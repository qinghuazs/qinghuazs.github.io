<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01.SpringBoot简介</title>
    <url>/2019/06/18/01.SpringBoot%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>Spring Boot 使您可以轻松地创建可独立运行的、生产级的基于 Spring 的应用程序。 我们对 Spring 平台和第三方库进行了封装，因此您可以轻松上手。 大多数 Spring Boot 应用程序只需要很少的 Spring 配置。</p>
<p>您可以使用 Spring Boot 创建 Java 应用程序，这些应用程序可以通过使用 <code>java -jar</code> 或更传统的 war 包形式部署启动。 我们还提供了一个命令行工具来运行 “spring 脚本”。</p>
<p>我们的主要目标是：</p>
<ul>
<li>为所有 Spring 开发提供快速且广泛的合适的入门体验</li>
<li>开箱即用，但是当默认值不能满足需求时，需要修改配置</li>
<li> 提供大型项目所共有的一系列非功能特性(如嵌入式服务器、安全性、度量、健康检查和外部化配置)</li>
<li> 绝对没有代码生成，也不需要 XML 配置</li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot翻译</category>
        <category>2.1.5.RELEASE</category>
      </categories>
      <tags>
        <tag>SpringBoot翻译</tag>
        <tag>2.1.5.RELEASE</tag>
      </tags>
  </entry>
  <entry>
    <title>02.SpringBoot系统要求</title>
    <url>/2019/06/18/02.SpringBoot%E7%B3%BB%E7%BB%9F%E8%A6%81%E6%B1%82/</url>
    <content><![CDATA[<p>Spring Boot 2.1.5.RELEASE 需要 JDK8 并且兼容 JDK11。Spring Framework 5.1.7.RELEASE 或更高的版本。</p>
<p>为以下构建工具提供了明确的构建支持：</p>
<table>
<thead>
<tr>
<th>构建工具</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>Maven</td>
<td>3.3+</td>
</tr>
<tr>
<td>Gradle</td>
<td>4.4+</td>
</tr>
</tbody></table>
<h3 id="Servlet-容器"><a href="#Servlet-容器" class="headerlink" title="Servlet 容器"></a>Servlet 容器</h3><p>Spring Boot 支持以下嵌入的Servlet容器：</p>
<table>
<thead>
<tr>
<th>容器</th>
<th>Servlet版本</th>
</tr>
</thead>
<tbody><tr>
<td>Tomcat 9.0</td>
<td>4.0</td>
</tr>
<tr>
<td>Jetty 9.4</td>
<td>3.1</td>
</tr>
<tr>
<td>Undertow 2.0</td>
<td>4.0</td>
</tr>
</tbody></table>
<p>您还可以将 Spring Boot 应用程序部署到任何兼容 Servlet 3.1以上的容器中。</p>
]]></content>
      <categories>
        <category>SpringBoot翻译</category>
        <category>2.1.5.RELEASE</category>
      </categories>
      <tags>
        <tag>SpringBoot翻译</tag>
        <tag>2.1.5.RELEASE</tag>
      </tags>
  </entry>
  <entry>
    <title>03.SpringBoot安装</title>
    <url>/2019/06/19/03.SpringBoot%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>Spring Boot 可以与”经典” Java 开发工具一起使用，也可以作为命令行工具安装。 无论哪种方式，您都需要 JDK1.8 或更高版本。 在开始之前，你应该使用以下命令检查你当前安装的JDK的版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -version</span></span><br></pre></td></tr></table></figure>

<h1 id="Java开发人员的安装说明"><a href="#Java开发人员的安装说明" class="headerlink" title="Java开发人员的安装说明"></a>Java开发人员的安装说明</h1><p>您可以以与任何标准 Java 库相同的方式使用 Spring Boot。 所以，请在 classpath 中包含适当的 <code>spring-boot-*.jar</code>。  Spring Boot 不需要任何特殊的工具集成，因此您可以使用任何 IDE 或文本编辑器。 此外，Spring Boot 应用程序没有什么特别之处，您可以像运行其他 Java 程序一样运行和调试 Spring Boot 应用程序。</p>
<p>虽然可以拷贝 Spring Boot 的 jar 包，但我们通常建议您使用支持依赖项管理的构建工具(例如 Maven 或 Gradle)。</p>
<h3 id="Maven-安装"><a href="#Maven-安装" class="headerlink" title="Maven 安装"></a>Maven 安装</h3><p>Spring Boot 兼容 Apache Maven 3.3 或更高版本，如果你还没有安装 Maven，可以按照 <a href="https://maven.apache.org/">maven.apache.org</a> 的说明进行操作。</p>
<blockquote>
<p>在许多操作系统上，Maven 可以通过一个包管理器进行安装。 如果你使用 OSX 自制程序，可以运行 <code>brew install maven</code> 指令。 Ubuntu 用户可以运行 <code>sudo apt-get install maven</code> 指令。 使用 <a href="https://chocolatey.org/">Chocolatey</a> 的 Windows 用户可以在 cmd 下运行 <code>choco install maven</code>。</p>
</blockquote>
<p>Spring Boot 依赖项使用 <code>org.springframework.boot</code> 作为 <code>groupId</code>。 通常，您的 Maven POM 文件继承自 <code>spring-boot-starter-parent</code> 项目，并声明对一个或多个 <a href="https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/htmlsingle/#using-boot-starter">“Starters”</a> 的依赖。 Spring Boot 还提供了一个可选的  <a href="https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/htmlsingle/#build-tool-plugins-maven-plugin">Maven plugin</a> 来创建可执行的 jar 文件。</p>
<p>下面是一个典型的 <code>pom.xml</code> 文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>myproject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- Inherit defaults from Spring Boot --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- Add typical dependencies for a web application --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- Package as an executable jar --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>spring-boot-starter-parent</code> 是使用 Spring Boot 的一个很好的方法，但它不可能在所有的时候都适用。 有时您可能需要从不同的父 POM 继承，或者您可能不喜欢我们的默认设置。 在这些情况下，请参阅<a href="https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/htmlsingle/#using-boot-maven-without-a-parent">第13.2.2节”在不使用父 POM 的情况下使用 Spring Boot”</a>，以获得使用 <code>import</code> 范围的替代解决方案。</p>
</blockquote>
<h2 id="安装Spring-Boot-CLI"><a href="#安装Spring-Boot-CLI" class="headerlink" title="安装Spring Boot CLI"></a>安装Spring Boot CLI</h2><p>Spring Boot CLI (命令行接口)是一个命令行工具，您可以使用它来快速构建 Spring 的样例。 支持运行 Groovy 脚本，这代表你可以使用类似 Java 的语法，而不需要太多的样板代码。</p>
<p>您不需要使用 CLI 来处理 Spring Boot，但它绝对是获得 Spring 应用程序的最快方法。</p>
<h3 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h3><p>你可以从 Spring 软件资源库下载 Spring CLI 发行版:</p>
<ul>
<li><a href="https://repo.spring.io/release/org/springframework/boot/spring-boot-cli/2.1.5.RELEASE/spring-boot-cli-2.1.5.RELEASE-bin.zip">spring-boot-cli-2.1.5.RELEASE-bin.zip</a></li>
<li><a href="https://repo.spring.io/release/org/springframework/boot/spring-boot-cli/2.1.5.RELEASE/spring-boot-cli-2.1.5.RELEASE-bin.tar.gz">spring-boot-cli-2.1.5.RELEASE-bin.tar.gz</a></li>
</ul>
<p>也可以使用最新的快照版本（<a href="https://repo.spring.io/snapshot/org/springframework/boot/spring-boot-cli/">snapshot distributions</a> ）</p>
<p>下载完成后，请按照未打包的归档文件中的 INSTALL.txt 说明进行操作。 一般情况下，<code>.zip</code> 文件中有一个 <code>bin</code> 文件夹，在该文件夹下存放了一个 <code> spring</code> 脚本(<code>spring.bat</code> ,Windows平台下使用)。 或者，在遇到 <code>.jar</code> 时您可以使用 <code>java -jar</code> (<strong>该脚本可以帮助您确保classpath设置正确</strong>)。</p>
<h3 id="安装-SDKMAN"><a href="#安装-SDKMAN" class="headerlink" title="安装 SDKMAN"></a>安装 SDKMAN</h3><p>SDKMAN!（The Software Development Kit Manager）能帮您管理各种版本的二进制 SDK，包括 Groovy 和 Spring Boot CLI。从 <a href="https://sdkman.io/">sdkman.io</a> 可以获取 SDKMAN! ，然后运行以下命令来安装 Spring Boot：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sdk install springboot</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">spring --version</span></span><br><span class="line">Spring Boot v2.1.5.RELEASE</span><br></pre></td></tr></table></figure>

<p>如果您为 CLI 开发特性并希望方便地访问您构建的版本，请使用以下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sdk install springboot dev /path/to/spring-boot/spring-boot-cli/target/spring-boot-cli-2.1.5.RELEASE-bin/spring-2.1.5.RELEASE/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sdk default springboot dev</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">spring --version</span></span><br><span class="line">Spring CLI v2.1.5.RELEASE</span><br></pre></td></tr></table></figure>

<p>通过上面的指令安装一个 <code>spring</code> 的本地实例，称为 <code>dev</code> 实例。 它指向您的目标构建位置，因此每次重新构建 Spring Boot 时，<code>Spring</code> 都是最新的。</p>
<p>你可以通过运行以下命令来查看它:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sdk <span class="built_in">ls</span> springboot</span></span><br><span class="line"></span><br><span class="line">================================================================================</span><br><span class="line">Available Springboot Versions</span><br><span class="line">================================================================================</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">+ dev</span></span><br><span class="line">* 2.1.5.RELEASE</span><br><span class="line"></span><br><span class="line">================================================================================</span><br><span class="line">+ - local version</span><br><span class="line">* - installed</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">- currently <span class="keyword">in</span> use</span></span><br><span class="line">================================================================================</span><br></pre></td></tr></table></figure>

<h3 id="OSX-Homebrew安装"><a href="#OSX-Homebrew安装" class="headerlink" title="OSX Homebrew安装"></a>OSX Homebrew安装</h3><p>如果你在 Mac 电脑上使用 <a href="https://brew.sh/">Homebrew</a>，则可以使用以下指令安装 Spring Boot CLI：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brew tap pivotal/tap</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brew install springboot</span></span><br></pre></td></tr></table></figure>

<p>Homebrew 会将 Spring 安装到 <code>/usr/local/bin</code> 目录。</p>
<blockquote>
<p>如果您没有看到该公式，您安装的 brew 可能已经过时了。 在这种情况下，运行 <code>brew update</code>， 然后再试一次。</p>
</blockquote>
<h3 id="MacPorts-安装"><a href="#MacPorts-安装" class="headerlink" title="MacPorts 安装"></a>MacPorts 安装</h3><p>如果你在 Mac 上使用 <a href="https://www.macports.org/">MacPorts</a>，你可以使用以下命令安装 Spring Boot CLI:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo port install spring-boot-cli</span></span><br></pre></td></tr></table></figure>

<h3 id="命令行补全"><a href="#命令行补全" class="headerlink" title="命令行补全"></a>命令行补全</h3><p>Spring Boot CLI 中包含了为 BASH 和 zsh 提供命令补全的脚本。 您可以在任何 shell 中 <code>source</code> 这些脚本(也称为 <code>spring</code> ) ，或者将其放入个人或系统范围的 bash 补全初始化中。 在 Debian 系统上，系统范围的脚本在 <code>/shell-completion/bash</code> 中，当新的 shell 启动时，该目录中的所有脚本都将执行。 例如，如果您已经使用 SDKMAN 安装了脚本，那么可以使用以下命令手动运行该脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">. ~/.sdkman/candidates/springboot/current/shell-completion/bash/spring</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">spring &lt;HIT TAB HERE&gt;</span></span><br><span class="line">  grab  help  jar  run  test  version</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你使用 Homebrew 或者 MacPorts 来安装 Spring Boot CLI，命令行补全脚本会自动注册到你的 shell 中。</p>
</blockquote>
<h3 id="快速启用-Spring-CLI-示例"><a href="#快速启用-Spring-CLI-示例" class="headerlink" title="快速启用 Spring CLI 示例"></a>快速启用 Spring CLI 示例</h3><p>您可以使用以下 web 应用程序来测试您的安装是否成功。 首先，创建一个 <code>app.groovy</code> 文件，如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThisWillActuallyRun</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">	String <span class="title function_">home</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后以 shell 形式运行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">spring run app.groovy</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>应用程序的第一次运行速度很慢，因为要下载依赖项。 后续的运行速度要快得多。</p>
</blockquote>
<p>在浏览器中打开 <code>localhost: 8080</code> ，您应该看到以下输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure>

<h2 id="SpringBoot-版本升级"><a href="#SpringBoot-版本升级" class="headerlink" title="SpringBoot 版本升级"></a>SpringBoot 版本升级</h2><p>如果您正在从早期版本的 Spring Boot 升级，请查看项目 wiki 上的<a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide">迁移指南</a>，该指南提供了详细的升级说明。 还要检查<a href="https://github.com/spring-projects/spring-boot/wiki">发行说明</a>以获得每个版本的<strong>新的和值得注意的</strong>特性列表。</p>
<p>当升级到新的特性版本时，一些属性可能已被重命名或删除。 Spring Boot 提供了一种在启动时分析应用程序环境和打印诊断信息的方法，而且还可以在运行时为您临时迁移属性。 要启用该特性，请在项目中添加以下依赖项:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-properties-migrator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>后期添加到环境中的属性(例如在使用 <code>@PropertySource</code> 时)将不会被考虑。</p>
</blockquote>
<blockquote>
<p>迁移完成后，请确保从项目的依赖项中删除此模块。</p>
</blockquote>
<p>要升级已安装的 CLI ，请使用适当的包管理器命令(例如，<code>brew upgrade</code>) ，或者，如果您手动安装了 CLI，请按照<a href="https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/htmlsingle/#getting-started-manual-cli-installation">标准说明</a>进行升级，记住更新 <code>PATH</code> 环境变量以删除任何旧的引用。</p>
]]></content>
      <categories>
        <category>SpringBoot翻译</category>
        <category>2.1.5.RELEASE</category>
      </categories>
      <tags>
        <tag>SpringBoot翻译</tag>
        <tag>2.1.5.RELEASE</tag>
      </tags>
  </entry>
  <entry>
    <title>04.开发你的第一个SpringBoot应用</title>
    <url>/2019/06/19/04.%E5%BC%80%E5%8F%91%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AASpringBoot%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>本节主要内容是如何通过开发一个简单的”Hello World!” web应用突出Spring Boot 的一些关键特性。 我们使用 Maven 来构建这个项目，因为大多数 IDE 都支持它。</p>
<blockquote>
<p><a href="https://spring.io/">spring.io</a> 网站包含了许多使用 Spring Boot 的”入门”<a href="https://spring.io/guides">指南</a>。 如果你需要解决一个特定的问题，首先检查那里。</p>
<p>通过访问 <a href="https://start.spring.io/">start.spring.io</a> 并从依赖项查询中选择”Web”starter，可以快捷地完成以下步骤。 这样做会生成一个新的项目结构，以便您可以立即开始编码。 查看 <a href="https://docs.spring.io/initializr/docs/current/reference/html/#user-guide">Spring Initializr 文档</a>了解更多细节。</p>
</blockquote>
<p>在我们开始之前，打开一个终端并运行以下命令，以确保你已经安装了 Java 和 Maven 的有效版本:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -version</span></span><br><span class="line">java version &quot;1.8.0_102&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_102-b14)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.102-b14, mixed mode)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mvn -v</span></span><br><span class="line">Apache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-17T14:33:14-04:00)</span><br><span class="line">Maven home: /usr/local/Cellar/maven/3.3.9/libexec</span><br><span class="line">Java version: 1.8.0_102, vendor: Oracle Corporation</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个示例需要在它自己的文件夹中创建。 接下来的介绍假设你已经创建了一个合适的文件夹，并且这个文件夹就是你的工作目录。</p>
</blockquote>
<h2 id="创建-POM-文件"><a href="#创建-POM-文件" class="headerlink" title="创建 POM 文件"></a>创建 POM 文件</h2><p>我们首先需要创建一个 Maven <code>pom.xml</code> 文件。<code>pom.xml</code> 是用于构建项目的配方。 打开文本编辑器，添加以下内容:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>myproject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- Additional lines to be added here... --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>pom.xml</code> 文件会为您提供一个工作构建。 您可以通过运行 <code>mvn package</code> 来测试它(现在，您可以先忽略 “jar will be empty - no content was marked for inclusion!” 的警告)。</p>
<blockquote>
<p>现在，您可以将项目导入到 IDE 中(大多数Java IDE 都包含对 Maven 的内置支持)。 为了简单起见，我们继续使用纯文本编辑器。</p>
</blockquote>
<h2 id="添加-Classpath-依赖"><a href="#添加-Classpath-依赖" class="headerlink" title="添加 Classpath 依赖"></a>添加 Classpath 依赖</h2><p>Spring Boot 提供了很多 “Starter”，你可以将这些 jar 包添加到 classpath 中。在本例中，我们已经在 POM 文件的 <code>parent</code> 标签中使用了 <code>spring-boot-starter-parent</code>。<code>spring-boot-starter-parent</code> 是一个特殊的 Starter，它提供了一些有用的Maven的默认值。同时也提供了一个 <code>dependency-management</code> 标签，这些你可以省略部分依赖的 <code>version</code> 标记。</p>
<p>其他 “Starter” 提供了在开发特定类型的应用程序时可能需要的依赖项。 因为我们正在开发一个 web 应用程序，所以我们添加了一个 <code>spring-boot-starter-web</code> 依赖项。 在此之前，我们可以通过运行以下命令查看我们当前已有的内容:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mvn dependency:tree</span></span><br><span class="line"></span><br><span class="line">[INFO] com.example:myproject:jar:0.0.1-SNAPSHOT</span><br></pre></td></tr></table></figure>

<p><code>mvn dependency:tree</code> 命令以树的形式展示当前项目的依赖项。 您可以看到，<code>spring-boot-starter-parent</code> 本身并不提供任何依赖性。 要添加必要的依赖项，请编辑 <code>pom.xml</code> 并在 <code>&lt;parent&gt;</code> 节点下面添加 <code>spring-boot-starter-web</code> 依赖项:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果再次运行 <code>mvn dependency:tree</code> ，您会看到现在有许多附加的依赖项，包括 Tomcat web 服务器和 Spring Boot 本身。</p>
<h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><p>为了完成我们的应用程序，我们需要创建一个 Java 文件。 默认情况下，Maven 从 <code>src/main/java</code> 下编译源代码，因此需要创建该文件夹结构，然后添加一个名为 <code>src/main/java/Examole.java</code> 的文件，该文件内容如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">	String <span class="title function_">home</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SpringApplication.run(Example.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这里没有很多代码，但是有很多事情正在进行。 在接下来的几节中，我们将逐步介绍重要的部分。</p>
<h3 id="RestController-和-RequestMapping-注解"><a href="#RestController-和-RequestMapping-注解" class="headerlink" title="@RestController 和 @RequestMapping 注解"></a>@RestController 和 @RequestMapping 注解</h3><p><code>Example</code> 类的第一个注解是 <code>@RestController</code>。 这是一个称为 <em>stereotype</em> 注解。 它为阅读代码的人提供了提示；对 Spring 来说，它提供了特殊的角色。 在这种情况下，我们的类是一个 web <code>@Controller</code>，因此 Spring 在处理传入的 web 请求时会考虑它。</p>
<p><code>@RequestMapping</code> 注解提供”路由”信息。 它告诉 Spring，任何带有 <code>/</code> 路径的 HTTP 请求都应该映射到 <code>home</code> 方法。<code>@RestController</code> 注解告诉 Spring 将结果以字符串的形式直接返回给调用方。</p>
<blockquote>
<p><code>@RestController </code>和 <code>@RequestMapping</code> 注解是 Spring MVC 的注解。 (它们不是 Spring Boot 特有的。) 有关更多细节，请参见 Spring 参考文档中的 <a href="https://docs.spring.io/spring/docs/5.1.7.RELEASE/spring-framework-reference/web.html#mvc">MVC 部分</a>。</p>
</blockquote>
<h3 id="EnableAutoConfiguration-注解"><a href="#EnableAutoConfiguration-注解" class="headerlink" title="@EnableAutoConfiguration 注解"></a>@EnableAutoConfiguration 注解</h3><p>第二个类级别的注解是 <code>@EnableAutoConfiguration</code>。 这个注解告诉 Spring Boot 根据你添加的 jar 依赖项”猜测”您希望如何配置 Spring。 由于 <code>spring-boot-starter-web</code> 添加了 Tomcat 和 Spring MVC，因此自动装配假定您正在开发 web 应用程序并相应地设置 Spring。</p>
<blockquote>
<p>Starter 和 自动装配</p>
<p>自动装配被设计成与”Starter”一起工作，但是这两个概念并没有直接联系在一起。 您可以在 Starter 之外自由选择 jar 依赖项。 Spring Boot 仍然尽最大努力自动配置应用程序。</p>
</blockquote>
<h3 id="“main”-方法"><a href="#“main”-方法" class="headerlink" title="“main” 方法"></a>“main” 方法</h3><p>我们应用的最后一部分是 <code>main</code> 方法。 这只是遵循 Java 约定的应用程序入口点的标准方法。 我们的主方法委托给Spring Boot 的 <code>SpringApplication</code> 类，通过调用 <code>run</code> 来实现。 <code>SpringApplication</code> 启动我们的应用程序，启动 Spring，然后启动自动配置的 Tomcat web 服务器。 我们需要将 <code>Example.class</code> 作为参数传递给 <code>run</code> 方法，以告诉 <code>SpringApplication</code> 哪个是主 Spring 组件。  <code>args</code> 数组暴露出来以接收命令行参数。</p>
<h2 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a>运行示例</h2><p>此时，您的应用程序应该可以工作了。 由于使用了 <code>spring-boot-starter-parent</code> POM，因此可以使用一个有用的 <code>run</code> 目标来启动应用程序。 输入 <code>mvn spring-boot:run</code> 从根项目目录启动应用程序。 你应该看到类似下面的输出:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mvn spring-boot:run</span></span><br><span class="line"></span><br><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> /\\ / ___&#x27;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ | &#x27;_ | &#x27;_| | &#x27;_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  &#x27;  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="line"> =========|_|==============|___/=/_/_/_/</span><br><span class="line"> :: Spring Boot ::  (v2.1.5.RELEASE)</span><br><span class="line">....... . . .	</span><br><span class="line">....... . . . (log output here)</span><br><span class="line">....... . . .</span><br><span class="line">........ Started Example in 2.222 seconds (JVM running for 6.514)</span><br></pre></td></tr></table></figure>

<p>打开web 浏览器访问 <code>localhost: 8080</code>，可以看到如下输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure>

<p>可以按 <code>ctrl-c</code>退出应用程序。</p>
<h2 id="创建一个可执行-Jar"><a href="#创建一个可执行-Jar" class="headerlink" title="创建一个可执行 Jar"></a>创建一个可执行 Jar</h2><p>我们通过创建一个完全自包含的可执行 jar 文件来完成示例，该文件可以在生产环境中运行。 可执行的 jar (有时称为”fat jars”)是存档文件，其中包含您编译的类以及您的代码需要运行的所有 jar 依赖项。</p>
<blockquote>
<p>可执行的 jar 和 Java<br>Java 没有提供加载嵌套 jar 文件(jar 文件本身包含在 jar 中)的标准方法。 如果您希望分发一个自包含的应用程序，这可能会有问题。<br>为了解决这个问题，许多开发人员使用”超级”罐子(uber jar)。 一个 uber jar 将应用程序的所有依赖项的所有类打包到一个归档文件中。这种方法的问题在于，很难看到应用程序中有哪些库。如果在多个 jar 中使用相同的文件名(但内容不同) ，也会出现问题。<br>Spring Boot 采用了一种<a href="https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/htmlsingle/#executable-jar">不同的方法</a>，它可以让您直接嵌套 jar。</p>
</blockquote>
<p>要创建一个可执行的 jar，我们需要将 <code>spring-boot-maven-plugin</code> 添加到 <code>pom.xml</code> 中。 为此，在 <code>dependencies</code> 部分下面插入以下行:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>spring-boot-starter-parent</code> POM 包括 <code>&lt;executions&gt;</code> 配置用于绑定 <code>repackage</code> 目标。 如果不使用父 POM，则需要自己声明此配置。 有关详细信息，请参阅<a href="https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/maven-plugin/usage.html">插件文档</a>。</p>
</blockquote>
<p>保存 <code>pom.xml</code> 并从命令行运行 <code>mvn package</code>，如下所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mvn package</span></span><br><span class="line"></span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Building myproject 0.0.1-SNAPSHOT</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] .... ..</span><br><span class="line">[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ myproject ---</span><br><span class="line">[INFO] Building jar: /Users/developer/example/spring-boot-example/target/myproject-0.0.1-SNAPSHOT.jar</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- spring-boot-maven-plugin:2.1.5.RELEASE:repackage (default) @ myproject ---</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>如果查看 <code>target</code> 目录，应该会看到 <code>myproject-0.0.1-SNAPSHOT.jar</code>。 文件大小应该在10MB 左右。 如果你想查看jar 包内部的信息，你可以使用 <code>jar tvf</code>，如下所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">jar tvf target/myproject-0.0.1-SNAPSHOT.jar</span></span><br></pre></td></tr></table></figure>

<p>在 <code>target</code> 目录下，您还应该看到一个更小的文件，名为 <code>myproject-0.0.1-SNAPSHOT.jar.original</code>。 这是 Maven 在被 Spring Boot 重新打包之前创建的原始 jar 文件。</p>
<p>要运行该应用程序，请使用 <code>java-jar</code> 命令，如下所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -jar target/myproject-0.0.1-SNAPSHOT.jar</span></span><br><span class="line"></span><br><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> /\\ / ___&#x27;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ | &#x27;_ | &#x27;_| | &#x27;_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  &#x27;  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="line"> =========|_|==============|___/=/_/_/_/</span><br><span class="line"> :: Spring Boot ::  (v2.1.5.RELEASE)</span><br><span class="line">....... . . .</span><br><span class="line">....... . . . (log output here)</span><br><span class="line">....... . . .</span><br><span class="line">........ Started Example in 2.536 seconds (JVM running for 2.864)</span><br></pre></td></tr></table></figure>

<p>可以按<code>ctrl-c</code> 退出应用程序。</p>
]]></content>
      <categories>
        <category>SpringBoot翻译</category>
        <category>2.1.5.RELEASE</category>
      </categories>
      <tags>
        <tag>SpringBoot翻译</tag>
        <tag>2.1.5.RELEASE</tag>
      </tags>
  </entry>
  <entry>
    <title>05.如何使用Spring Boot - Maven</title>
    <url>/2020/01/10/05.%E4%BD%BF%E7%94%A8SpringBoot/</url>
    <content><![CDATA[<p>本节将更详细地介绍如何使用 Spring Boot。 它涵盖了诸如构建系统、自动配置以及如何运行应用程序等内容。 此外，还介绍了一些 Spring Boot 的最佳实践。 尽管 Spring Boot 没有什么特别之处(它只是您可以使用的另一个库) ，但是有一些建议可以使您的开发过程更容易一些 。</p>
<p>如果你之前没有使用过 Spring Boot，那么在看这部分内容之前，你应该先阅读下<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/html/getting-started.html#getting-started">入门指南</a></p>
<h3 id="构建系统"><a href="#构建系统" class="headerlink" title="构建系统"></a>构建系统</h3><p>强烈建议您选择一个支持依赖管理的构建系统，该系统可以使用发布到 Maven 中央库的依赖。 我们建议你选择 Maven 或 Gradle。Spring Boot 也支持其他构建系统，例如 Ant，但是它们并没有得到特别好的支持。 </p>
<blockquote>
<p>因为公司目前只用Maven，所以Gradle和Ant的方式不做翻译了</p>
</blockquote>
<h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p> Spring  Boot 的每个版本都提供了它所支持的经过精心策划的依赖项列表。 实际上，您不需要为构建配置中的任何依赖项提供版本信息，因为 Spring Boot 已经为您管理了这些依赖项。 当您升级 Spring Boot 时，这些依赖关系也会随之升级。 </p>
<blockquote>
<p> 如果需要的话，您仍然可以指定一个版本并覆盖 Spring Boot 提供的版本。</p>
</blockquote>
<p>这个精选列表包含所有可以用于 Spring Boot 的 Spring 模块，以及第三方库的精选列表。 该列表是一个可用于 Maven 和 Gradle的标准的材料账单(<code>spring-boot-dependencies</code>)。 </p>
<blockquote>
<p>Spring Boot 的每个版本都与 Spring 框架的基本版本高度关联， 建议您不要指定它的版本 </p>
</blockquote>
<h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><p>Maven 用户可以通过继承 <code>spring-boot-starter-parent</code> 项目来获得合理的默认值。 父项目具有以下特点: </p>
<ul>
<li>默认的编译级别是 Java 1.8</li>
<li>编码格式为 UTF-8</li>
<li>从 <code>spring-boot-dependencies</code> pom 继承而来的<a href="#%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86">依赖管理</a>部分，用于管理公共依赖项的版本。 这种依赖项管理允许您在自己的 pom 中引入依赖时忽略<code>&lt;version&gt;</code>标记。 </li>
<li>带有 <code>repackage</code>  执行 id 的 <code>repackage</code>  目标的执行</li>
<li>可感知的<a href="https://maven.apache.org/plugins/maven-resources-plugin/examples/filter.html">资源过滤</a></li>
<li>合理的插件配置（ <a href="https://www.mojohaus.org/exec-maven-plugin/">exec plugin</a>, <a href="https://github.com/ktoso/maven-git-commit-id-plugin">Git commit ID</a>,  <a href="https://maven.apache.org/plugins/maven-shade-plugin/">shade</a> ）</li>
<li>对 <code>application.properties</code> 和 <code>application.yml</code> 进行合理的资源筛选，包括特定的配置文件(例如，<code>application-dev.properties</code> 和 <code>application-dev.yml </code> )</li>
</ul>
<p>注意，因为 <code>application.properties</code> 和 <code>application.yml</code> 文件接受 Spring 风格的占位符( <code>$&#123;…&#125;</code> ) ，所以 Maven 过滤标识被更改为使用 <code>@..@</code> 占位符 (可以通过设置一个名为 <code>resource.delimiter</code>的 Maven 属性来覆盖该属性)。 </p>
<h4 id="继承-Starter-父类"><a href="#继承-Starter-父类" class="headerlink" title="继承 Starter 父类"></a>继承 Starter 父类</h4><p> 若要将项目配置为从 <code>spring-boot-starter-parent</code> 继承，请将 parent 设置如下: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Inherit defaults from Spring Boot --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 您应该只需要通过这个依赖指定 Spring Boot 版本号。如果导入其他 starter 依赖，您可以省略版本号 </p>
</blockquote>
<p> 使用该设置，还可以通过重写自己项目中的属性来重写单个依赖项。 例如，要升级到另一个 Spring Data 版本，可以在 <code>pom.xml</code> 中添加以下内容: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-data-releasetrain.version</span>&gt;</span>Fowler-SR2<span class="tag">&lt;/<span class="name">spring-data-releasetrain.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 检查<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-dependencies/pom.xml"><code>spring-boot-dependencies</code> pom</a>文件获取受支持的属性列表</p>
</blockquote>
<h4 id="使用没有父-POM-的-Spring-Boot"><a href="#使用没有父-POM-的-Spring-Boot" class="headerlink" title="使用没有父 POM 的 Spring Boot"></a>使用没有父 POM 的 Spring Boot</h4><p>并不是每个人都喜欢继承<code> spring-boot-starter-parent</code> POM， 您可能需要使用自己的企业标准父级，或者您可能更喜欢显式声明所有 Maven 配置。 </p>
<p>如果你不想使用 <code>spring-boot-starter-parent</code> ，你可以通过 <code>scope=import</code> 的方式来从依赖管理（不是插件管理）中受益，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Import dependency management from Spring Boot --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如上所述，前面的示例程序不允许使用属性重写单个依赖项。 要实现相同的结果，您需要在 <code>spring-boot-dependencies</code> 依赖之前在项目的 <code>dependencyManagement</code> 中添加一个条目。 例如，要升级到另一个 Spring Data 发布系列，可以在 <code>pom.xml</code> 中添加以下元素: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Override Spring Data release train provided by Spring Boot --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-releasetrain<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Fowler-SR2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在前面的例子中，我们指定了一个BOM，任务依赖类型都可以以相同的方式来重写</p>
</blockquote>
<h4 id="使用-Spring-Boot-Maven-插件"><a href="#使用-Spring-Boot-Maven-插件" class="headerlink" title="使用 Spring Boot Maven 插件"></a>使用 Spring Boot Maven 插件</h4><p> Spring Boot 包含一个 Maven 插件，可以将项目打包为一个可执行 jar。 如果你想使用这个插件，可以把它添加到你的插件部分，如下面的例子所示: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你使用 Spring Boot starter 父 pom，你只需要添加插件，没有必要配置它，除非您想要更改在父级中定义的设置 </p>
</blockquote>
]]></content>
      <categories>
        <category>SpringBoot翻译</category>
        <category>2.2.2.RELEASE</category>
      </categories>
      <tags>
        <tag>SpringBoot翻译</tag>
        <tag>2.2.2.RELEASE</tag>
      </tags>
  </entry>
  <entry>
    <title>06. Starters</title>
    <url>/2020/01/14/06.Starters/</url>
    <content><![CDATA[<p>Starters是一组可以包含在应用程序中的方便的依赖描述符。 您可以获得所有 Spring 和相关技术的一站式服务，而无需遍历示例代码和复制粘贴大量依赖描述符。 例如，如果您希望开始使用 Spring 和 JPA 进行数据库访问，那么可以在项目中包含 <code>spring-boot-starter-data-jpa</code> 依赖项。 </p>
<p>starters 中包含了许多依赖项，您需要这些依赖项来快速启动和运行项目，并且具有一致的、受支持的托管传递依赖项集合。 </p>
<blockquote>
<p>官方的 Starter 遵循 <code>spring-boot-starter-*</code> 的命名模式，如 <code>spring-boot-starter-data-jpa</code> 。第三方的 Starter 通常以自己的项目名称开始，例如，名为 thirdpartyproject 的第三方入门项目通常被命名为 <code>thirdpartyproject-spring-boot-starter</code>。 </p>
</blockquote>
<h3 id="Spring-Boot-应用程序-starter"><a href="#Spring-Boot-应用程序-starter" class="headerlink" title="Spring Boot 应用程序 starter"></a>Spring Boot 应用程序 starter</h3><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>spring-boot-starter</td>
<td>核心starter，包括自动配置支持，日志和 YAML</td>
</tr>
<tr>
<td>spring-boot-starter-activemq</td>
<td>使用 Apache ActiveMQ 实现 JMS 消息传递的starter</td>
</tr>
<tr>
<td>spring-boot-starter-amqp</td>
<td>使用 Spring AMQP 和 Rabbit MQ 的starter</td>
</tr>
<tr>
<td>spring-boot-starter-aop</td>
<td>带有 Spring AOP 和 AspectJ 的面向切面编程的starter</td>
</tr>
<tr>
<td>spring-boot-starter-artemis</td>
<td>使用 Apache Artemis 的 JMS 消息传递starter</td>
</tr>
<tr>
<td>spring-boot-starter-batch</td>
<td>基于 Spring Batch 实现的 starter</td>
</tr>
<tr>
<td>spring-boot-starter-web</td>
<td>用于构建 web 的入门程序，包括 RESTful，使用 Spring MVC 的<br />应用程序。 使用 Tomcat 作为默认的嵌入式容器</td>
</tr>
<tr>
<td>spring-boot-starter-validation</td>
<td>使用 Hibernate Validator 进行 javabean 验证的启动器</td>
</tr>
<tr>
<td>spring-boot-starter-webflux</td>
<td>用于使用 Spring 框架的 Reactive Web 支持构建 WebFlux 应用程序的starter</td>
</tr>
</tbody></table>
<p>Starter 比较多，就不一一列举了，需要的话，可以自行去<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/html/using-spring-boot.html#using-boot-starter">spring-boot-starter</a>查询，另外还有很多第三方的starter，Spring 官网查不到的，需要去对应的开源网站或者官方网站查询。</p>
]]></content>
      <categories>
        <category>SpringBoot翻译</category>
        <category>2.2.2.RELEASE</category>
      </categories>
      <tags>
        <tag>SpringBoot翻译</tag>
        <tag>2.2.2.RELEASE</tag>
      </tags>
  </entry>
  <entry>
    <title>07.结构化代码</title>
    <url>/2020/01/16/07.%E7%BB%93%E6%9E%84%E5%8C%96%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>Spring Boot 不需要任何特定的代码布局就可以工作。 然而，有一些最佳实践可以帮助你。 </p>
<h4 id="使用默认package"><a href="#使用默认package" class="headerlink" title="使用默认package"></a>使用默认package</h4><p>当一个类不包含 <code>package</code> 声明时，它被认为是在“默认包”中。 通常不鼓励使用“默认包” ，并且应该避免使用。 对于使用 <code>@ComponentScan</code>、<code>@configurationPropertiesScan</code>、<code>@EntityScan</code> 或<code>@SpringBootApplication</code> 注解的 Spring Boot 应用程序，它可能会导致特殊的问题，因为每个 jar 的每个类都会被读取。 </p>
<blockquote>
<p> 建议您遵循 Java 推荐的包命名约定，并使用反向域名，例如 <code>com.example.project</code> </p>
</blockquote>
<h4 id="定位主程序类"><a href="#定位主程序类" class="headerlink" title="定位主程序类"></a>定位主程序类</h4><p>我们通常建议您将主程序类定位在根包中，位于其他类之上。 <code>@SpringBootApplication</code> 注解通常放在您的主类上，它隐式地为某些项定义一个基本的“搜索包”。 例如，如果您正在编写一个 JPA 应用程序，可以使用 <code>@SpringBootApplication</code> 注解类的包来搜索<code>@Entity</code> 项。 使用根包还允许组件扫描只应用于项目。</p>
<blockquote>
<p> 如果你不想使用 <code>@SpringBootApplication</code> ， <code>@EnableAutoConfiguration</code> 和   <code>@ComponentScan</code> 注解提供了相同和功能，可以使用这两个注解来代替 <code>@SpringBootApplication</code></p>
</blockquote>
<p>下面显示了一个典型的布局: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com</span><br><span class="line"> +- example</span><br><span class="line">     +- myapplication</span><br><span class="line">         +- Application.java</span><br><span class="line">         |</span><br><span class="line">         +- customer</span><br><span class="line">         |   +- Customer.java</span><br><span class="line">         |   +- CustomerController.java</span><br><span class="line">         |   +- CustomerService.java</span><br><span class="line">         |   +- CustomerRepository.java</span><br><span class="line">         |</span><br><span class="line">         +- order</span><br><span class="line">             +- Order.java</span><br><span class="line">             +- OrderController.java</span><br><span class="line">             +- OrderService.java</span><br><span class="line">             +- OrderRepository.java</span><br></pre></td></tr></table></figure>

<p><code>Application.java</code> 文件声明了一个 <code>main</code> 方法和 <code>@SpringBootApplication</code> ，如下所示：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapplication;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>全篇的意思就是：<strong>在SpringBoot应用中不要使用无package声明的类，不然可能会导致SpringBoot应用启动时无法扫描到这些类；SpringBoot的主类要放在最外层的包目录下，其他模块在该包下再创建子包。</strong></p>
]]></content>
      <categories>
        <category>SpringBoot翻译</category>
        <category>2.2.2.RELEASE</category>
      </categories>
      <tags>
        <tag>SpringBoot翻译</tag>
        <tag>2.2.2.RELEASE</tag>
      </tags>
  </entry>
  <entry>
    <title>08.配置类</title>
    <url>/2020/01/17/08.%E9%85%8D%E7%BD%AE%E7%B1%BB/</url>
    <content><![CDATA[<p>Spring Boot 支持基于Java的配置。虽然可以将 <code>SpringApplication</code> 与 XML 配置文件一起使用，但是我们通常建议你使用 <code>@Configuration</code> 类来定义配置信息；通常定义<code>main</code> 方法的类是一个很好的作为主要<code>@Configuration</code> 的候选类。</p>
<blockquote>
<p>网络上已经有很多使用XML配置的Spring案例，如果可能的话，将这些案例尝试使用基于Java配置的形式来实现。在网络上搜索<code>Enable*</code>注解是一个很好的起点。</p>
</blockquote>
<h3 id="导入额外的配置类"><a href="#导入额外的配置类" class="headerlink" title="导入额外的配置类"></a>导入额外的配置类</h3><p>您不必将所有 <code>@Configuration</code> 都放在一个类中，可以使用 <code>@Import</code> 注解导入其他配置类，或者，您可以使用<code>@ComponentScan</code> 自动扫描所有 Spring 组件，包括 <code>@Configuration</code>类。 </p>
<h4 id="Import注解"><a href="#Import注解" class="headerlink" title="@Import注解"></a><code>@Import</code>注解</h4><p><code>@Import</code> 注解相当于 XML 配置中的 <code>&lt;import&gt;</code> 标签，可以导入其他配置文件中的配置，避免所有配置都写在一个配置文件或配置类中。该注解也可以将普通的类声明为一个bean。</p>
<h5 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoService</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="将类声明为Bean"><a href="#将类声明为Bean" class="headerlink" title="将类声明为Bean"></a>将类声明为Bean</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(DemoService.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样Spring容器启动时就会将<code>DemoService</code>类加载到容器中</p>
<p><img src="https://images.gitee.com/uploads/images/2020/0117/231048_ba62f420_1305976.png" alt="输入图片说明" title="import注解图示.png"></p>
<blockquote>
<p><code>@Import(DemoService.class)</code>这种写法的效果和 <code>@Bean</code> 的效果相同</p>
</blockquote>
<h3 id="导入XML配置"><a href="#导入XML配置" class="headerlink" title="导入XML配置"></a>导入XML配置</h3><p> 如果您必须使用基于 XML 的配置，我们建议您仍然从 <code>@Configuration</code> 类开始。 然后可以使用<code>@ImportResource</code> 注解加载 XML 配置文件，将XML中配置的类和属性加载到容器中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource(locations=&#123;&quot;classpath:applicationContext.xml&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XmlConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringBoot翻译</category>
        <category>2.2.2.RELEASE</category>
      </categories>
      <tags>
        <tag>SpringBoot翻译</tag>
        <tag>2.2.2.RELEASE</tag>
      </tags>
  </entry>
  <entry>
    <title>09.自动配置</title>
    <url>/2020/01/17/09.%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>Spring Boot 自动配置目的是根据添加的 jar 依赖项自动配置 Spring 应用程序。 例如，如果 <code>HSQLDB</code> 位于<code>classpath</code>上，而你没有手动配置任何数据库连接 bean，那么 Spring Boot 将自动配置一个内存数据库。 </p>
<p>您需要通过向	<code>@Configuration</code> 类中添加<code>@EnableAutoConfiguration</code> 或<code>@SpringBootApplication</code> 注解来选择自动配置。 </p>
<blockquote>
<p> 你应该只添加一个·<code>@SpringBootApplication</code> 或<code>@EnableAutoConfiguration</code> 注解，通常建议 你将其中一个添加到你的主 <code>@Configuration</code> 类中。</p>
</blockquote>
<h3 id="逐渐取代自动配置"><a href="#逐渐取代自动配置" class="headerlink" title="逐渐取代自动配置"></a>逐渐取代自动配置</h3><p>自动配置是非侵入性的。 在任何时候，您都可以定义自己的配置，以替换自动配置的特定部分。 例如，如果您添加自己的 <code>DataSource</code> bean，则默认的嵌入式数据库支持将失效。</p>
<p>如果您需要了解当前应用的自动配置了哪些内容，以及为什么会自动配置，那么可以使用 <code>--debug</code> 开关启动应用程序。 这样做可以为选择的核心日志记录器启用调试日志，并将日志输出到控制台。 </p>
<h3 id="禁用特定的自动配置类"><a href="#禁用特定的自动配置类" class="headerlink" title="禁用特定的自动配置类"></a>禁用特定的自动配置类</h3><p>如果您发现您不想要的特定自动配置类正在被应用，您可以使用 <code>@SpringBootApplication</code> 的 <code>exclude</code> 属性来禁用它们，如下面的示例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.jdbc.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication(exclude=&#123;DataSourceAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果类不在 classpath 下，则可以使用 <code>excludeName</code> 属性并指定完全限定名。 如果您更喜欢使用<code>@EnableAutoConfiguration</code>而不是<code>@SpringBootApplication</code> ，也可以使用 <code>exclude</code> 和  <code>excludeName</code>，此外，还可以使用 <code>spring.autoconfigure.exclude</code> 属性控制要排除的自动配置类列表。</p>
<blockquote>
<p>可以在注释级别和通过使用属性定义要排除的自动配置类</p>
</blockquote>
]]></content>
      <categories>
        <category>SpringBoot翻译</category>
        <category>2.2.2.RELEASE</category>
      </categories>
      <tags>
        <tag>SpringBoot翻译</tag>
        <tag>2.2.2.RELEASE</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7下安装MySQL8</title>
    <url>/2018/06/30/CentOS7%E4%B8%8B%E5%AE%89%E8%A3%85MySQL8/</url>
    <content><![CDATA[<p>本文主要介绍MySQL的yum仓库的使用方法，其中包含了MySQL的安装步骤</p>
<p>原文<a href="https://dev.mysql.com/doc/mysql-yum-repo-quick-guide/en/#repo-qg-yum-upgrading">MySQL Yum仓库使用快速指南</a></p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>MySQL Yum仓库提供了在Linux平台上安装MySQL服务器、客户端和其他组件的RPM包。这些包还可以升级和替换安装在Linux发行版上的可以从MySQL中获得的任何第三方MySQL软件包。</p>
<p>MySQL Yum仓库支持下列Linux发行版：</p>
<ul>
<li>EL6和基于el7的平台（例如，Oracle Linux、Red Hat Enterprise Linux和CentOS的对应版本）</li>
<li>Fedora 27 和 28</li>
</ul>
<p>注意：并不是所有版本的MySQL都支持上述所有的Linux版本。如果想确认您的Linux发行版是否支持某个特定版本，请参阅<a href="https://dev.mysql.com/doc/refman/8.0/en/linux-installation-yum-repo.html#yum-repo-select-series">Selecting a Release Series</a></p>
<p>这是一个使用MySQL Yum仓库的快速指南。要了解更多信息，请参阅<a href="https://dev.mysql.com/doc/mysql-yum-repo-quick-guide/en/#repo-qg-yum-more-info">补充</a>。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>MySQL的安装步骤</li>
<li>安装额外的MySQL产品和组件</li>
<li>使用MySQL Yum仓库升级MySQL</li>
<li>替换MySQL的本地第三方发行版</li>
<li>使用Yum仓库安装MySQL NDB集群</li>
<li>安装额外的MySQL NDB集群产品和组件</li>
<li>补充</li>
</ul>
<h3 id="MySQL的安装步骤"><a href="#MySQL的安装步骤" class="headerlink" title="MySQL的安装步骤"></a>MySQL的安装步骤</h3><p>注意：下面的介绍是在假设使用第三方分布式RPM包的MySQL还没有安装在您的系统的基础上；如果已经使用RPM包安装了MySQL，请参照【替换MySQL的本地第三方发行版】。</p>
<h4 id="添加MySQL-Yum仓库"><a href="#添加MySQL-Yum仓库" class="headerlink" title="添加MySQL Yum仓库"></a>添加MySQL Yum仓库</h4><p>首先，将MySQL Yum仓库添加到系统的仓库列表中。</p>
<p>按照以下步骤进行:</p>
<p>1.先跳转到MySQL Yum仓库的下载页面<a href="http://dev.mysql.com/downloads/repo/yum/">http://dev.mysql.com/downloads/repo/yum/</a></p>
<p>2.为您的平台选择并下载发布包</p>
<p><img src="/mysql1.png" alt="RPM安装包"></p>
<p>这里我们选择<strong>mysql80-community-release-el7-1.noarch.rpm</strong></p>
<p>3.使用下面的命令安装下载的版本包，用下载的包的名称替换<em><strong>platform-and-version-specific-package-name</strong></em>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">shell&gt; </span><span class="language-bash">sudo rpm -Uvh platform-and-version-specific-package-name.rpm</span></span><br></pre></td></tr></table></figure>
<p>例如，对于基于el7的系统包的版本n，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">shell&gt; </span><span class="language-bash">sudo rpm -Uvh mysql80-community-release-el7-1.noarch.rpm</span></span><br></pre></td></tr></table></figure>

<p>注意：一旦发布包安装在您的系统上，如果Yum在MySQL Yum仓库中找到MySQL升级包或第三方软件包的替代品，那么通过<strong>yum update</strong>命令（支持dnf的系统是<strong>dnf upgrade</strong>）执行的任何系统更新都会自动升级系统上的MySQL包，同时也会替换任何本地的第三方软件包。具体可参考<strong>通过MySQL Yum仓库升级MySQL</strong>和<strong>替换MySQL的本地第三方分发版</strong>以获取详细信息。</p>
<h4 id="选择一个发行版本"><a href="#选择一个发行版本" class="headerlink" title="选择一个发行版本"></a>选择一个发行版本</h4><p>在使用MySQL Yum仓库时，默认情况下会选择最新的MySQL GA版本。如果这是您想要的，您可以跳到下一个步骤，用Yum安装MySQL。</p>
<p>在MySQL Yum仓库<a href="http://repo.mysql.com/yum/">http://repo.mysql.com/yum/</a>中，MySQL社区服务器的不同版本系列托管在不同的子库中。最新的GA系列（目前是MySQL 8.0）的子库默认启用，而所有其他系列（例如，MySQL 5.7系列）的子库在默认情况下都是禁用的。</p>
<p>使用这个命令查看MySQL Yum仓库中的所有子库，并查看哪些子库是启用或禁用的（对于支持dnf的系统，用dnf替换yum）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">shell&gt; </span><span class="language-bash">yum repolist all | grep mysql</span></span><br></pre></td></tr></table></figure>

<p>要安装最新GA系列的最新版本，不需要配置。要安装最新GA系列以外的特定系列的最新版本，请在运行安装命令之前禁用最新GA系列的子库，并启用特定系列的子库。如果您的平台支持<strong>yum-config-manager</strong>或<strong>dnf config-manager</strong>命令，您可以通过以下命令来实现这一点，例如，执行以下命令禁用8.0系列的子库，并启用5.7系列的子库</p>
<p>对于不支持dnf的平台:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">shell&gt; </span><span class="language-bash">sudo yum-config-manager --<span class="built_in">disable</span> mysql80-community</span></span><br><span class="line"><span class="meta prompt_">shell&gt; </span><span class="language-bash">sudo yum-config-manager --<span class="built_in">enable</span> mysql57-community</span></span><br></pre></td></tr></table></figure>

<p>对于支持dnf的平台</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">shell&gt; </span><span class="language-bash">sudo dnf config-manager --<span class="built_in">disable</span> mysql80-community</span></span><br><span class="line"><span class="meta prompt_">shell&gt; </span><span class="language-bash">sudo dnf config-manager --<span class="built_in">enable</span> mysql57-community</span></span><br></pre></td></tr></table></figure>

<p>除了使用<strong>yum-config-manager</strong>或<strong>dnf config-manager</strong>命令之外，您还可以通过手工编辑***&#x2F;etc&#x2F;yum.repos.d&#x2F;mysql-community.repo***协议文件来选择一个系列。下面是一个发布系列的子库中的典型条目：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line">[<span class="string">mysql80-community</span>]</span><br><span class="line"><span class="string">name=MySQL</span> <span class="number">8.0</span> <span class="string">Community</span> <span class="string">Server</span></span><br><span class="line"><span class="string">baseurl=http://repo.mysql.com/yum/mysql-8.0-community/el/7/$basearch/</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=1</span></span><br><span class="line"><span class="string">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql</span></span><br></pre></td></tr></table></figure>

<p>找到您想要配置的子库的条目，并编辑<strong>enabled</strong>的选项。指定<strong>enabled&#x3D;0</strong>来禁用子库，或者<strong>enabled&#x3D;1</strong>来启用子库。例如，要安装MySQL 5.7，请确保在MySQL 8.0的子库条目中enabled&#x3D;0，并为5.7系列的条目设置enabled&#x3D;1：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Enable to use MySQL 5.7</span></span><br><span class="line">[<span class="string">mysql57-community</span>]</span><br><span class="line"><span class="string">name=MySQL</span> <span class="number">5.7</span> <span class="string">Community</span> <span class="string">Server</span></span><br><span class="line"><span class="string">baseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/6/$basearch/</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=1</span></span><br><span class="line"><span class="string">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql</span></span><br></pre></td></tr></table></figure>

<p>您应该在任何时候只启用子库。当启用多个发布系列的子库时，Yum将使用最新的系列</p>
<p>通过运行以下命令并检查其输出（对于支持dnf的系统，用dnf替换yum），验证相应的子库是否已启用和禁用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">shell&gt; </span><span class="language-bash">yum repolist enabled | grep mysql</span></span><br></pre></td></tr></table></figure>

<h4 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h4><p>通过以下命令安装MySQL（用于支持dnf的系统，用dnf替换yum）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">shell&gt; </span><span class="language-bash">sudo yum install mysql-community-server</span></span><br></pre></td></tr></table></figure>

<p>这将为MySQL服务器安装软件包，以及其他必需的软件包。</p>
<h4 id="启动MySQL服务器"><a href="#启动MySQL服务器" class="headerlink" title="启动MySQL服务器"></a>启动MySQL服务器</h4><p>使用下面的命令启动MySQL服务器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">shell&gt; </span><span class="language-bash">sudo service mysqld start</span></span><br></pre></td></tr></table></figure>

<p>对于基于el7的平台，执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">shell&gt; </span><span class="language-bash">sudo systemctl start mysqld.service</span></span><br></pre></td></tr></table></figure>

<p>您可以使用以下命令检查MySQL服务器的状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">shell&gt; </span><span class="language-bash">sudo service mysqld status</span></span><br></pre></td></tr></table></figure>

<p>对于基于el7的平台，使用systemctl：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">shell&gt; </span><span class="language-bash">sudo systemctl status mysqld.service</span></span><br></pre></td></tr></table></figure>

<p>MySQL服务器初始化（和MySQL 5.7一样）：在服务器的初始启动时，由于服务器的数据目录是空的，所以会发现以下过程：</p>
<ul>
<li>服务器初始化</li>
<li>在data目录中生成SSL证书和密钥文件</li>
<li>validate_password插件被安装并启用</li>
<li>创建一个超级用户帐户的<strong>root‘@’localhost</strong>，超级用户的密码被设置并存储在错误日志文件中。要获取初始密码，请使用以下命令：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">shell&gt; </span><span class="language-bash">sudo grep <span class="string">&#x27;temporary password&#x27;</span> /var/log/mysqld.log</span></span><br></pre></td></tr></table></figure>

<p>尽快更改初始密码，通过初始密码登录，并为超级用户帐户设置一个自定义密码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">shell&gt; </span><span class="language-bash">mysql -uroot -p</span></span><br></pre></td></tr></table></figure>

<p>修改密码</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;MyNewPassword&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>注意：MySQL的validate_password插件是默认安装的。这将要求密码至少包含一个大写字母、一个小写字母、一个数字和一个特殊字符，并且总密码长度至少为8个字符。</p>
<p>至此， MySQL8.0安装完毕！</p>
<h4 id="确保MySQL安装（仅针对MySQL-5-6）"><a href="#确保MySQL安装（仅针对MySQL-5-6）" class="headerlink" title="确保MySQL安装（仅针对MySQL 5.6）"></a>确保MySQL安装（仅针对MySQL 5.6）</h4><p>指令<strong>mysql_secure_installation</strong>允许您执行一些重要的操作，如设置根密码、删除匿名用户等等。通过运行它来确保MySQL 5.6已安装成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">shell&gt; </span><span class="language-bash">mysql_secure_installation</span></span><br></pre></td></tr></table></figure>

<p>记住您设置的根密码是很重要的。详细信息请参阅<a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-secure-installation.html">mysql_secure_installation — Improve MySQL Installation Security</a></p>
<p>在安装MySQL 5.7或更高版本后，不要运行mysql_secure_installation，因为该指令的程序已经由Yum仓库安装完成。</p>
<p>注意：对于基于el7的平台，请查看<a href="https://dev.mysql.com/doc/refman/8.0/en/linux-installation-yum-repo.html#yum-install-compatibility-el7">Compatibility Information for EL7-based platforms</a></p>
<h3 id="安装额外的MySQL产品和组件"><a href="#安装额外的MySQL产品和组件" class="headerlink" title="安装额外的MySQL产品和组件"></a>安装额外的MySQL产品和组件</h3><p>您可以使用Yum来安装和管理MySQL的各个组件。其中一些组件已存在MySQL Yum仓库的子库中。使用下面的命令列出MySQL Yum仓库的所有子库中可用的所有MySQL组件的包（对于支持dnf的系统，用dnf替换yum）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">shell&gt; </span><span class="language-bash">yum --disablerepo=\* --enablerepo=<span class="string">&#x27;mysql*-community*&#x27;</span> list available</span></span><br></pre></td></tr></table></figure>

<p>使用以下命令安装您所选择的任何包，用包名替换***package-name ***（对于支持dnf的系统，用dnf替换指令中的yum）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell&gt; sudo yum install package-name</span><br></pre></td></tr></table></figure>

<p>例如，在Fedora上安装MySQL Workbench：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell&gt; sudo dnf install mysql-workbench-community</span><br></pre></td></tr></table></figure>

<h3 id="用MySQL-Yum仓库升级MySQL"><a href="#用MySQL-Yum仓库升级MySQL" class="headerlink" title="用MySQL Yum仓库升级MySQL"></a>用MySQL Yum仓库升级MySQL</h3><p>注意：在对MySQL进行任何更新之前，请仔细检查<a href="https://dev.mysql.com/doc/refman/8.0/en/upgrading.html">Upgrading MySQL</a>的说明。在这里说明中，更新之前备份数据库的内容尤其重要。</p>
<p>使用MySQL Yum仓库进行就地更新(即取代旧版本,然后运行旧的数据文件的新版本)为你的MySQL安装通过以下步骤(假设你已经安装了MySQL与MySQL Yum资源库或RPM包直接从MySQL开发人员下载区域的MySQL下载页面;如果不是这样，请按照以下指示替换MySQL的本地第三方发行版):</p>
<p>选择一个目标系列</p>
<p>默认情况下，MySQL Yum库将MySQL更新为您在安装期间选择的发布系列中的最新版本(参见选择发布系列了解详细信息)，这意味着，例如5.7版本。x安装不会更新为8.0。x自动释放。要更新到另一个发布系列，您需要首先禁用所选系列的子存储库(默认情况下，或者您自己)，并启用目标系列的子存储库。要做到这一点，请参阅在选择发布系列以编辑&#x2F;etc&#x2F;yum.repo .d&#x2F;mysql-community中的子存储库条目时给出的一般说明。回购协议文件。要从MySQL 5.7升级到8.0，请执行与选择发布系列所示步骤相反的操作，禁用MySQL 5.7系列的子存储库，并启用MySQL 8.0系列的子存储库。</p>
<p>一般来说，要从一个发布系列升级到另一个发布系列，请转到下一个系列，而不是跳过一个系列。例如，如果您正在运行MySQL 5.6并希望升级到8.0，请先升级到MySQL 5.7，然后再升级到8.0。</p>
<p>重要</p>
<p>关于从MySQL 5.6升级到5.7的重要信息，请参见从MySQL 5.6升级到5.7。</p>
<p>有关从MySQL 5.7升级到8.0的重要信息，请参见从MySQL 5.7升级到8.0。</p>
<p>MySQL Yum库不支持就地降级MySQL。按照降级MySQL的说明。</p>
<p>升级MySQL</p>
<p>对于不支持dnf的平台，通过以下命令升级MySQL及其组件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell&gt; sudo yum update mysql-server</span><br></pre></td></tr></table></figure>


<p>对于支持dnf的平台</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell&gt; sudo dnf --refresh upgrade mysql-server</span><br></pre></td></tr></table></figure>

<p>或者，您可以通过告诉Yum更新系统上的所有内容来更新MySQL，这可能会花费更多的时间;对于不支持dnf的平台:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell&gt; sudo yum update</span><br></pre></td></tr></table></figure>


<p>对于支持dnf的平台</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell&gt; sudo dnf upgrade</span><br></pre></td></tr></table></figure>

<h3 id="重启MySQL"><a href="#重启MySQL" class="headerlink" title="重启MySQL"></a>重启MySQL</h3><p>MySQL服务器总是在Yum更新后重新启动。一旦服务器重新启动，运行mysql_upgrade来检查并解决旧数据和升级软件之间的任何不兼容问题。mysql_upgrade还可以执行其他功能;请参阅mysql_upgrade -检查和升级MySQL表以了解详细信息。</p>
<p>您还可以只更新特定的组件。使用以下命令列出MySQL组件的所有已安装包(对于支持dnf的系统，将yum替换为dnf):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell&gt; sudo yum list installed | grep &quot;^mysql&quot;</span><br></pre></td></tr></table></figure>

<p>在识别您选择的组件的包名之后，对于不支持dnf的平台，使用以下命令更新包，用包名替换包名:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell&gt; sudo yum update package-name</span><br></pre></td></tr></table></figure>

<p>对于支持dnf的平台</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell&gt; sudo dnf upgrade package-name</span><br></pre></td></tr></table></figure>


<p>替换MySQL的本地第三方发行版</p>
<p>要用MySQL Yum库最新的GA版本(目前来自MySQL 8.0系列)替换从受支持的Linux平台的本地软件仓库安装的第三方MySQL发行版，请执行以下步骤:</p>
<p>备份数据库<br>为了避免数据丢失，请在尝试使用MySQL Yum库替换MySQL安装之前备份数据库。有关如何备份数据库，请参阅备份和恢复。</p>
<p>添加MySQL Yum存储库</p>
<p>通过添加MySQL Yum存储库中给出的说明，将MySQL Yum存储库添加到您的系统的存储库列表中。</p>
<p>用Yum更新或DNF升级替换本机第三方发行版</p>
<p>通过设计,MySQL Yum资源库将取代你的本地,第三方MySQL在最新的GA版本(从目前的MySQL 8.0系列)从MySQL百胜库执行Yum更新命令时(或dnf升级dnf-enabled系统)系统,或Yum更新MySQL服务器(或MySQL服务器升级dnf dnf-enabled系统)。</p>
<p>在使用Yum存储库更新MySQL之后，使用旧版本的共享客户机库编译的应用程序应该继续工作。但是，如果您想重新编译应用程序并动态地将它们与更新后的库链接起来，请参阅升级共享客户机库以获得一些特殊的考虑。</p>
<p>备注</p>
<p>对于基于el7的平台：查看基于el7的平台的兼容性信息。</p>
<p>如果您已经从一个非本地存储库下载并安装了MySQL的第三方分发版（例如，来自MariaDB或Percona），那么在MySQL服务器的参考手册中，遵循替换它们的说明是很重要的。</p>
<p>使用Yum存储库安装MySQL NDB集群、</p>
<p>备注</p>
<p>下面的说明假设MySQL服务器和MySQL NDB集群都已经安装在您的系统上;如果不是这样，那么在继续之前，删除MySQL服务器或MySQL NDB集群，包括所有可执行文件、库、配置文件和数据目录。但是，没有必要删除您可能用于在系统上启用MySQL Yum存储库的放行包。</p>
<p>NDB集群SQL节点包对Perl类：：MethodMaker模块有依赖关系。如果在您的系统上启用了EPEL（Enterprise Linux的额外包），Yum可以处理这种依赖关系;请参阅这里的说明，了解如何启用EPEL存储库。</p>
<p>MySQL Yum存储库支持MySQL NDB集群的安装，仅用于发布7.5.6和后续版本，并且只支持EL6和EL7平台。对于其他安装NDB集群的方法，请参阅Linux上的NDB集群的安装，或者在Linux上安装NDB集群，这取决于您正在使用的发布系列。</p>
<p>为MySQL NDB集群添加MySQL Yum存储库</p>
<p>按照添加MySQL Yum存储库的步骤，将MySQL Yum存储库添加到系统的存储库列表中。如果您之前已经完成了这个步骤，那么请确保您拥有最新版本的发布包，运行以下命令，以支持那些没有启用dnf的平台：</p>
<p>shell&gt; sudo yum update mysql57-community-release</p>
<p>对于支持dnf的平台</p>
<p>shell&gt; sudo dnf –refresh upgrade mysql57-community-release</p>
<p>选择MySQL NDB集群子存储库</p>
<p>在MySQL Yum库(<a href="http://repo.sqmyl.com/yum/)%E4%B8%AD%EF%BC%8CMySQL%E7%A4%BE%E5%8C%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8CMySQL">http://repo.sqmyl.com/yum/)中，MySQL社区服务器和MySQL</a> NDB集群托管在不同的子存储库中。默认情况下，将启用MySQL服务器最新GA系列的子存储库，并禁用MySQL NDB集群的子存储库。要安装NDB集群，请禁用MySQL服务器的子存储库，并启用NDB集群的子存储库。如果您的平台支持yum-config-manager或dnf config-manager命令，您可以通过发出以下命令来做到这一点，该命令禁用了MySQL 5.7系列的子存储库，并为MySQL NDB集群7.5启用了这个命令;对于不支持dnf的平台:</p>
<p>shell&gt; sudo yum-config-manager –disable mysql57-community<br>shell&gt; sudo yum-config-manager –enable mysql-cluster-7.5-community</p>
<p>对于支持dnf的平台</p>
<p>shell&gt; sudo dnf config-manager –disable mysql57-community<br>shell&gt; sudo dnf config-manager –enable mysql-cluster-7.5-community</p>
<p>除了使用yconfig管理器或dnf configmanager命令之外，您还可以通过手工编辑&#x2F;etc&#x2F;yum.repos.d&#x2F;mysql-community来选择子存储库。回购协议文件。这是文件中MySQL 5.7个子存储库的示例条目：</p>
<p>[mysql57-community]<br>name&#x3D;MySQL 5.7 Community Server<br>baseurl&#x3D;<a href="http://repo.mysql.com/yum/mysql-5.7-community/el/6/$basearch/">http://repo.mysql.com/yum/mysql-5.7-community/el/6/$basearch/</a><br>enabled&#x3D;1<br>gpgcheck&#x3D;1<br>gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-mysql</p>
<p>要安装NDB集群7.5，您必须禁用MySQL 5.7的子存储库，方法是为上面的子库条目启用启用&#x3D;0，并启用NDB集群7.5个子存储库，使其条目&#x3D;1：</p>
<p>[mysql-cluster-7.5-community]<br>name&#x3D;MySQL Cluster 7.5 Community<br>baseurl&#x3D;<a href="http://repo.mysql.com/yum/mysql-cluster-7.5-community/el/6/$basearch/">http://repo.mysql.com/yum/mysql-cluster-7.5-community/el/6/$basearch/</a><br>enabled&#x3D;1<br>gpgcheck&#x3D;1<br>gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-mysql</p>
<p>在保存文件的更改之后，通过运行以下命令来验证是否启用了正确的子存储库（支持dnf的系统，用dnf替换yum）：</p>
<p>shell&gt; yum repolist enabled | grep mysql<br>!mysql-cluster-7.5-community&#x2F;x86_64 MySQL Cluster 7.5 Community               18<br>!mysql-connectors-community&#x2F;x86_64  MySQL Connectors Community                31<br>!mysql-tools-community&#x2F;x86_64       MySQL Tools Community                     33</p>
<p>NDB集群7.5（Community edition）的子存储库现已启用。<br>在列表中还有一些MySQL Yum存储库的其他子存储库，它们在默认情况下是启用的。</p>
<p>安装MySQL NDB集群</p>
<p>对于MySQL NDB集群的最小安装，请遵循以下步骤（用于支持dnf的系统，用dnf替换yum中的yum）：</p>
<p>为SQL节点安装组件：</p>
<p>shell&gt; sudo yum install mysql-cluster-community-server</p>
<p>安装完成后，按照启动MySQL服务器的步骤启动和初始化SQL节点。 </p>
<p>如果您选择使用mysqld——初始化命令（请参阅使用mysqld手动初始化数据目录）来手动初始化数据目录，则会生成根密码并将其存储在SQL节点的错误日志中;有关如何查找密码的MySQL服务器初始化，以及您需要了解的一些事情。</p>
<p>为管理节点安装可执行文件：</p>
<p>shell&gt; sudo yum install mysql-cluster-community-management-server</p>
<p>为数据节点安装可执行文件：</p>
<p>shell&gt; sudo yum install mysql-cluster-community-data-node</p>
<p>配置和启动MySQL NDB集群</p>
<p>关于如何配置MySQL NDB集群和NDB集群的初始启动，请参阅NDB集群的初始配置，了解如何第一次启动它。</p>
<p>备注</p>
<p>对于基于el7的平台：查看基于el7的平台的兼容性信息。</p>
<p>安装额外的MySQL NDB集群产品和组件</p>
<p>您可以使用Yum从MySQL Yum存储库中安装MySQL NDB集群的单个组件和附加产品。<br>要做到这一点，假设您已经在系统的存储库列表中已经有了MySQL Yum存储库（如果没有的话，请遵循使用Yum存储库安装MySQL NDB集群的步骤1和步骤2），遵循在安装额外的MySQL产品和组件时所提供的相同步骤。</p>
<p>备注</p>
<p>已知的问题：目前，当您安装测试套件包（mysql-集群-社区测试）时，并不是运行MySQL NDB集群测试套件所需的所有组件。在运行测试套件之前，先安装yum安装（或dnf安装的dnf系统）的下列软件包：</p>
<ul>
<li><p>mysql-cluster-community-auto-installer</p>
</li>
<li><p>mysql-cluster-community-management-server</p>
</li>
<li><p>mysql-cluster-community-data-node</p>
</li>
<li><p>mysql-cluster-community-memcached</p>
</li>
<li><p>mysql-cluster-community-java</p>
</li>
<li><p>mysql-cluster-community-ndbclient-devel</p>
</li>
</ul>
<p>补充</p>
<p>关于MySQL Yum存储库的更多信息可以在MySQL服务器参考手册的以下部分中找到：<br>Installing MySQL on Linux Using the MySQL Yum Repository</p>
<p>Replacing a Third-Party Distribution of MySQL Using the MySQL Yum Repository</p>
<p>Upgrading MySQL with the MySQL Yum Repository</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7配置静态IP</title>
    <url>/2020/01/18/CentOS7%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/</url>
    <content><![CDATA[<h3 id="网卡配置文件"><a href="#网卡配置文件" class="headerlink" title="网卡配置文件"></a>网卡配置文件</h3><p>进入到 <code>/etc/sysconfig/network-scripts</code> 目录，找到网卡配置文件 <strong>ifcfg-</strong>*</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">cd</span> /etc/sysconfig/network<span class="literal">-scripts</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/iSaoHKH.png"></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在 <code>ifcfg-ens192</code> 文件中修改或添加以下信息</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">BOOTPROTO</span>=<span class="string">&quot;static&quot; #dhcp改为static </span></span><br><span class="line"><span class="attr">ONBOOT</span>=<span class="string">&quot;yes&quot; #开机启用本配置</span></span><br><span class="line"><span class="attr">IPADDR</span>=<span class="string">10.192.89.130 #静态IP</span></span><br><span class="line"><span class="attr">GATEWAY</span>=<span class="string">10.192.89.254 #默认网关</span></span><br><span class="line"><span class="attr">NETMASK</span>=<span class="string">255.255.255.0 #子网掩码</span></span><br><span class="line"><span class="attr">DNS1</span>=<span class="string">10.1.7.7 #DNS 配置</span></span><br></pre></td></tr></table></figure>

<h3 id="重启网卡服务"><a href="#重启网卡服务" class="headerlink" title="重启网卡服务"></a>重启网卡服务</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; service network restart</span><br></pre></td></tr></table></figure>

<h3 id="查看配置结果"><a href="#查看配置结果" class="headerlink" title="查看配置结果"></a>查看配置结果</h3><p><img src="https://i.imgur.com/3UuDm1b.png"></p>
]]></content>
      <categories>
        <category>CentOS7</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7安装：Operating System Not Found</title>
    <url>/2020/01/18/CentOS7%E5%AE%89%E8%A3%85%EF%BC%9AOperating%20System%20Not%20Found/</url>
    <content><![CDATA[<p>虚拟机下安装CentOS7时报错：Operating System Not Found，具体信息如下截图</p>
<p><img src="https://i.imgur.com/C8jDi3W.png"></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>关闭虚拟机电源，在选择镜像的地方勾选 <code>Connect At Power On</code> 选项，并选择 CentOS7 的镜像，重启电源即可。</p>
<p><img src="https://i.imgur.com/TpGKo0n.png"></p>
]]></content>
      <categories>
        <category>CentOS7</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS下OpenSSH版本升级</title>
    <url>/2018/12/16/CentOS%E4%B8%8BOpenSSH%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<p>最近一段时间 OpenSSH 爆发了远程访问漏洞，需要升级现有服务器的OpenSSH版本，目前官网的最新版本为7.7</p>
<h3 id="查看现有版本"><a href="#查看现有版本" class="headerlink" title="查看现有版本"></a>查看现有版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ssh -V</span></span><br><span class="line">OpenSSH_5.3p1, OpenSSL 1.0.1e-fips 11 Feb 2013</span><br></pre></td></tr></table></figure>
<h3 id="安装Telnet服务"><a href="#安装Telnet服务" class="headerlink" title="安装Telnet服务"></a>安装Telnet服务</h3><p>安装 telnet 是为了防止卸载 OpenSSH 之后无法远程连接服务器</p>
<h4 id="安装服务"><a href="#安装服务" class="headerlink" title="安装服务"></a>安装服务</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum -y install telnet-server* telnet</span></span><br></pre></td></tr></table></figure>

<h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vim /etc/xinetd.d/telnet</span></span><br></pre></td></tr></table></figure>

<p>将其中 disable 字段的 yes 改为 no，允许 root 用户通过 telnet 登录（升级之后再修改回来）</p>
<h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">service xinetd start</span></span><br><span class="line">Starting xinetd:                                           [  OK  ]</span><br></pre></td></tr></table></figure>

<h4 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chkconfig xinetd on</span></span><br></pre></td></tr></table></figure>

<h3 id="卸载原有OpenSSH"><a href="#卸载原有OpenSSH" class="headerlink" title="卸载原有OpenSSH"></a>卸载原有OpenSSH</h3><h4 id="备份原有文件"><a href="#备份原有文件" class="headerlink" title="备份原有文件"></a>备份原有文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mv</span> /etc/securetty /etc/securetty.old</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mv</span> /etc/init.d/sshd  /etc/init.d/sshd.old</span></span><br></pre></td></tr></table></figure>

<h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rpm -qa | grep openssh</span></span><br><span class="line">openssh-clients-5.3p1-123.el6_9.x86_64</span><br><span class="line">openssh-5.3p1-123.el6_9.x86_64</span><br><span class="line">openssh-server-5.3p1-123.el6_9.x86_64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rpm -e --nodeps openssh-5.3p1-123.el6_9.x86_64</span> </span><br><span class="line">warning:    erase unlink of /etc/ssh/moduli failed: No such file or directory</span><br><span class="line">warning:    erase unlink of /etc/ssh failed: No such file or directory</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rpm -e --nodeps openssh-server-5.3p1-123.el6_9.x86_64</span></span><br><span class="line">error reading information on service sshd: No such file or directory</span><br><span class="line">error: %preun(openssh-server-5.3p1-123.el6_9.x86_64) scriptlet failed, exit status 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rpm -e --noscripts  openssh-server-5.3p1-123.el6_9.x86_64</span></span><br><span class="line">warning:    erase unlink of /etc/ssh/sshd_config failed: No such file or directory</span><br><span class="line">warning:    erase unlink of /etc/rc.d/init.d/sshd failed: No such file or directory</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rpm -e --nodeps openssh-clients-5.3p1-123.el6_9.x86_64</span></span><br><span class="line">warning:    erase unlink of /etc/ssh/ssh_config failed: No such file or directory</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rpm -qa | grep openssh</span></span><br></pre></td></tr></table></figure>

<h3 id="安装新版本OpenSSH"><a href="#安装新版本OpenSSH" class="headerlink" title="安装新版本OpenSSH"></a>安装新版本OpenSSH</h3><h4 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum install -y gcc openssl-devel pam-devel rpm-build</span></span><br></pre></td></tr></table></figure>

<h4 id="下载源文件"><a href="#下载源文件" class="headerlink" title="下载源文件"></a>下载源文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wget http://ftp.openbsd.org/pub/OpenBSD/OpenSSH/portable/openssh-7.3p1.tar.gz</span></span><br></pre></td></tr></table></figure>

<h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tar -zxvf openssh-7.3p1.tar.gz</span> </span><br></pre></td></tr></table></figure>

<h4 id="进入主目录"><a href="#进入主目录" class="headerlink" title="进入主目录"></a>进入主目录</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> openssh-7.3p1</span></span><br></pre></td></tr></table></figure>

<h4 id="配置相关参数"><a href="#配置相关参数" class="headerlink" title="配置相关参数"></a>配置相关参数</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./configure --prefix=/usr --sysconfdir=/etc/ssh --with-md5-passwords --with-pam --with-zlib --with-openssl-includes=/usr --with-privsep-path=/var/lib/sshd</span> </span><br></pre></td></tr></table></figure>

<h4 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">make</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">make install</span></span><br></pre></td></tr></table></figure>

<h4 id="修改配置-1"><a href="#修改配置-1" class="headerlink" title="修改配置"></a>修改配置</h4><p>默认情况下，root 用户禁止远程登录，需要修改 &#x2F;etc&#x2F;ssh&#x2F;sshd_config 文件，将 PermitRootLogin 参数改为 yes，如果没有该配置，则在文件末尾追加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vim /etc/ssh/sshd_config</span></span><br></pre></td></tr></table></figure>

<h4 id="添加服务并启动"><a href="#添加服务并启动" class="headerlink" title="添加服务并启动"></a>添加服务并启动</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cp</span> -p contrib/redhat/sshd.init /etc/init.d/sshd</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">chmod</span> +x /etc/init.d/sshd</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chkconfig  --add  sshd</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chkconfig sshd on</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chkconfig --list sshd</span></span><br><span class="line">sshd           	0:off	1:off	2:on	3:on	4:on	5:on	6:off</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">service sshd restart</span></span><br></pre></td></tr></table></figure>

<h3 id="检查版本"><a href="#检查版本" class="headerlink" title="检查版本"></a>检查版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ssh -V</span></span><br><span class="line">OpenSSH_7.3p1, OpenSSL 1.0.1e-fips 11 Feb 2013</span><br></pre></td></tr></table></figure>

<p>至此，OepnSSH 升级完毕！</p>
<p>别忘了关闭 telnet 的 root 远程访问权限</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>OpenSSH</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS6下PostgreSQL安装</title>
    <url>/2018/06/29/CentOS%E4%B8%8BPostgreSQL%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>基于CentOS6的PostgreSQL yum安装</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum install https://download.postgresql.org/pub/repos/yum/9.6/redhat/rhel-6-x86_64/pgdg-centos96-9.6-3.noarch.rpm</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum install postgresql96</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum install postgresql96-server</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum install postgresql96-contrib</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">service postgresql-9.6 initdb</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chkconfig postgresql-9.6 on</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">service postgresql-9.6 start</span></span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>安装后默认只能本地访问，需要修改配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> /var/lib/pgsql/9.6/data/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ll</span></span><br></pre></td></tr></table></figure>

<h4 id="修改监听地址"><a href="#修改监听地址" class="headerlink" title="修改监听地址"></a>修改监听地址</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vim postgresql.conf</span> </span><br></pre></td></tr></table></figure>
<p>修改listen_address</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">listen_address</span>=<span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="修改登入权限"><a href="#修改登入权限" class="headerlink" title="修改登入权限"></a>修改登入权限</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vim pg_hba.conf</span> </span><br></pre></td></tr></table></figure>
<p>修改IPv4的配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">host</span>    <span class="string">all</span>             <span class="string">all</span>             <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span>            <span class="string">md5</span></span><br></pre></td></tr></table></figure>

<h3 id="重启生效"><a href="#重启生效" class="headerlink" title="重启生效"></a>重启生效</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">service postgresql-9.6 restart</span></span><br></pre></td></tr></table></figure>

<p>备注： root 用户无法直接访问数据库，需要切换成 postgres 用户，进入 bash 界面，再输入 psql 进入数据库的控制台</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">su postgres</span></span><br><span class="line">bash-4.1$ psql</span><br><span class="line">psql (9.6.9)</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">postgres=# </span><br></pre></td></tr></table></figure>

<p>至此，PostgreSQL的安装和配置完毕！</p>
]]></content>
      <categories>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>FunctionalInterface注解</title>
    <url>/2022/03/18/FunctionalInterface%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p><code>FunctionalInterface</code> 是一个信息性注解类型，用于指示接口类型符合 Java 语言规范定义的函数式接口要求。</p>
<p>从概念上讲，函数式接口只有一个抽象方法，其他方法都有默认的实现。</p>
<p>如果接口声明了一个覆盖 <code> java.lang.Object</code> 的公共方法之一的抽象方法，这也不会进入抽象方法计数，因为接口的任何实现都具有来自 <code>java.lang.Object</code> 或其他地方的实现。</p>
<p>请注意，函数式接口的实例可以使用 lambda 表达式、方法引用或构造函数引用来创建。</p>
<p>如果使用此注解类型对类型进行注解，则编译器需要生成错误消息，除非：</p>
<ul>
<li>该类型是接口类型，而不是注释类型、枚举或类。</li>
<li>带注释的类型满足函数式接口的要求。</li>
</ul>
<p>但是，无论接口声明中是否存在 <code>FunctionalInterface</code> 注解，编译器都会将满足函数式接口定义的任何接口视为函数式接口。</p>
<h3 id="注解定义"><a href="#注解定义" class="headerlink" title="注解定义"></a>注解定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment">//Target表明FunctionalInterface只能用来修饰接口、类和枚举</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FunctionalInterface &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数式接口只有一个抽象方法"><a href="#函数式接口只有一个抽象方法" class="headerlink" title="函数式接口只有一个抽象方法"></a>函数式接口只有一个抽象方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HelloInterface</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">(String str)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 HelloInterface 中定义两个抽象方法，编译器会给出提示：在HelloInterface中找到多个非重写的abtract方法。</p>
<h3 id="接口声明覆盖-java-lang-Object的抽象方法，不会进行抽象方法计数"><a href="#接口声明覆盖-java-lang-Object的抽象方法，不会进行抽象方法计数" class="headerlink" title="接口声明覆盖 java.lang.Object的抽象方法，不会进行抽象方法计数"></a>接口声明覆盖 java.lang.Object的抽象方法，不会进行抽象方法计数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HelloInterface</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">(String str)</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">toString</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HelloInterface 定义了 toString() 方法，编译器不会给出错误提示，编译可以通过。</p>
<h3 id="函数式接口的实例可以使用-lambda-表达式、方法引用或构造函数引用来创建"><a href="#函数式接口的实例可以使用-lambda-表达式、方法引用或构造函数引用来创建" class="headerlink" title="函数式接口的实例可以使用 lambda 表达式、方法引用或构造函数引用来创建"></a>函数式接口的实例可以使用 lambda 表达式、方法引用或构造函数引用来创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//lambda表达式方法 定义抽象方法test1的实现，生成接口实例</span></span><br><span class="line">        <span class="type">HelloInterface</span> <span class="variable">hello</span> <span class="operator">=</span> x -&gt; System.out.println(<span class="string">&quot;hello &quot;</span> + x);</span><br><span class="line">        <span class="comment">//进行接口调用</span></span><br><span class="line">        hello.test1(<span class="string">&quot;qinghuazs&quot;</span>);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//构造器方式来实现抽象方法，生成接口实例</span></span><br><span class="line">        <span class="type">HelloInterface</span> <span class="variable">hello2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloInterface</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">(String str)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hello construction &quot;</span> + str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        hello2.test1(<span class="string">&quot;qinghuazs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方法引用还没搞明白，等我搞明白了再来补充。</p>
</blockquote>
<h3 id="FunctionalInterface-用来修饰类或枚举会编译失败"><a href="#FunctionalInterface-用来修饰类或枚举会编译失败" class="headerlink" title="FunctionalInterface 用来修饰类或枚举会编译失败"></a>FunctionalInterface 用来修饰类或枚举会编译失败</h3><p>因为 FunctionalInterface 要求必须有一个抽象方法，所以普通的类肯定是不满足条件的，我们来看一下抽象类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractTest</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器提示 AbstractTest 不是函数式接口，编译失败。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义注解</title>
    <url>/2018/12/15/Java%E5%85%83%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>在 Spring 中，我们经常能够看到各种各样的注解，Java 自身也定义了很多的注解，这些注解的添加能够让程序员明确的知道这个类的状态。</p>
<p>Java中比较常见的注解类：</p>
<ul>
<li>@Override  重写父类的方法</li>
<li>@Deprecated 标记过时，不建议再使用</li>
<li>@SuppressWarnings 消除警告</li>
</ul>
<p>Java中的注解类，都使用 <code>@interface</code> 标记</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Override 注解类中，可以看到有两个注解 @Targe t和 @Retention 对 Override 进行了修饰，这些用来修饰注解类的注解称为元注解，元注解是注解的注解。</p>
<p>Java 中的元注解主要有以下几种</p>
<ul>
<li>Target</li>
<li>Retention</li>
<li>Documented</li>
<li>Inherited</li>
</ul>
<h4 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Target 有一个属性 value，类型是 ElementType 数组，ElementType 是一个枚举类型，<strong>主要用来标记被@Target修饰的注解类可应用在什么位置上</strong></p>
<p>枚举值为</p>
<ul>
<li>ANNOTATION_TYPE  可应用在注解类上</li>
<li>CONSTRUCTOR  构造器</li>
<li>FIELD  成员变量 </li>
<li>LOCAL_VARIABLE  局部变量</li>
<li>METHOD  方法</li>
<li>PACKAGE  包</li>
<li>PARAMETER  参数</li>
<li>TYPE  类、接口以及枚举</li>
</ul>
<p>JDK1.8 之后新增了两个枚举属性</p>
<ul>
<li>TYPE_PARAMETER  类型参数声明</li>
<li>TYPE_USE  使用的类型</li>
</ul>
<h4 id="Retention"><a href="#Retention" class="headerlink" title="Retention"></a>Retention</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">	RetentionPolicy <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Retention 注解有一个属性 value，是 RetentionPolicy 类型的，RetentionPolicy 是一个枚举类型，这个枚举决定了 Retention 注解的保留机制</p>
<p>RetentionPolicy 有3个值：</p>
<ul>
<li>CLASS 表示当程序编译时注解的信息被保留在 class 文件(字节码文件)中，但在运行的时候不会被虚拟机读取</li>
<li>RUNTIME 表示当程序编译时注解的信息被保留在 class 文件(字节码文件)中，运行时也会被虚拟机读取 </li>
<li>SOURCE 表示注解的信息会被编译器抛弃，不会留在 class 文件中，注解的信息只会留在源文件中</li>
</ul>
<h4 id="Documented"><a href="#Documented" class="headerlink" title="Documented"></a>Documented</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Documented &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Documented 元注解用于声明被该注解修饰的注解类是可以写入 JavaDoc 中的</p>
<h4 id="Inherited"><a href="#Inherited" class="headerlink" title="Inherited"></a>Inherited</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Inherited &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Inherited 用于指定某个注解用于父类时是否能够被子类继承</p>
<p>@Inherited 使用的较少，稍微理解即可</p>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>下面以日志注解为例介绍如何自定义注解。</p>
<p>首先需定义注解类 MyLog</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyLog &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Target(ElementType.METHOD)</code> 表明该注解只能在方法上使用</p>
<p><code>@Retention(RetentionPolicy.RUNTIME)</code> 表明该注解会在程序编译时放到 class 文件(字节码文件)中，运行时也会被虚拟机读取</p>
<p><code>@Documented</code> 声明被该注解修饰的注解类是可以写入 JavaDoc 中</p>
<p>@Target 和 @Retention 是必须的，@Documented 根据自己的需要进行添加</p>
<p>此时，只是定义了MyLog注解，但是并不是加了该注解就起作用的，还需要配置AOP，使之与注解配合，达到日志记录的作用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLogAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.example.demo.annotation.MyLog)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myLog</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知【在连接点前面执行，前置通知不会影响连接点的执行，除非此处抛出异常】</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;myLog()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;MyLog日志注解 - 前置通知【在连接点前面执行，前置通知不会影响连接点的执行，除非此处抛出异常】&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知【环绕通知围绕在连接点前后，比如一个方法调用的前后】</span></span><br><span class="line"><span class="comment">     * 环绕通知还需要负责决定是继续处理join point(调用ProceedingJoinPoint的proceed方法)还是中断执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;myLog()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;MyLog日志注解 - 环绕通知【环绕通知围绕在连接点前后，比如一个方法调用的前后】&quot;</span>);</span><br><span class="line">            <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line">            <span class="comment">//获取请求相关信息</span></span><br><span class="line">            log.debug(<span class="string">&quot;URL ------&gt; &quot;</span> + request.getRequestURL().toString());</span><br><span class="line">            log.debug(<span class="string">&quot;METHOD ----&gt; &quot;</span> + request.getMethod());</span><br><span class="line">            log.debug(<span class="string">&quot;ContentType -----&gt;&quot;</span> + request.getContentType());</span><br><span class="line">            log.debug(<span class="string">&quot;Parameters -----&gt;&quot;</span> + request.getParameterMap());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取切入点的相关信息</span></span><br><span class="line">            log.debug(<span class="string">&quot;className ------&gt; &quot;</span> + joinPoint.getTarget().getClass().getName());</span><br><span class="line">            log.debug(<span class="string">&quot;method ----&gt; &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">            log.debug(<span class="string">&quot;params -----&gt;&quot;</span> + Arrays.toString(joinPoint.getArgs()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//DO SOMETHING</span></span><br><span class="line">        <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正常返回通知【在连接点正常执行完成后执行，如果连接点抛出异常，则不会执行】</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;myLog()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;MyLog日志注解 - 正常返回通知【在连接点正常执行完成后执行，如果连接点抛出异常，则不会执行】&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常返回通知【在连接点抛出异常后执行】</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;myLog()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;MyLog日志注解 - 异常返回通知【在连接点抛出异常后执行】&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回通知【在连接点执行完成后执行，不管是正常执行完成，还是抛出异常，都会执行返回通知中的内容】</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After(&quot;myLog()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;MyLog日志注解 - 返回通知【在连接点执行完成后执行，不管是正常执行完成，还是抛出异常，都会执行返回通知中的内容】&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下，各个通知的执行顺序如下：</p>
<ul>
<li>环绕通知</li>
<li>前置通知</li>
<li>返回通知</li>
<li>正常返回通知</li>
</ul>
<p>在发生异常的情况下，执行顺序如下：</p>
<ul>
<li>环绕通知</li>
<li>前置通知</li>
<li>返回通知</li>
<li>异常返回通知</li>
</ul>
<p>一般我们只需要配置环绕通知和异常返回通知即可</p>
<p>然后我们添加Controller类进行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="meta">@MyLog</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">user</span><span class="params">(<span class="meta">@RequestParam</span> String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 HelloController 类中，我们只对 user() 方法添加了 MyLog 注解，使用Postman进行接口测试</p>
<p>调用 hello() 方法未打印出 MyLogAspect 中的日志信息， 而调用 user() 方法则打印出各个方法内的日志信息</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">151079</span> <span class="number">2018</span>-<span class="number">12</span>-<span class="number">15</span> <span class="number">15</span>:<span class="number">47</span>:<span class="number">17</span><span class="variable">.330</span> [http-nio-<span class="number">8080</span>-exec-<span class="number">1</span>] DEBUG o<span class="variable">.s</span><span class="variable">.b</span><span class="variable">.f</span><span class="variable">.s</span><span class="variable">.DefaultListableBeanFactory</span> - Returning cached <span class="keyword">instance</span> of singleton bean &#x27;myLogAspect&#x27; </span><br><span class="line"><span class="number">151079</span> <span class="number">2018</span>-<span class="number">12</span>-<span class="number">15</span> <span class="number">15</span>:<span class="number">47</span>:<span class="number">17</span><span class="variable">.330</span> [http-nio-<span class="number">8080</span>-exec-<span class="number">1</span>] DEBUG com<span class="variable">.example</span><span class="variable">.demo</span><span class="variable">.aspect</span><span class="variable">.MyLogAspect</span> - MyLog日志注解 - 环绕通知【环绕通知围绕在连接点前后，比如一个方法调用的前后】 </span><br><span class="line"><span class="number">151079</span> <span class="number">2018</span>-<span class="number">12</span>-<span class="number">15</span> <span class="number">15</span>:<span class="number">47</span>:<span class="number">17</span><span class="variable">.330</span> [http-nio-<span class="number">8080</span>-exec-<span class="number">1</span>] DEBUG com<span class="variable">.example</span><span class="variable">.demo</span><span class="variable">.aspect</span><span class="variable">.MyLogAspect</span> - URL ------&gt; http:<span class="comment">//127.0.0.1:8080/user </span></span><br><span class="line"><span class="number">151079</span> <span class="number">2018</span>-<span class="number">12</span>-<span class="number">15</span> <span class="number">15</span>:<span class="number">47</span>:<span class="number">17</span><span class="variable">.330</span> [http-nio-<span class="number">8080</span>-exec-<span class="number">1</span>] DEBUG com<span class="variable">.example</span><span class="variable">.demo</span><span class="variable">.aspect</span><span class="variable">.MyLogAspect</span> - METHOD ----&gt; GET </span><br><span class="line"><span class="number">151079</span> <span class="number">2018</span>-<span class="number">12</span>-<span class="number">15</span> <span class="number">15</span>:<span class="number">47</span>:<span class="number">17</span><span class="variable">.330</span> [http-nio-<span class="number">8080</span>-exec-<span class="number">1</span>] DEBUG com<span class="variable">.example</span><span class="variable">.demo</span><span class="variable">.aspect</span><span class="variable">.MyLogAspect</span> - ContentType -----&gt;<span class="literal">null</span> </span><br><span class="line"><span class="number">151080</span> <span class="number">2018</span>-<span class="number">12</span>-<span class="number">15</span> <span class="number">15</span>:<span class="number">47</span>:<span class="number">17</span><span class="variable">.331</span> [http-nio-<span class="number">8080</span>-exec-<span class="number">1</span>] DEBUG com<span class="variable">.example</span><span class="variable">.demo</span><span class="variable">.aspect</span><span class="variable">.MyLogAspect</span> - Parameters -----&gt;org<span class="variable">.apache</span><span class="variable">.catalina</span><span class="variable">.util</span><span class="variable">.ParameterMap</span>@<span class="number">5</span>a243ff8 </span><br><span class="line"><span class="number">151080</span> <span class="number">2018</span>-<span class="number">12</span>-<span class="number">15</span> <span class="number">15</span>:<span class="number">47</span>:<span class="number">17</span><span class="variable">.331</span> [http-nio-<span class="number">8080</span>-exec-<span class="number">1</span>] DEBUG com<span class="variable">.example</span><span class="variable">.demo</span><span class="variable">.aspect</span><span class="variable">.MyLogAspect</span> - className ------&gt; com<span class="variable">.example</span><span class="variable">.demo</span><span class="variable">.controller</span><span class="variable">.HelloController</span> </span><br><span class="line"><span class="number">151081</span> <span class="number">2018</span>-<span class="number">12</span>-<span class="number">15</span> <span class="number">15</span>:<span class="number">47</span>:<span class="number">17</span><span class="variable">.332</span> [http-nio-<span class="number">8080</span>-exec-<span class="number">1</span>] DEBUG com<span class="variable">.example</span><span class="variable">.demo</span><span class="variable">.aspect</span><span class="variable">.MyLogAspect</span> - method ----&gt; user </span><br><span class="line"><span class="number">151081</span> <span class="number">2018</span>-<span class="number">12</span>-<span class="number">15</span> <span class="number">15</span>:<span class="number">47</span>:<span class="number">17</span><span class="variable">.332</span> [http-nio-<span class="number">8080</span>-exec-<span class="number">1</span>] DEBUG com<span class="variable">.example</span><span class="variable">.demo</span><span class="variable">.aspect</span><span class="variable">.MyLogAspect</span> - params -----&gt;[qinghuazangshui] </span><br><span class="line"><span class="number">151081</span> <span class="number">2018</span>-<span class="number">12</span>-<span class="number">15</span> <span class="number">15</span>:<span class="number">47</span>:<span class="number">17</span><span class="variable">.332</span> [http-nio-<span class="number">8080</span>-exec-<span class="number">1</span>] DEBUG com<span class="variable">.example</span><span class="variable">.demo</span><span class="variable">.aspect</span><span class="variable">.MyLogAspect</span> - MyLog日志注解 - 前置通知【在连接点前面执行，前置通知不会影响连接点的执行，除非此处抛出异常】 </span><br><span class="line"><span class="number">151084</span> <span class="number">2018</span>-<span class="number">12</span>-<span class="number">15</span> <span class="number">15</span>:<span class="number">47</span>:<span class="number">17</span><span class="variable">.335</span> [http-nio-<span class="number">8080</span>-exec-<span class="number">1</span>] DEBUG com<span class="variable">.example</span><span class="variable">.demo</span><span class="variable">.aspect</span><span class="variable">.MyLogAspect</span> - MyLog日志注解 - 返回通知【在连接点执行完成后执行，不管是正常执行完成，还是抛出异常，都会执行返回通知中的内容】 </span><br><span class="line"><span class="number">151085</span> <span class="number">2018</span>-<span class="number">12</span>-<span class="number">15</span> <span class="number">15</span>:<span class="number">47</span>:<span class="number">17</span><span class="variable">.336</span> [http-nio-<span class="number">8080</span>-exec-<span class="number">1</span>] DEBUG com<span class="variable">.example</span><span class="variable">.demo</span><span class="variable">.aspect</span><span class="variable">.MyLogAspect</span> - MyLog日志注解 - 正常返回通知【在连接点正常执行完成后执行，如果连接点抛出异常，则不会执行】</span><br></pre></td></tr></table></figure>

<h3 id="注解内容丰富"><a href="#注解内容丰富" class="headerlink" title="注解内容丰富"></a>注解内容丰富</h3><p>可以在 MyLog 中添加方法，为注解添加相关说明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyLog &#123;</span><br><span class="line"></span><br><span class="line">    ActionPolicy <span class="title function_">action</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在 MyLog 中添加 action() 方法， 该方法的作用是指定用户操作的类型，返回值为 ActionPolicy。 ActionPolicy 是自定义的枚举类，定义了登录、登出、增删改查、上传、下载等操作类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ActionPolicy</span> &#123;</span><br><span class="line"></span><br><span class="line">    LOGIN,</span><br><span class="line"></span><br><span class="line">    LOGOUT,</span><br><span class="line"></span><br><span class="line">    SAVE,</span><br><span class="line"></span><br><span class="line">    DELETE,</span><br><span class="line"></span><br><span class="line">    UDDATE,</span><br><span class="line"></span><br><span class="line">    SEARCH,</span><br><span class="line"></span><br><span class="line">    UPLOAD,</span><br><span class="line"></span><br><span class="line">    DOWNLOAD</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用 MyLog 时需要添加 action 值的声明，否则会发生编译错误</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@MyLog(action = ActionPolicy.SEARCH)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">user</span><span class="params">(<span class="meta">@RequestParam</span> String username)</span> &#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 MyLogAspect 的环绕通知方法下加入 action 的判断，进行相关的业务处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;myLog()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">	<span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> ((MethodSignature)joinPoint.getSignature()).getMethod();</span><br><span class="line">	<span class="type">MyLog</span> <span class="variable">myLog</span> <span class="operator">=</span> method.getAnnotation(MyLog.class);</span><br><span class="line">	<span class="type">ActionPolicy</span> <span class="variable">actionPolicy</span> <span class="operator">=</span> myLog.action();</span><br><span class="line">	<span class="keyword">if</span> (actionPolicy == ActionPolicy.SEARCH) &#123;</span><br><span class="line">		log.debug(<span class="string">&quot;MyLog日志记录 ---------&gt; 查询方法调用&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，也可以增加其他的属性方法，仿照 action() 方法即可</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射</title>
    <url>/2018/12/24/Java%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>Java反射机制是在运行过程中，对于任意一个类，能够动态的获取对象的属性和方法</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li>获取类的变量，调用类的私有方法</li>
<li>增加代码的灵活性</li>
</ol>
<h3 id="获取类的Class对象"><a href="#获取类的Class对象" class="headerlink" title="获取类的Class对象"></a>获取类的Class对象</h3><h4 id="通过对象的getClass-方法"><a href="#通过对象的getClass-方法" class="headerlink" title="通过对象的getClass()方法"></a>通过对象的getClass()方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">Class&lt;?&gt; clazz = str.getClass();</span><br><span class="line">System.out.println(clazz);</span><br></pre></td></tr></table></figure>

<p>输入结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br></pre></td></tr></table></figure>

<h4 id="通过类的-class属性"><a href="#通过类的-class属性" class="headerlink" title="通过类的.class属性"></a>通过类的.class属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz2 = String.class;</span><br><span class="line">System.out.println(clazz2);</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br></pre></td></tr></table></figure>

<h4 id="通过Class类的静态方法forName-String-className"><a href="#通过Class类的静态方法forName-String-className" class="headerlink" title="通过Class类的静态方法forName(String className)"></a>通过Class类的静态方法forName(String className)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz3 = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">System.out.println(clazz3);</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：使用这种方法，需要写上包名，不需要写.class</p>
</blockquote>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>先创建一个实体类User，具体内容如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> level;</span><br><span class="line">	<span class="keyword">private</span> String phone;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name, String password, <span class="type">int</span> level, String phone)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.id = id;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.password = password;</span><br><span class="line">		<span class="built_in">this</span>.level = level;</span><br><span class="line">		<span class="built_in">this</span>.phone = phone;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name, String password)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.id = id;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.password = password;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.id = id;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取所有的构造方法"><a href="#获取所有的构造方法" class="headerlink" title="获取所有的构造方法"></a>获取所有的构造方法</h4><ul>
<li>public Constructor&lt;?&gt;[] getConstructors()</li>
</ul>
<p>获得所有 public 访问权限的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;org.spirit.lemon.reflect.User&quot;</span>);</span><br><span class="line">		</span><br><span class="line">System.out.println(<span class="string">&quot;获取所有的公共构造方法：&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt;[] constructors = clazz.getConstructors();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; constructors.length; i++) &#123;</span><br><span class="line">	System.out.println(constructors[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">获取所有的公共构造方法：</span><br><span class="line"><span class="keyword">public</span> org.spirit.lemon.reflect.User(java.lang.Integer,java.lang.String,java.lang.String)</span><br><span class="line"><span class="keyword">public</span> org.spirit.lemon.reflect.User(java.lang.Integer,java.lang.String,java.lang.String,<span class="type">int</span>,java.lang.String)</span><br><span class="line"><span class="keyword">public</span> org.spirit.lemon.reflect.User()</span><br></pre></td></tr></table></figure>

<p>可以看出，只输出了三个public修饰的构造方法，私有的构造方法并未输出</p>
<ul>
<li>public Constructor<T> getConstructor(Class&lt;?&gt;… parameterTypes)</li>
</ul>
<p>获得指定的构造方法，注意只能获得 public 权限的构造方法，其他访问权限的获取不到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;获取指定的公共构造方法:&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; constructor = clazz.getConstructor(Integer.class, String.class, String.class);</span><br><span class="line">System.out.println(constructor);</span><br><span class="line">System.out.println();</span><br><span class="line">		</span><br><span class="line">System.out.println(<span class="string">&quot;私有构造方法测试：&quot;</span>);</span><br><span class="line">constructor = clazz.getConstructor(Integer.class, String.class);</span><br><span class="line">System.out.println(constructor);</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">获取指定的公共构造方法:</span><br><span class="line"><span class="keyword">public</span> org.spirit.lemon.reflect.User(java.lang.Integer,java.lang.String,java.lang.String)</span><br><span class="line"></span><br><span class="line">私有构造方法测试：</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NoSuchMethodException: org.spirit.lemon.reflect.User.&lt;init&gt;(java.lang.Integer, java.lang.String)</span><br><span class="line">	at java.lang.Class.getConstructor0(Class.java:<span class="number">3082</span>)</span><br><span class="line">	at java.lang.Class.getConstructor(Class.java:<span class="number">1825</span>)</span><br><span class="line">	at org.spirit.lemon.reflect.Test.main(Test.java:<span class="number">37</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，只能获取public修饰的构造方法，在获取private修饰的构造方法时，抛出了异常信息</p>
<ul>
<li>public Constructor&lt;?&gt;[] getDeclaredConstructors()</li>
</ul>
<p>获得所有的构造方法，包括（public, private,protected,默认权限的） </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;获取所有的公共构造方法(包括私有构造方法)：&quot;</span>);</span><br><span class="line">Constructor[] constructors = clazz.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; constructors.length; i++) &#123;</span><br><span class="line">	System.out.println(constructors[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">获取所有的公共构造方法(包括私有构造方法)：</span><br><span class="line"><span class="keyword">private</span> org.spirit.lemon.reflect.User(java.lang.Integer,java.lang.String)</span><br><span class="line"><span class="keyword">public</span> org.spirit.lemon.reflect.User(java.lang.Integer,java.lang.String,java.lang.String)</span><br><span class="line"><span class="keyword">public</span> org.spirit.lemon.reflect.User(java.lang.Integer,java.lang.String,java.lang.String,<span class="type">int</span>,java.lang.String)</span><br><span class="line"><span class="keyword">public</span> org.spirit.lemon.reflect.User()</span><br></pre></td></tr></table></figure>

<p>不仅输出了public修饰的构造方法，private的构造方法也有输出</p>
<ul>
<li>public Constructor<T> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</li>
</ul>
<p>获得指定的构造方法，注意可以获取到任何访问权限的构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;获取指定的构造方法(私有构造方法也可以获取)：&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Integer.class, String.class);</span><br><span class="line">System.out.println(constructor);</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">获取指定的构造方法(私有构造方法也可以获取)：</span><br><span class="line"><span class="keyword">private</span> org.spirit.lemon.reflect.User(java.lang.Integer,java.lang.String)</span><br></pre></td></tr></table></figure>

<p>可以看出，private修饰的构造方法也可以获取到</p>
<h4 id="通过构造方法构建实例对象"><a href="#通过构造方法构建实例对象" class="headerlink" title="通过构造方法构建实例对象"></a>通过构造方法构建实例对象</h4><p>获取到构造方法Constructor的对象之后，可以通过Constructor对象创建类的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Integer.class, String.class, String.class);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)constructor.newInstance(<span class="number">1</span>, <span class="string">&quot;lemon&quot;</span>, <span class="string">&quot;a12345+&quot;</span>);</span><br><span class="line">System.out.println(user.toString());</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User [id=<span class="number">1</span>, name=lemon, password=a12345+, level=<span class="literal">null</span>, phone=<span class="literal">null</span>]</span><br></pre></td></tr></table></figure>

<p>不过<strong>私有构造方法好像是不能通过这个方式创建对象的</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Integer.class, String.class);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)constructor.newInstance(<span class="number">1</span>, <span class="string">&quot;lemon&quot;</span>);</span><br><span class="line">System.out.println(user.toString());</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalAccessException: Class org.spirit.lemon.reflect.Test can not access a member of <span class="keyword">class</span> <span class="title class_">org</span>.spirit.lemon.reflect.User with modifiers <span class="string">&quot;private&quot;</span></span><br><span class="line">	at sun.reflect.Reflection.ensureMemberAccess(Reflection.java:<span class="number">102</span>)</span><br><span class="line">	at java.lang.reflect.AccessibleObject.slowCheckMemberAccess(AccessibleObject.java:<span class="number">296</span>)</span><br><span class="line">	at java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:<span class="number">288</span>)</span><br><span class="line">	at java.lang.reflect.Constructor.newInstance(Constructor.java:<span class="number">413</span>)</span><br><span class="line">	at org.spirit.lemon.reflect.Test.main(Test.java:<span class="number">55</span>)</span><br></pre></td></tr></table></figure>

<p>抛出异常，对象创建失败</p>
<h4 id="通过Class对象创建实例对象"><a href="#通过Class对象创建实例对象" class="headerlink" title="通过Class对象创建实例对象"></a>通过Class对象创建实例对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> (User)clazz.newInstance(); <span class="comment">//User.class.newInstance()也可以实现</span></span><br><span class="line">System.out.println(user2.toString());</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User [id=<span class="number">0</span>, name=<span class="literal">null</span>, password=<span class="literal">null</span>, level=<span class="literal">null</span>, phone=<span class="literal">null</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 更多创建对象的方法可以参考<a href="https://blog.csdn.net/w410589502/article/details/56489294">Java 创建对象的几种方式</a></p>
</blockquote>
<h4 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h4><p>添加Student类，继承User的属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span>  <span class="title class_">User</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String cardNo;</span><br><span class="line">	<span class="keyword">private</span> Integer profession;</span><br><span class="line">	<span class="keyword">public</span> String cls;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String cardNo, Integer profession)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.cardNo = cardNo;</span><br><span class="line">		<span class="built_in">this</span>.profession = profession;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getCardNo</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> cardNo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardNo</span><span class="params">(String cardNo)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.cardNo = cardNo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Integer <span class="title function_">getProfession</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> profession;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProfession</span><span class="params">(Integer profession)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.profession = profession;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCls</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCls</span><span class="params">(String cls)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cls = cls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student [cardNo=&quot;</span> + cardNo + <span class="string">&quot;, profession=&quot;</span> + profession + <span class="string">&quot;, cls=&quot;</span> + cls + <span class="string">&quot;, id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name</span><br><span class="line">                + <span class="string">&quot;, password=&quot;</span> + password + <span class="string">&quot;, level=&quot;</span> + level + <span class="string">&quot;, phone=&quot;</span> + phone + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>public Field[] getDeclaredFields()</li>
</ul>
<p>返回 <code>Field</code> 对象的一个数组，包括public、private、protected和default属性，但是<strong>不包括继承的属性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Student.class;	</span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">student.setCardNo(<span class="string">&quot;1001&quot;</span>);</span><br><span class="line">student.setProfession(<span class="number">11055225</span>);</span><br><span class="line">student.setCls(<span class="string">&quot;数媒2班&quot;</span>);</span><br><span class="line"></span><br><span class="line">Field[] fields = clazz.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">	<span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> fields[i];</span><br><span class="line">    field.setAccessible(<span class="literal">true</span>); <span class="comment">//设置属性可访问，否则私有属性无法获取值，抛出IllegalAccessException</span></span><br><span class="line">    </span><br><span class="line">	System.out.println(field);<span class="comment">//属性字段对象</span></span><br><span class="line">			</span><br><span class="line">	System.out.println(field.getName());<span class="comment">//属性名</span></span><br><span class="line">	System.out.println(field.getType());<span class="comment">//属性的类型</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(field.get(student));<span class="comment">//获取对象指定属性的值</span></span><br><span class="line">			</span><br><span class="line">	System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> java.lang.String org.spirit.lemon.reflect.Student.cardNo</span><br><span class="line">cardNo</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line"><span class="number">1001</span></span><br><span class="line">-------------------------</span><br><span class="line"><span class="keyword">private</span> java.lang.Integer org.spirit.lemon.reflect.Student.profession</span><br><span class="line">profession</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.Integer</span><br><span class="line"><span class="number">11055225</span></span><br><span class="line">-------------------------</span><br><span class="line"><span class="keyword">public</span> java.lang.String org.spirit.lemon.reflect.Student.cls</span><br><span class="line">cls</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line">数媒<span class="number">2</span>班</span><br><span class="line">-------------------------</span><br></pre></td></tr></table></figure>
<ul>
<li>public Field[] getFields()</li>
</ul>
<p>获取类的公共属性，包括继承的属性；私有属性无法获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field[] fields = clazz.getFields();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">	<span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> fields[i];</span><br><span class="line">	field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            </span><br><span class="line">	System.out.println(field);</span><br><span class="line">            </span><br><span class="line">	System.out.println(field.getName());</span><br><span class="line">	System.out.println(field.getType());</span><br><span class="line">            </span><br><span class="line">	System.out.println(field.get(student));</span><br><span class="line">            </span><br><span class="line">	System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.String org.spirit.lemon.reflect.Student.cls</span><br><span class="line">cls</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line">数媒<span class="number">2</span>班</span><br><span class="line">-------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> org.spirit.lemon.reflect.User.id</span><br><span class="line">id</span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">-------------------------</span><br><span class="line"><span class="keyword">public</span> java.lang.String org.spirit.lemon.reflect.User.name</span><br><span class="line">name</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line"><span class="literal">null</span></span><br><span class="line">-------------------------</span><br><span class="line"><span class="keyword">public</span> java.lang.String org.spirit.lemon.reflect.User.password</span><br><span class="line">password</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line"><span class="literal">null</span></span><br><span class="line">-------------------------</span><br><span class="line"><span class="keyword">public</span> java.lang.Integer org.spirit.lemon.reflect.User.level</span><br><span class="line">level</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.Integer</span><br><span class="line"><span class="literal">null</span></span><br><span class="line">-------------------------</span><br><span class="line"><span class="keyword">public</span> java.lang.String org.spirit.lemon.reflect.User.phone</span><br><span class="line">phone</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line"><span class="literal">null</span></span><br><span class="line">-------------------------</span><br></pre></td></tr></table></figure>

<p>可以看出，cardNo和profession两个私有属性没有输出</p>
<ul>
<li>public Field getDeclaredField(String name)</li>
</ul>
<p>获取指定属性的Field对象，包括private属性；不可以获取继承自父类的属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        </span><br><span class="line">System.out.println(field);</span><br><span class="line">        </span><br><span class="line">System.out.println(field.getName());</span><br><span class="line">System.out.println(field.getType());</span><br><span class="line">        </span><br><span class="line">System.out.println(field.get(student));</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public java.lang.String org.spirit.lemon.reflect.Student.cls</span><br><span class="line">cls</span><br><span class="line">class java.lang.String</span><br><span class="line">数媒2班</span><br></pre></td></tr></table></figure>
<ul>
<li>public Field getField(String name)</li>
</ul>
<p>获取指定属性的Field对象，包括继承自父类的属性；只能获取public修饰的属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        </span><br><span class="line">System.out.println(field);</span><br><span class="line">        </span><br><span class="line">System.out.println(field.getName());</span><br><span class="line">System.out.println(field.getType());</span><br><span class="line">        </span><br><span class="line">System.out.println(field.get(student));</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.String org.spirit.lemon.reflect.User.name</span><br><span class="line">name</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h4 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h4><p>在User类中添加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;User&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Student类中添加私有方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;Student&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>public Method[] getDeclaredMethods()</li>
</ul>
<p>获取所有的方法，包括private方法，但是不包括继承自父类的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">	<span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> methods[i];</span><br><span class="line">	System.out.println(method);</span><br><span class="line">	System.out.println(method.getName());<span class="comment">//方法名</span></span><br><span class="line">	System.out.println(method.getReturnType());<span class="comment">//返回值</span></span><br><span class="line">			</span><br><span class="line">	<span class="keyword">if</span> (method.getName().contains(<span class="string">&quot;test2&quot;</span>)) &#123;</span><br><span class="line">		method.setAccessible(<span class="literal">true</span>);<span class="comment">//设置可访问，否则私有方法执行报错</span></span><br><span class="line">		System.out.println(<span class="string">&quot;执行test2方法：&quot;</span>);</span><br><span class="line">		method.invoke(student, args);<span class="comment">//执行方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">&quot;---------分割线----------&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.String org.spirit.lemon.reflect.Student.toString()</span><br><span class="line">toString</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line">---------分割线----------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> org.spirit.lemon.reflect.Student.setCls(java.lang.String)</span><br><span class="line">setCls</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">---------分割线----------</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> org.spirit.lemon.reflect.Student.test2()</span><br><span class="line">test2</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">执行test2方法：</span><br><span class="line">Student</span><br><span class="line">---------分割线----------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> org.spirit.lemon.reflect.Student.setCardNo(java.lang.String)</span><br><span class="line">setCardNo</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">---------分割线----------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> org.spirit.lemon.reflect.Student.setProfession(java.lang.Integer)</span><br><span class="line">setProfession</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">---------分割线----------</span><br><span class="line"><span class="keyword">public</span> java.lang.String org.spirit.lemon.reflect.Student.getCardNo()</span><br><span class="line">getCardNo</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line">---------分割线----------</span><br><span class="line"><span class="keyword">public</span> java.lang.String org.spirit.lemon.reflect.Student.getCls()</span><br><span class="line">getCls</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line">---------分割线----------</span><br><span class="line"><span class="keyword">public</span> java.lang.Integer org.spirit.lemon.reflect.Student.getProfession()</span><br><span class="line">getProfession</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.Integer</span><br><span class="line">---------分割线----------</span><br></pre></td></tr></table></figure>

<p>可以看出，User的方法test并没有获取到</p>
<ul>
<li>public Method[] getMethods()</li>
</ul>
<p>获取类的方法，包括继承自父类的方法；但是只能获取public修饰的方法，私有方法不能获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method[] methods = clazz.getMethods();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">	<span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> methods[i];</span><br><span class="line">	System.out.println(method);</span><br><span class="line">	System.out.println(method.getName());<span class="comment">//方法名</span></span><br><span class="line">	System.out.println(method.getReturnType());<span class="comment">//返回值</span></span><br><span class="line">			</span><br><span class="line">	System.out.println(<span class="string">&quot;---------分割线----------&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.String org.spirit.lemon.reflect.Student.toString()</span><br><span class="line">toString</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line">---------分割线----------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> org.spirit.lemon.reflect.Student.setProfession(java.lang.Integer)</span><br><span class="line">setProfession</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">---------分割线----------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> org.spirit.lemon.reflect.Student.setCardNo(java.lang.String)</span><br><span class="line">setCardNo</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">---------分割线----------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> org.spirit.lemon.reflect.Student.setCls(java.lang.String)</span><br><span class="line">setCls</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">---------分割线----------</span><br><span class="line"><span class="keyword">public</span> java.lang.String org.spirit.lemon.reflect.Student.getCardNo()</span><br><span class="line">getCardNo</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line">---------分割线----------</span><br><span class="line"><span class="keyword">public</span> java.lang.Integer org.spirit.lemon.reflect.Student.getProfession()</span><br><span class="line">getProfession</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.Integer</span><br><span class="line">---------分割线----------</span><br><span class="line"><span class="keyword">public</span> java.lang.String org.spirit.lemon.reflect.Student.getCls()</span><br><span class="line">getCls</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line">---------分割线----------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> org.spirit.lemon.reflect.User.test()</span><br><span class="line">test</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">---------分割线----------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait() <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line">wait</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">---------分割线----------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="type">long</span>,<span class="type">int</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line">wait</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">---------分割线----------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="type">long</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line">wait</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">---------分割线----------</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> java.lang.Object.equals(java.lang.Object)</span><br><span class="line">equals</span><br><span class="line"><span class="type">boolean</span></span><br><span class="line">---------分割线----------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> java.lang.Object.hashCode()</span><br><span class="line">hashCode</span><br><span class="line"><span class="type">int</span></span><br><span class="line">---------分割线----------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> java.lang.Class java.lang.Object.getClass()</span><br><span class="line">getClass</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.Class</span><br><span class="line">---------分割线----------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notify()</span><br><span class="line">notify</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">---------分割线----------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notifyAll()</span><br><span class="line">notifyAll</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">---------分割线----------</span><br></pre></td></tr></table></figure>

<p>可以看到Student的私有方法test2()并没有打印出来</p>
<ul>
<li>public Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</li>
</ul>
<p>获取本类指定的方法，包括私有方法；但是不能获取继承自父类的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;test2&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">System.out.println(method);</span><br><span class="line">System.out.println(method.getName());<span class="comment">//方法名</span></span><br><span class="line">System.out.println(method.getReturnType());<span class="comment">//返回值</span></span><br><span class="line">		</span><br><span class="line">method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">method.invoke(student, args);</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> org.spirit.lemon.reflect.Student.test2()</span><br><span class="line">test2</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">Student</span><br></pre></td></tr></table></figure>
<ul>
<li>public Method getMethod(String name, Class&lt;?&gt;… parameterTypes)</li>
</ul>
<p>获取指定的方法，包括继承自父类的方法，但是只能获取public方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;test&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">System.out.println(method);</span><br><span class="line">System.out.println(method.getName());<span class="comment">//方法名</span></span><br><span class="line">System.out.println(method.getReturnType());<span class="comment">//返回值</span></span><br><span class="line">method.invoke(student, args);</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> org.spirit.lemon.reflect.User.test()</span><br><span class="line">test</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">User</span><br></pre></td></tr></table></figure>
<h4 id="获取注解"><a href="#获取注解" class="headerlink" title="获取注解"></a>获取注解</h4><p>通过Class对象也可以获取对应的类的注解信息。自定义注解就可以通过获取类&#x2F;方法&#x2F;属性的注解信息来判定是否需要进行必要的逻辑处理。</p>
<p>在类Student的声明上添加两个注解，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Description(&quot;test&quot;)</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span>  <span class="title class_">User</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>public Annotation[] getAnnotations()</li>
</ul>
<p>获取类的注解信息，返回注解类的对象数组；可以获取到继承自父类的注解信息（@Inherited修饰的注解才行）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; annotations.length; i++) &#123;</span><br><span class="line">	<span class="type">Annotation</span> <span class="variable">annotation</span> <span class="operator">=</span> annotations[i];</span><br><span class="line">	System.out.println(annotation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@com</span>.sun.org.glassfish.gmbal.Description(key=, value=test)</span><br><span class="line"><span class="meta">@java</span>.lang.Deprecated()</span><br></pre></td></tr></table></figure>

<p>可以看出，获取到了类的注解信息</p>
<ul>
<li>public Annotation[] getDeclaredAnnotations()</li>
</ul>
<p>获取直接作用在类上的注解信息，不包含继承的注解</p>
<ul>
<li>public <A extends Annotation> A getDeclaredAnnotation(Class<A> annotationClass)</li>
</ul>
<p>获取类的指定类型的注解信息，如果该类配置了指定注解，返回注解的对象信息，否则返回null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Annotation</span> <span class="variable">annotation</span> <span class="operator">=</span> clazz.getDeclaredAnnotation(Deprecated.class);</span><br><span class="line">System.out.println(annotation);</span><br><span class="line">		</span><br><span class="line">annotation = clazz.getDeclaredAnnotation(Documented.class);</span><br><span class="line">System.out.println(annotation);</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@java</span>.lang.Deprecated()</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>Student声明了Deprecated注解，未声明Documented注解，所以第二行输出null</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>也可以通过Class类获取包(Package)、修饰符、父类、泛型等其他信息，此处不做介绍了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>个人在开发过程中用到反射的地方并不是很多，但是使用的框架中（如Spring）大量的应用了反射技术，了解反射的使用方法有助于了解这些框架的实现；</p>
<p>此外，反射会额外的消耗系统资源，效率上较直接创建对象、方法调用较差，但是更加灵活、方便。</p>
<h3 id="待补充"><a href="#待补充" class="headerlink" title="待补充"></a>待补充</h3><ul>
<li>反射的实现原理</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础类型</title>
    <url>/2018/03/16/Java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="计算机中的常用单位"><a href="#计算机中的常用单位" class="headerlink" title="计算机中的常用单位"></a>计算机中的常用单位</h3><h4 id="位-bit"><a href="#位-bit" class="headerlink" title="位 bit"></a>位 bit</h4><p>计算机中的最小单元，缩写为b，值为0或1，表示一位的二进制信息</p>
<h4 id="字节-byte"><a href="#字节-byte" class="headerlink" title="字节 byte"></a>字节 byte</h4><p>计算机中的基本单位，缩写为B，1字节 &#x3D; 8位，即1byte &#x3D; 8bit</p>
<h4 id="千字节-KB"><a href="#千字节-KB" class="headerlink" title="千字节 KB"></a>千字节 KB</h4><p>1KB &#x3D; 1024B</p>
<h4 id="兆字节-MB"><a href="#兆字节-MB" class="headerlink" title="兆字节 MB"></a>兆字节 MB</h4><p>1MB &#x3D; 1024KB</p>
<h4 id="吉字节-GB"><a href="#吉字节-GB" class="headerlink" title="吉字节 GB"></a>吉字节 GB</h4><p>又称千兆字节， 1GB &#x3D; 1024MB</p>
<h4 id="其他单位"><a href="#其他单位" class="headerlink" title="其他单位"></a>其他单位</h4><p>TB 万亿字节 太字节 </p>
<p>PB 千万亿字节 拍字节</p>
<p>EB 百亿亿字节 艾字节</p>
<p>ZB 十万亿亿字节 泽字节</p>
<p>YB 一亿亿亿字节 尧字节</p>
<p>BB 一千亿亿亿字节</p>
<p>NB </p>
<p>DB</p>
<p>转化时，都以1024计算</p>
<h3 id="基础类型及其包装类型"><a href="#基础类型及其包装类型" class="headerlink" title="基础类型及其包装类型"></a>基础类型及其包装类型</h3><table>
<thead>
<tr>
<th>基本类型</th>
<th align="right">存储空间大小</th>
<th align="right">最大值</th>
<th align="right">最小值</th>
<th align="center">包装类类型</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td align="right">-</td>
<td align="right">-</td>
<td align="right">-</td>
<td align="center">Boolean</td>
</tr>
<tr>
<td>char</td>
<td align="right">16bit</td>
<td align="right">Unicode 0</td>
<td align="right">Unicode 2^16-1</td>
<td align="center">Character</td>
</tr>
<tr>
<td>byte</td>
<td align="right">8bit</td>
<td align="right">-128</td>
<td align="right">127</td>
<td align="center">Byte</td>
</tr>
<tr>
<td>short</td>
<td align="right">16bit</td>
<td align="right">-2^15</td>
<td align="right">2^15-1</td>
<td align="center">Short</td>
</tr>
<tr>
<td>int</td>
<td align="right">32bit</td>
<td align="right">-2^31</td>
<td align="right">2^31-1</td>
<td align="center">Integer</td>
</tr>
<tr>
<td>long</td>
<td align="right">64bit</td>
<td align="right">-2^63</td>
<td align="right">2^63-1</td>
<td align="center">Long</td>
</tr>
<tr>
<td>float</td>
<td align="right">32bit</td>
<td align="right">IEEE754</td>
<td align="right">IEEE754</td>
<td align="center">Float</td>
</tr>
<tr>
<td>double</td>
<td align="right">64bit</td>
<td align="right">IEEE754</td>
<td align="right">IEEE754</td>
<td align="center">Double</td>
</tr>
</tbody></table>
<h4 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h4><p>boolean所占用的存储空间的大小没有明确指定，仅定义为能取字面值true和false</p>
<h4 id="char"><a href="#char" class="headerlink" title="char"></a>char</h4><p>即Unicode字符</p>
<p>char类型的字符中包含某些特殊字符，即转义字符</p>
<p>常见的转义字符如下</p>
<ul>
<li>\b 退格</li>
<li>\t 制表</li>
<li>\n 换行</li>
<li>\r 回车</li>
<li>&quot; 双引号</li>
<li>&#39; 单引号</li>
<li>\\ 反斜杠</li>
</ul>
<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>Java中，整形的默认类型为int，默认值为0</p>
<p>byte和short主要用于特定的应用场合，如底层的文件处理</p>
<p><strong>long类型的字面值都应该加L加以区分</strong>，如11L表示的long类型的11，而11则表示的是int类型的11</p>
<h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>float为单精度浮点型。默认值是0.0F</p>
<p>double是双精度浮点型，默认值是0.0</p>
<p>浮点型的默认类型是double</p>
<p>同long类型类似，float的表示要在字面量后方加F进行区分</p>
<p>float和double都不能表示精确的值，如货币，主要原因是浮点数值采用二进制系统表示，而在二进制系统中无法精确的表示分数1&#x2F;10，这就好像十进制无法精确的表示1&#x2F;3一样。如果想要进行高精度的计算，可以使用BigDecimal类，该类大体上也属于“包装类”，但是并没有对应的基础类型。</p>
<h5 id="Double的特殊值"><a href="#Double的特殊值" class="headerlink" title="Double的特殊值"></a>Double的特殊值</h5><p>Double.POSITIVE_INFINITY 正无穷大</p>
<p>Double.NEGATIVE_INFINITY 负无穷大</p>
<p>Double.NaN 非数字</p>
<blockquote>
<p>注意：不能使用 x &#x3D;&#x3D; Double.NaN 的方法检测一个特定值是否等于Double.NaN，可以使用Double.isNaN()方法</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2018/08/17/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<hr>
<h2 id="Java线程池"><a href="#Java线程池" class="headerlink" title="Java线程池"></a>Java线程池</h2><blockquote>
<p>本文参考自<a href="https://blog.csdn.net/u011974987/article/details/51027795"> Java 四种线程池的用法分析</a></p>
</blockquote>
<h3 id="new-Thread的弊端"><a href="#new-Thread的弊端" class="headerlink" title="new Thread的弊端"></a>new Thread的弊端</h3><p>执行一个异步任务你还只是如下new Thread吗？ </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure>

<p><strong>那你就out太多了，new Thread的弊端如下：</strong> </p>
<ul>
<li>每次new Thread新建对象性能差</li>
<li>线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom</li>
<li>缺乏更多功能，如定时执行、定期执行、线程中断</li>
</ul>
<p><strong>相比new Thread，Java提供的四种线程池的好处在于：</strong> </p>
<ul>
<li>重用存在的线程，减少对象创建、消亡的开销，性能佳 </li>
<li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞 </li>
<li>提供定时执行、定期执行、单线程、并发数控制等功能</li>
</ul>
<h3 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h3><p>线程池作用就是限制系统中执行线程的数量。  </p>
<p>根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量，其他线程排 队等候。一个任务执行完毕，再从队列的中取最前面的任务开始执行。若队列中没有等待进程，线程池的这一资源处于等待。当一个新任务需要运行时，如果线程池 中有等待的工作线程，就可以开始运行了；否则进入等待队列。 </p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 </li>
<li>可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li>
</ol>
<p>Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。 </p>
<h3 id="相关的Java类"><a href="#相关的Java类" class="headerlink" title="相关的Java类"></a>相关的Java类</h3><ul>
<li>ExecutorService  真正的线程池接口 </li>
<li>ScheduledExecutorService  能和Timer&#x2F;TimerTask类似，解决那些需要任务重复执行的问题。 </li>
<li>ThreadPoolExecutor   ExecutorService的默认实现。 </li>
<li>ScheduledThreadPoolExecutor  继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。</li>
</ul>
<h3 id="Java中四种线程池"><a href="#Java中四种线程池" class="headerlink" title="Java中四种线程池"></a>Java中四种线程池</h3><p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在Executors类里面提供了一些静态工厂，生成一些常用的线程池。 分别为： </p>
<ul>
<li>newCachedThreadPool	创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li>
<li>newFixedThreadPool   创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li>
<li>newScheduledThreadPool   创建一个定长线程池，支持定时及周期性任务执行。</li>
<li>newSingleThreadExecutor   创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li>
</ul>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p>
<p>示例代码如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheThreadPoolTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">cachedThreadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(index * <span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cachedThreadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    System.out.println(index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下所示：</p>
<p><img src="https://i.imgur.com/cnntMWn.gif"> </p>
<p>当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。</p>
<p>如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。</p>
<p>此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p>
<h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 </p>
<p>示例代码如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedThreadPoolTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">fixedThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">            fixedThreadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;当前线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;, index值为:&quot;</span> + index);</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="https://images.gitee.com/uploads/images/2018/0817/155716_fdea9fd0_1305976.gif" alt="输入图片说明" title="fixed.gif"></p>
<p>可以看出，每次最多同时运行2个线程，超出的线程等待其他线程运行完毕后再运行。其次，加入线程池的线程属于托管状态，线程的运行不受加入顺序的影响。 </p>
<h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><p>创建一个定长线程池，支持定时及周期性任务执行。</p>
<h5 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h5><p>示例代码如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledThreadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(DateTime.now().toString(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>延迟3秒执行run方法中的内容</p>
<h5 id="定期执行"><a href="#定期执行" class="headerlink" title="定期执行"></a>定期执行</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledThreadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(DateTime.now().toString(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表示延迟1秒后每3秒执行一次。 </p>
<p>结果如下：</p>
<p><img src="https://i.imgur.com/pMQNOYh.gif"> </p>
<h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><p><strong>创建一个单线程化的线程池</strong>，这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 </p>
<p>示例代码如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">singleThreadExecutor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">            singleThreadExecutor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(index);</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://i.imgur.com/PMg0miA.gif"> </p>
<p>可以看到，结果依次输出，相当于顺序执行各个任务。 </p>
]]></content>
  </entry>
  <entry>
    <title>Java集合ArrayList</title>
    <url>/2018/07/25/Java%E9%9B%86%E5%90%88ArrayList/</url>
    <content><![CDATA[<mark class="label [primary]">ArrayList</mark> Java 中的动态数组实现，默认容量为10，最大容量为Integer.MAX_VALUE

<p>基于数组实现，所以拥有数组的特点：数据连续，随机访问速度快（实现了RandomAccess标记接口，表明了随机读取的能力）；同样的，因为Java中的数组是不可变的，所以每次的增删数组都涉及到了数组的扩容和拷贝，速度上会较慢（ArrayList如果不考虑扩容的情况，效率和LinkedList不会有太大差别）；</p>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>在添加元素时，考虑到容量的因素，需要按情况进行扩容，默认的扩容方案如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">//扩容判断  size+1即为minCapacity，可满足add操作的最小容量</span></span><br><span class="line">    elementData[size++] = e;<span class="comment">//在末尾追加元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可分配的最大数组长度</span></span><br><span class="line"><span class="comment"> * 一些虚拟机会在数组中保留头文字</span></span><br><span class="line"><span class="comment"> * 去分配一个更大长度的数组可能会导致内存溢出的错误：请求的数组大小超过虚拟机的限制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123; <span class="comment">//如果列表为空（没有元素）</span></span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);<span class="comment">//比较设定的最小容量和默认容量，取其中大最大值为最小容量；即minCapacity不满10，按10处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);<span class="comment">//扩容判断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;<span class="comment">//修改次数加1，这个字段继承自AbstractList，用于在add  set等操作时进行ConcurrentModificationException异常判断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)<span class="comment">//判断最小容量和当前列表的大小，注意是elementData.length而不是size</span></span><br><span class="line">        grow(minCapacity);<span class="comment">//当前容量不足，扩容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;<span class="comment">//原有的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//新容量  原有的容量的1.5倍左右  &gt;&gt; 移位操作  即 1111右移1位变为0111 15-&gt;7</span></span><br><span class="line">    <span class="comment">// int newCapacity = (oldCapacity * 3)/2 + 1;  //JDK1.6的源码</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) <span class="comment">//如果扩容后的容量比所需的最小容量还小  溢出？？</span></span><br><span class="line">        newCapacity = minCapacity; <span class="comment">//设置最小容量为新的容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) <span class="comment">//再判断新容量是否超出所允许的最大长度  MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8 为什么是这个数？？？ 没搞清楚</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity); <span class="comment">//如果新容量超出最大长度，重新扩容</span></span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);<span class="comment">//数组拷贝，新数组长度为新容量的大小，扩容完毕</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();<span class="comment">//溢出  抛异常  感觉不会出现这种情况</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? <span class="comment">//如果最小容量超出所允许的最大长度，新容量就用Integer.MAX_VALUE,否则的话就用MAX_ARRAY_SIZE</span></span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在扩容的过程中涉及到了modCount字段，ArrayList的修改次数，Java中的fail-fast机制，每次去检查修改次数，如果和期望的修改次数不一致，会出现ConcurrentModificationException异常</p>
<blockquote>
<p>fail-fast，快速失败，Java集合中的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出ConcurrentModificationException异常，从而产生fail-fast机制</p>
</blockquote>
<p>除了在添加元素时，自动的扩容之外，ArrayList也可以显式的进行扩容，直接指定ArrayList的最小容量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minExpand</span> <span class="operator">=</span> (elementData != EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// 如果elementData不是空数组，则证明数组已有数据，minExpand为0</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// 等于空数组的话，则默认大小为DEFAULT_CAPACITY 10</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;<span class="comment">//如果需要的最小容量大于minExpand</span></span><br><span class="line">        ensureExplicitCapacity(minCapacity);<span class="comment">//对数组进行扩容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>ArrayList三个构造器，其中两个是根据Collection实现类的标准定义的，另一个<code>public ArrayList(int initialCapacity)</code>用来指定初始化的容量，这个方法是为了在可以预估大概数据量的情况下，指定ArrayList的默认长度，避免扩容和数组拷贝，可以提高插入效率</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造器</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>  数组的大小</span></span><br><span class="line"><span class="comment">   * 如果传入的参数小于0的话，抛出IllegalArgumentException异常</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>();</span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+ initialCapacity);</span><br><span class="line">      <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity]; <span class="comment">//初始化一个Object数组</span></span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 无参构造器，初始化一个空数组</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>();</span><br><span class="line">      <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA; </span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 构造器</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> c 集合类，该集合中的元素必须是ArrayList的泛型的本类或子类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">      elementData = c.toArray(); <span class="comment">//转换为Object数组</span></span><br><span class="line">      size = elementData.length; <span class="comment">//设置size</span></span><br><span class="line"><span class="comment">// c.toArray可能不返回Object数组 详见http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652</span></span><br><span class="line">      <span class="keyword">if</span> (elementData.getClass() != Object[].class) </span><br><span class="line">             <span class="comment">//如果elementData中的元素不是Object类型的，则将其复制到Object数组中，并重新赋值给elementData</span></span><br><span class="line">          elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ArrayList是Collection的实现类，所有通用的Collection实现类（通常通过它的一个子接口间接实现Collection，如List、Queue和Set）应该提供两个“标准”的构造方法：<br>1.无参构造方法，用于创建空的collection<br>2.带有Collection类型单参数的构造方法，用于创建一个具有与其参数相同元素的新collection，如：<code>public ArrayList(Collection&lt;? extends Ec)</code><br>这两个标准不强制必须遵守，但是目前JDK中所有集合实现类都遵守了这两个标准</p>
</blockquote>
<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><h3 id="去除无用空间"><a href="#去除无用空间" class="headerlink" title="去除无用空间"></a>去除无用空间</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">()</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="列表中是否包含某个元素"><a href="#列表中是否包含某个元素" class="headerlink" title="列表中是否包含某个元素"></a>列表中是否包含某个元素</h3><p>其实就是 o&#x3D;&#x3D;null ? e&#x3D;&#x3D;null : o.equals(e)； </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取某个元素的索引值"><a href="#获取某个元素的索引值" class="headerlink" title="获取某个元素的索引值"></a>获取某个元素的索引值</h3><p>返回此列表中首次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;<span class="comment">//如果传入的参数是null，则循环遍历数组，找到第一个为null的值，返回它的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则，遍历数组，查看两个对象是否相等；比对时需要注意equals方法有没有被重写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//如果数组中找不到该值，则返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回此列表中最后一次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> &#123;<span class="comment">//倒叙遍历数组</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p>重写Clone方法，虽然实现了Cloneable接口，但是Cloneable中并没有clone方法；如果不重写clone()方法，当ArrayList对象调用clone()方法时，将抛出CloneNotSupportedException异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="built_in">super</span>.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">//因为ArrayList已经实现了Cloneable，所以这个异常不会发生，</span></span><br><span class="line">        <span class="comment">//如果发生了，就抛出InternalError错误：Java虚拟机中发生了意外的内部错误</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="List转数组"><a href="#List转数组" class="headerlink" title="List转数组"></a>List转数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转化为对象数组，数组中元素顺序和在列表中时一致；重写分配了内存空间，修改该数组不影响原列表；</p>
<p>需要注意的是，这里仍为浅拷贝，修改元素的内容，会影响原列表中元素的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="comment">// Make a new array of a&#x27;s runtime type, but my contents:</span></span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组</p>
<h3 id="获取指定位置的元素"><a href="#获取指定位置的元素" class="headerlink" title="获取指定位置的元素"></a>获取指定位置的元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);<span class="comment">//检查传入的索引参数是否超出列表的最大长度，如果超出，抛出越界异常IndexOutOfBoundsException</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设值"><a href="#设值" class="headerlink" title="设值"></a>设值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">	</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置某个位置的元素为element，该方法返回列表中被替换的值，即原值</p>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!! 保证容量，可能会触发扩容操作</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>列表末尾添加元素，此方法可能会涉及到列表扩容和数组拷贝。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在列表中指定位置插入元素，列表中该位置前的元素不动，后面的元素向后移动一位</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// 将数组中最后一个位置的元素置空，使垃圾回收起效，此处可做参考</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从列表中指定位置移除某个元素，列表的capacity容量不变，但是size减1</p>
<p>该方法返回移除的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移除列表中第一个对象o，成功返回true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>私有删除方法，跳过边界检查，并且不返回删除的值。可参考remove(int index)的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">removeRange</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - toIndex;</span><br><span class="line">    System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                     numMoved);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newSize</span> <span class="operator">=</span> size - (toIndex-fromIndex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> newSize; i &lt; size; i++) &#123;</span><br><span class="line">        elementData[i] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    size = newSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移除列表中索引在fromIndex、toIndex之间的元素</p>
<h3 id="清空列表"><a href="#清空列表" class="headerlink" title="清空列表"></a>清空列表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清空列表元素，执行该方法后，容量不变，但是size变为0</p>
<h3 id="添加集合到列表中"><a href="#添加集合到列表中" class="headerlink" title="添加集合到列表中"></a>添加集合到列表中</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将集合中的元素都添加到列表中，需要注意的是，集合元素的类型必须是列表中元素类型或者其子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把集合中的元素都存入到列表中的指定位置，起始位置由index决定</p>
<h3 id="边界检查"><a href="#边界检查" class="headerlink" title="边界检查"></a>边界检查</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查传入的索引参数是否超出列表的最大长度，如果超出，抛出越界异常</p>
<p>该方法不检查index是否为负数，所以虽然get(i)在传入负值时仍会抛出IndexOutOfBoundsException异常，但是该异常信息是elementData[index]时数组越界产生的，不是ArrayList的rangeCheck方法抛出的，这点需要注意</p>
<p>ArrayList的IndexOutOfBoundsException会调用outOfBoundsMsg方法，显示【”Index: “+index+”, Size: “+size】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheckForAdd</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在add和addAll方法中使用，避免index出现越界问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">outOfBoundsMsg</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Index: &quot;</span>+index+<span class="string">&quot;, Size: &quot;</span>+size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>List越界异常触发时，异常信息详情</p>
<h3 id="交集、差集"><a href="#交集、差集" class="headerlink" title="交集、差集"></a>交集、差集</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从列表中移除集合中的所有元素，相当于数学中的差集</p>
<p>如果集合中元素类型和列表中元素类型不匹配，则会抛出ClassCastException</p>
<p>如果列表中包含null值，但是集合中不允许null，则会抛出NullPointerException</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>列表取列表和集合的交集 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="type">boolean</span> complement)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = <span class="built_in">this</span>.elementData;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">modified</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement) <span class="comment">//该方法取交集或差集</span></span><br><span class="line">                elementData[w++] = elementData[r];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 保留与AbstractCollection的行为兼容性，即使c.contains()抛出异常也会进行部分交集/差集操作。</span></span><br><span class="line">        <span class="keyword">if</span> (r != size) &#123;<span class="comment">//列表没有遍历完就抛出异常</span></span><br><span class="line">            System.arraycopy(elementData, r,</span><br><span class="line">                             elementData, w,</span><br><span class="line">                             size - r);</span><br><span class="line">            w += size - r;<span class="comment">//取交集/差集后，列表应有的长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (w != size) &#123;<span class="comment">//多余的索引位置置空，快速GC</span></span><br><span class="line">            <span class="comment">// clear to let GC do its work</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> w; i &lt; size; i++)</span><br><span class="line">                elementData[i] = <span class="literal">null</span>;</span><br><span class="line">            modCount += size - w;</span><br><span class="line">            size = w;</span><br><span class="line">            modified = <span class="literal">true</span>;<span class="comment">//列表长度发生了改变，则证明进行了交集/差集操作，返回true，代表成功，哪怕抛出了异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除&#x2F;保留列表中的元素（在集合中存在的元素）</p>
<p>complement是boolean类型的，为 true 则保留，即取交集，为false 删除，即取差集 </p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> java.io.IOException&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123; <span class="comment">//防止在ArrayList对象序列化期间修改了ArrayList</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <!--
        /**
         * Returns a list iterator over the elements in this list (in proper
         * sequence), starting at the specified position in the list.
         * The specified index indicates the first element that would be
         * returned by an initial call to {@link ListIterator#next next}.
         * An initial call to {@link ListIterator#previous previous} would
         * return the element with the specified index minus one.
         *
         * <p>The returned list iterator is <a href="#fail-fast"><i>fail-fast</i></a>.
         *
         * @throws IndexOutOfBoundsException {@inheritDoc}
         */
        public ListIterator<E> listIterator(int index) {
            if (index < 0 || index > size)
                throw new IndexOutOfBoundsException("Index: "+index);
            return new ListItr(index);
        }
    
        /**
         * 返回一个基于list元素的迭代器
         * @see #listIterator(int)
         */
        public ListIterator<E> listIterator() {
            return new ListItr(0);
        }
    
        /**
         * Returns an iterator over the elements in this list in proper sequence.
         *
         * <p>The returned iterator is <a href="#fail-fast"><i>fail-fast</i></a>.
         *
         * @return an iterator over the elements in this list in proper sequence
         */
        public Iterator<E> iterator() {
            return new Itr();
        }
    
        /**
         * AbstractList.Itr的优化版本
         */
        private class Itr implements Iterator<E> {
            int cursor;       // 下一个元素的索引
            int lastRet = -1; // 上一个元素的索引，如果没有上一个元素，返回-1
            int expectedModCount = modCount;//修改的次数，防止在迭代遍历期间，修改ArrayList
        
            //是否还有下一个元素
            public boolean hasNext() {
                return cursor != size;
            }
    
            //获取下一个元素的值，其实是获取当前索引位置的值，并将指针指向下一个位置
            @SuppressWarnings("unchecked")
            public E next() {
                checkForComodification();
                int i = cursor;
                if (i >= size)//溢出
                    throw new NoSuchElementException();
                Object[] elementData = ArrayList.this.elementData;
                if (i >= elementData.length)//溢出
                    throw new ConcurrentModificationException();
                cursor = i + 1;//索引加1
                return (E) elementData[lastRet = i];
            }
    
            //移除元素
            public void remove() {
                if (lastRet < 0)
                    throw new IllegalStateException();
                checkForComodification();
    
                try {
                    ArrayList.this.remove(lastRet);
                    cursor = lastRet;
                    lastRet = -1;
                    expectedModCount = modCount;
                } catch (IndexOutOfBoundsException ex) {
                    throw new ConcurrentModificationException();
                }
            }
    
            //防止在迭代遍历期间，修改ArrayList
            final void checkForComodification() {
                if (modCount != expectedModCount)
                    throw new ConcurrentModificationException();
            }
        }
    
        /**
         * AbstractList.ListItr的优化版本
         */
        private class ListItr extends Itr implements ListIterator<E> {
            ListItr(int index) {
                super();
                cursor = index;
            }
    
            public boolean hasPrevious() {
                return cursor != 0;
            }
    
            public int nextIndex() {
                return cursor;
            }
    
            public int previousIndex() {
                return cursor - 1;
            }
    
            @SuppressWarnings("unchecked")
            public E previous() {
                checkForComodification();
                int i = cursor - 1;
                if (i < 0)
                    throw new NoSuchElementException();
                Object[] elementData = ArrayList.this.elementData;
                if (i >= elementData.length)
                    throw new ConcurrentModificationException();
                cursor = i;
                return (E) elementData[lastRet = i];
            }
    
            public void set(E e) {
                if (lastRet < 0)
                    throw new IllegalStateException();
                checkForComodification();
    
                try {
                    ArrayList.this.set(lastRet, e);
                } catch (IndexOutOfBoundsException ex) {
                    throw new ConcurrentModificationException();
                }
            }
    
            public void add(E e) {
                checkForComodification();
    
                try {
                    int i = cursor;
                    ArrayList.this.add(i, e);
                    cursor = i + 1;
                    lastRet = -1;
                    expectedModCount = modCount;
                } catch (IndexOutOfBoundsException ex) {
                    throw new ConcurrentModificationException();
                }
            }
        }
    
        /**
         * 获取列表的子列表
         * @throws IndexOutOfBoundsException
         * @throws IllegalArgumentException 
         */
        public List<E> subList(int fromIndex, int toIndex) {
            subListRangeCheck(fromIndex, toIndex, size);
            return new SubList(this, 0, fromIndex, toIndex);
        }
    
        //检查参数，是否溢出或者开始位置大于结束位置
        static void subListRangeCheck(int fromIndex, int toIndex, int size) {
            if (fromIndex < 0)
                throw new IndexOutOfBoundsException("fromIndex = " + fromIndex);
            if (toIndex > size)
                throw new IndexOutOfBoundsException("toIndex = " + toIndex);
            if (fromIndex > toIndex)
                throw new IllegalArgumentException("fromIndex(" + fromIndex +
                                                   ") > toIndex(" + toIndex + ")");
        }
    
        private class SubList extends AbstractList<E> implements RandomAccess {
            private final AbstractList<E> parent;
            private final int parentOffset;
            private final int offset;
            int size;
    
            SubList(AbstractList<E> parent,
                    int offset, int fromIndex, int toIndex) {
                this.parent = parent;
                this.parentOffset = fromIndex;
                this.offset = offset + fromIndex;
                this.size = toIndex - fromIndex;
                this.modCount = ArrayList.this.modCount;
            }
    
            public E set(int index, E e) {
                rangeCheck(index);
                checkForComodification();
                E oldValue = ArrayList.this.elementData(offset + index);
                ArrayList.this.elementData[offset + index] = e;
                return oldValue;
            }
    
            public E get(int index) {
                rangeCheck(index);
                checkForComodification();
                return ArrayList.this.elementData(offset + index);
            }
    
            public int size() {
                checkForComodification();
                return this.size;
            }
    
            public void add(int index, E e) {
                rangeCheckForAdd(index);
                checkForComodification();
                parent.add(parentOffset + index, e);
                this.modCount = parent.modCount;
                this.size++;
            }
    
            public E remove(int index) {
                rangeCheck(index);
                checkForComodification();
                E result = parent.remove(parentOffset + index);
                this.modCount = parent.modCount;
                this.size--;
                return result;
            }
    
            protected void removeRange(int fromIndex, int toIndex) {
                checkForComodification();
                parent.removeRange(parentOffset + fromIndex,
                                   parentOffset + toIndex);
                this.modCount = parent.modCount;
                this.size -= toIndex - fromIndex;
            }
    
            public boolean addAll(Collection<? extends E> c) {
                return addAll(this.size, c);
            }
    
            public boolean addAll(int index, Collection<? extends E> c) {
                rangeCheckForAdd(index);
                int cSize = c.size();
                if (cSize==0)
                    return false;
    
                checkForComodification();
                parent.addAll(parentOffset + index, c);
                this.modCount = parent.modCount;
                this.size += cSize;
                return true;
            }
    
            public Iterator<E> iterator() {
                return listIterator();
            }
    
            public ListIterator<E> listIterator(final int index) {
                checkForComodification();
                rangeCheckForAdd(index);
                final int offset = this.offset;
    
                return new ListIterator<E>() {
                    int cursor = index;
                    int lastRet = -1;
                    int expectedModCount = ArrayList.this.modCount;
    
                    public boolean hasNext() {
                        return cursor != SubList.this.size;
                    }
    
                    @SuppressWarnings("unchecked")
                    public E next() {
                        checkForComodification();
                        int i = cursor;
                        if (i >= SubList.this.size)
                            throw new NoSuchElementException();
                        Object[] elementData = ArrayList.this.elementData;
                        if (offset + i >= elementData.length)
                            throw new ConcurrentModificationException();
                        cursor = i + 1;
                        return (E) elementData[offset + (lastRet = i)];
                    }
    
                    public boolean hasPrevious() {
                        return cursor != 0;
                    }
    
                    @SuppressWarnings("unchecked")
                    public E previous() {
                        checkForComodification();
                        int i = cursor - 1;
                        if (i < 0)
                            throw new NoSuchElementException();
                        Object[] elementData = ArrayList.this.elementData;
                        if (offset + i >= elementData.length)
                            throw new ConcurrentModificationException();
                        cursor = i;
                        return (E) elementData[offset + (lastRet = i)];
                    }
    
                    public int nextIndex() {
                        return cursor;
                    }
    
                    public int previousIndex() {
                        return cursor - 1;
                    }
    
                    public void remove() {
                        if (lastRet < 0)
                            throw new IllegalStateException();
                        checkForComodification();
    
                        try {
                            SubList.this.remove(lastRet);
                            cursor = lastRet;
                            lastRet = -1;
                            expectedModCount = ArrayList.this.modCount;
                        } catch (IndexOutOfBoundsException ex) {
                            throw new ConcurrentModificationException();
                        }
                    }
    
                    public void set(E e) {
                        if (lastRet < 0)
                            throw new IllegalStateException();
                        checkForComodification();
    
                        try {
                            ArrayList.this.set(offset + lastRet, e);
                        } catch (IndexOutOfBoundsException ex) {
                            throw new ConcurrentModificationException();
                        }
                    }
                
                    public void add(E e) {
                        checkForComodification();
    
                        try {
                            int i = cursor;
                            SubList.this.add(i, e);
                            cursor = i + 1;
                            lastRet = -1;
                            expectedModCount = ArrayList.this.modCount;
                        } catch (IndexOutOfBoundsException ex) {
                            throw new ConcurrentModificationException();
                        }
                    }
                    //检查list是否在遍历中发生了改变
                    final void checkForComodification() {
                        if (expectedModCount != ArrayList.this.modCount)
                            throw new ConcurrentModificationException();
                    }
                };
            }


​			
​	        public List<E> subList(int fromIndex, int toIndex) {
​	            subListRangeCheck(fromIndex, toIndex, size);
​	            return new SubList(this, offset, fromIndex, toIndex);
​	        }
​			
            //是否发生越界
            private void rangeCheck(int index) {
                if (index < 0 || index >= this.size)
                    throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
            }
    
            //是否发生越界
            private void rangeCheckForAdd(int index) {
                if (index < 0 || index > this.size)
                    throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
            }
    
            //越界异常的信息
            private String outOfBoundsMsg(int index) {
                returnx "Index: "+index+", Size: "+this.size;
            }
    
            //检查list是否在遍历中发生了改变
            private void checkForComodification() {
                if (ArrayList.this.modCount != this.modCount)
                    throw new ConcurrentModificationException();
            }
        }
    }
-->]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合Queue</title>
    <url>/2018/07/31/Java%E9%9B%86%E5%90%88Queue/</url>
    <content><![CDATA[<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>接口，继承自Collection，Java集合框架中的队列实现。</p>
<p>除了基本的Collection操作外，队列还提供其他的插入、提取和检查操作。每个方法都存在两种形式：一种抛出异常（操作失败时），另一种返回一个特殊值（null 或 false，具体取决于操作）。插入操作的后一种形式是用于专门为有容量限制的 Queue 实现设计的；在大多数实现中，插入操作不会失败。</p>
<table>
<thead>
<tr>
<th>操作&#x2F;结果</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(e)</td>
<td>offer(e)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr>
<td>检查</td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody></table>
<p>队列通常（但并非一定）以 FIFO（先进先出）的方式排序各个元素。不过优先级队列和 LIFO 队列（或堆栈）例外，前者根据提供的比较器或元素的自然顺序对元素进行排序，后者按 LIFO（后进先出）的方式对元素进行排序。无论使用哪种排序方式，队列的头 都是调用 remove() 或 poll() 所移除的元素。在 FIFO 队列中，所有的新元素都插入队列的末尾。其他种类的队列可能使用不同的元素放置规则。每个 Queue 实现必须指定其顺序属性。</p>
<p>如果可能，offer 方法可插入一个元素，否则返回 false。这与 Collection.add 方法不同，该方法只能通过抛出未经检查的异常使添加元素失败。offer 方法设计用于正常的失败情况，而不是出现异常的情况，例如在容量固定（有界）的队列中。</p>
<p>remove() 和 poll() 方法可移除和返回队列的头。到底从队列中移除哪个元素是队列排序策略的功能，而该策略在各种实现中是不同的。remove() 和 poll() 方法仅在队列为空时其行为有所不同：remove() 方法抛出一个异常，而 poll() 方法则返回 null。</p>
<p>element() 和 peek() 返回但不移除队列的头。</p>
<p>Queue 接口并未定义并发编程中常见的阻塞队列的方法。BlockingQueue 接口定义了那些等待元素出现或等待队列中有可用空间的方法，这些方法扩展了此接口。</p>
<p>Queue 实现通常不允许插入 null 元素，尽管某些实现（如 LinkedList）并不禁止插入 null。即使在允许 null 的实现中，也不应该将 null 插入到 Queue 中，因为 null 也用作 poll 方法的一个特殊返回值，表明队列不包含元素。</p>
<p>Queue 实现通常未定义 equals 和 hashCode 方法的基于元素的版本，而是从 Object 类继承了基于身份的版本，因为对于具有相同元素但有不同排序属性的队列而言，基于元素的相等性不总是很好定义。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="boolean-add-E-e"><a href="#boolean-add-E-e" class="headerlink" title="boolean add(E e)"></a>boolean add(E e)</h4><p>将指定的元素插入此队列，如果队列没满，且可以立即插入，则返回 true。其他异常情况如下：</p>
<ul>
<li>IllegalStateException - 如果由于容量的限制此时不能添加该元素</li>
<li>ClassCastException - 如果指定元素的类不允许将其添加到此队列</li>
<li>NullPointerException - 如果指定元素为 null 并且此队列不允许 null 元素</li>
<li>IllegalArgumentException - 如果此元素的某些属性不允许将其添加到此队列</li>
</ul>
<h4 id="boolean-offer-E-e"><a href="#boolean-offer-E-e" class="headerlink" title="boolean offer(E e)"></a>boolean offer(E e)</h4><p>将指定的元素插入此队列（如果立即可行且不会违反容量限制），当使用有容量限制的队列时，<strong>此方法通常要优于 add(E)，后者可能无法插入元素，而只是抛出一个异常</strong>。</p>
<p>如果该元素已添加到此队列，则返回 true；否则返回 false</p>
<ul>
<li>ClassCastException - 如果指定元素的类不允许将其添加到此队列</li>
<li>NullPointerException - 如果指定元素为 null 并且此队列不允许 null 元素</li>
<li>IllegalArgumentException - 如果此元素的某些属性不允许将其添加到此队列</li>
</ul>
<h4 id="E-remove"><a href="#E-remove" class="headerlink" title="E remove()"></a>E remove()</h4><p>获取并移除此队列的头。此方法与 poll 唯一的不同在于：此队列为空时将抛出一个异常。 </p>
<ul>
<li>NoSuchElementException - 如果此队列为空</li>
</ul>
<h4 id="E-poll"><a href="#E-poll" class="headerlink" title="E poll()"></a>E poll()</h4><p>获取并移除此队列的头，如果此队列为空，则返回 null。</p>
<h4 id="E-element"><a href="#E-element" class="headerlink" title="E element()"></a>E element()</h4><p>获取但是不移除此队列的头。此方法与 peek 唯一的不同在于：此队列为空时将抛出一个异常。</p>
<ul>
<li>NoSuchElementException - 如果此队列为空</li>
</ul>
<h4 id="E-peek"><a href="#E-peek" class="headerlink" title="E peek()"></a>E peek()</h4><p>获取但不移除此队列的头；如果此队列为空，则返回 null。</p>
<h2 id="AbstractQueue"><a href="#AbstractQueue" class="headerlink" title="AbstractQueue"></a>AbstractQueue</h2><p>抽象队列类，实现了Queue接口，继承了AbstractCollection。</p>
<p>此类提供某些Queue操作的骨干实现。此类中的实现适用于基本实现不允许包含null元素时。add、remove 和 element 方法分别基于 offer、poll 和 peek 方法，但是它们通过抛出异常而不是返回 false 或 null 来指示失败。</p>
<p>扩展此类的 Queue 实现至少必须定义一个不允许插入 null 元素的 Queue.offer(E) 方法，该方法以及 Queue.peek()、Queue.poll()、Collection.size() 和 Collection.iterator() 都支持 Iterator.remove() 方法。通常还要重写其他方法。如果无法满足这些要求，那么可以转而考虑为 AbstractCollection 创建子类。</p>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><h4 id="boolean-add-E-e-1"><a href="#boolean-add-E-e-1" class="headerlink" title="boolean add(E e)"></a>boolean add(E e)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (offer(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于offer实现，将指定的元素插入到此队列中（如果立即可行且不会违反容量限制），在成功时返回 true，如果当前没有可用空间，则抛出 IllegalStateException。</p>
<h4 id="E-remove-1"><a href="#E-remove-1" class="headerlink" title="E remove()"></a>E remove()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> poll();</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于poll实现，获取并移除此队列的头。此方法与 poll 唯一的不同在于：此队列为空时将抛出一个异常NoSuchElementException。</p>
<h4 id="E-element-1"><a href="#E-element-1" class="headerlink" title="E element()"></a>E element()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">element</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> peek();</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于peek实现，获取但不移除此队列的头。此方法与 peek 唯一的不同在于：此队列为空时将抛出一个异常NoSuchElementException。</p>
<h4 id="void-clear"><a href="#void-clear" class="headerlink" title="void clear()"></a>void clear()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (poll() != <span class="literal">null</span>)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移除此队列中的所有元素。此调用返回后，队列将为空。</p>
<p>此实现重复调用 poll，直到它返回 null 为止。</p>
<h4 id="boolean-addAll-Collection-lt-extends-E-gt-c"><a href="#boolean-addAll-Collection-lt-extends-E-gt-c" class="headerlink" title="boolean addAll(Collection&lt;? extends E&gt; c)"></a>boolean addAll(Collection&lt;? extends E&gt; c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="built_in">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">modified</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c)</span><br><span class="line">        <span class="keyword">if</span> (add(e))</span><br><span class="line">            modified = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用add方法将指定 collection 中的所有元素都添加到此队列中。如果试图将某一队列 addAll 到该队列本身中，则会导致 IllegalArgumentException。此外，如果正在进行此操作时修改指定的 collection，则此操作的行为是不确定的。</p>
<p>此实现在指定的 collection 上进行迭代，并依次将迭代器返回的每一个元素添加到此队列中。在试图添加某一元素（尤其是 null 元素）时如果遇到了运行时异常，则可能导致在抛出相关异常时只成功地添加了某些元素。</p>
<ul>
<li>ClassCastException - 如果指定 collection 元素的类不允许将该元素添加到此队列中</li>
<li>NullPointerException - 如果指定 collection 包含一个 null 元素并且此队列不允许 null 元素，或者指定 collection 为 null</li>
<li>IllegalArgumentException - 如果指定 collection 元素的某些属性不允许将该元素添加到此队列中，或者指定 collection 是此队列</li>
<li>IllegalStateException - 如果此时由于插入限制无法添加所有元素</li>
</ul>
<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>接口，继承自Queue，支持两个附加操作的Queue，这两个操作是：</p>
<ul>
<li>获取元素时等待队列变为非空</li>
<li>存储元素时等待空间变得可用</li>
</ul>
<p>BlockingQueue 方法以四种形式出现，对于不能立即满足但可能在将来某一时刻可以满足的操作，这四种形式的处理方式不同：第一种是抛出一个异常，第二种是返回一个特殊值（null 或 false，具体取决于操作），第三种是在操作成功前，无限期地阻塞当前线程，第四种是在给定的最大时间限制内阻塞，超时失败。下表中总结了这些方法：</p>
<table>
<thead>
<tr>
<th>操作&#x2F;结果</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>阻塞等待</th>
<th>超时等待</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e, time, unit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time, unit)</td>
</tr>
<tr>
<td>检索</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<p><strong>BlockingQueue 不接受 null 元素</strong>，试图 add、put 或 offer 一个 null 元素时，某些实现会抛出 NullPointerException。null 被用作指示 poll 操作失败的警戒值。</p>
<p><strong>BlockingQueue可以是限定容量的</strong>。它在任意给定时间都可以有一个 remainingCapacity，超出此容量，便无法无阻塞地 put 附加元素。没有任何内部容量约束的 BlockingQueue 总是报告 Integer.MAX_VALUE 的剩余容量。</p>
<p><strong>BlockingQueue实现主要用于生产者-使用者队列</strong>，但它另外还支持 Collection 接口。因此，举例来说，使用 remove(x) 从队列中移除任意一个元素是有可能的。然而，这种操作通常不会有效执行，只能有计划地偶尔使用，比如在取消排队信息时。</p>
<p><strong>BlockingQueue实现是线程安全的</strong>。所有排队方法都可以使用内部锁或其他形式的并发控制来自动达到它们的目的。然而，大量的 Collection 操作（addAll、containsAll、retainAll 和 removeAll）没有必要自动执行，除非在实现中特别说明。因此，举例来说，在只添加了 c 中的一些元素后，addAll(c) 有可能失败（抛出一个异常）。</p>
<p>BlockingQueue 实质上不 支持使用任何一种“close”或“shutdown”操作来指示不再添加任何项。这种功能的需求和使用有依赖于实现的倾向。例如，一种常用的策略是：对于生产者，插入特殊的 end-of-stream 或 poison 对象，并根据使用者获取这些对象的时间来对它们进行解释。</p>
<p>以下是基于典型的生产者-使用者场景的一个用例。注意，BlockingQueue 可以安全地与多个生产者和多个使用者一起使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue queue;</span><br><span class="line">  Producer(BlockingQueue q) &#123; queue = q; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>) &#123; queue.put(produce()); &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123; ... handle ...&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Object <span class="title function_">produce</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue queue;</span><br><span class="line">  Consumer(BlockingQueue q) &#123; queue = q; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>) &#123; consume(queue.take()); &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123; ... handle ...&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">(Object x)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Setup</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">BlockingQueue</span> <span class="variable">q</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SomeQueueImplementation</span>();</span><br><span class="line">    <span class="type">Producer</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(q);</span><br><span class="line">    <span class="type">Consumer</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(q);</span><br><span class="line">    <span class="type">Consumer</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(q);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(p).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(c1).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(c2).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内存一致性效果</strong>：当存在其他并发 collection 时，将对象放入 BlockingQueue 之前的线程中的操作 happen-before 随后通过另一线程从 BlockingQueue 中访问或移除该元素的操作。</p>
<h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><h4 id="boolean-add-E-e-2"><a href="#boolean-add-E-e-2" class="headerlink" title="boolean add(E e)"></a>boolean add(E e)</h4><p>将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，<em>如果当前没有可用的空间，则抛出 IllegalStateException</em>。<strong>当使用有容量限制的队列时，通常首选 offer</strong></p>
<h4 id="boolean-offer-E-e-1"><a href="#boolean-offer-E-e-1" class="headerlink" title="boolean offer(E e)"></a>boolean offer(E e)</h4><p>将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，<em>如果当前没有可用的空间，则返回 false</em>。当使用有容量限制的队列时，此方法通常要优于 add(E)，后者可能无法插入元素，而只是抛出一个异常。</p>
<h4 id="void-put-E-e-throws-InterruptedException"><a href="#void-put-E-e-throws-InterruptedException" class="headerlink" title="void put(E e) throws InterruptedException"></a>void put(E e) throws InterruptedException</h4><p>将指定元素插入此队列中，将等待可用的空间（如果有必要）。</p>
<ul>
<li>InterruptedException - 如果在等待时被中断</li>
<li>ClassCastException - 如果指定元素的类不允许将其添加到此队列</li>
<li>NullPointerException - 如果指定元素为 null</li>
<li>IllegalArgumentException - 如果指定元素的某些属性不允许将其添加到此队列</li>
</ul>
<h4 id="boolean-offer-E-e-long-timeout-TimeUnit-unit-throws-InterruptedException"><a href="#boolean-offer-E-e-long-timeout-TimeUnit-unit-throws-InterruptedException" class="headerlink" title="boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException"></a>boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException</h4><p>将指定元素插入此队列中，在到达指定的等待时间前等待可用的空间（如果有必要）。</p>
<p>如果成功，则返回 true；如果在空间可用前超过了指定的等待时间，则返回 false。</p>
<ul>
<li>InterruptedException - 如果在等待时被中断</li>
<li>ClassCastException - 如果指定元素的类不允许将其添加到此队列</li>
<li>NullPointerException - 如果指定元素为 null</li>
<li>IllegalArgumentException - 如果指定元素的某些属性不允许将其添加到此队列</li>
</ul>
<h4 id="E-take-throws-InterruptedException"><a href="#E-take-throws-InterruptedException" class="headerlink" title="E take() throws InterruptedException"></a>E take() throws InterruptedException</h4><p>获取并移除此队列的头部，在元素变得可用之前一直等待（如果有必要）。</p>
<h4 id="E-poll-long-timeout-TimeUnit-unit-throws-InterruptedException"><a href="#E-poll-long-timeout-TimeUnit-unit-throws-InterruptedException" class="headerlink" title="E poll(long timeout, TimeUnit unit) throws InterruptedException;"></a>E poll(long timeout, TimeUnit unit) throws InterruptedException;</h4><p>获取并移除此队列的头部，在指定的等待时间前等待可用的元素（如果有必要）。</p>
<h4 id="int-remainingCapacity"><a href="#int-remainingCapacity" class="headerlink" title="int remainingCapacity();"></a>int remainingCapacity();</h4><p>返回在无阻塞的理想情况下（不存在内存或资源约束）此队列能接受的附加元素数量，<strong>即剩余容量</strong>；如果没有内部限制，则返回 Integer.MAX_VALUE。</p>
<p>注意，不能 总是通过检查 remainingCapacity 来判断尝试插入元素是否成功，因为可能出现这样的情况：其他线程即将插入或移除一个元素。</p>
<h4 id="boolean-remove-Object-o"><a href="#boolean-remove-Object-o" class="headerlink" title="boolean remove(Object o)"></a>boolean remove(Object o)</h4><p>从此队列中移除指定元素的单个实例（如果存在）。更确切地讲，如果此队列包含一个或多个满足 o.equals(e) 的元素 e，则移除该元素。如果此队列包含指定元素（或者此队列由于调用而发生更改），则返回 true。</p>
<ul>
<li>ClassCastException - 如果指定元素的类与此队列不兼容（可选）</li>
<li>NullPointerException - 如果指定元素为 null（可选）</li>
</ul>
<h4 id="boolean-contains-Object-o"><a href="#boolean-contains-Object-o" class="headerlink" title="boolean contains(Object o)"></a>boolean contains(Object o)</h4><p>如果此队列包含指定元素，则返回 true。更确切地讲，当且仅当此队列至少包含一个满足 o.equals(e) 的元素 e时，返回 true。</p>
<h4 id="int-drainTo-Collection-lt-super-E-gt-c"><a href="#int-drainTo-Collection-lt-super-E-gt-c" class="headerlink" title="int drainTo(Collection&lt;? super E&gt; c)"></a>int drainTo(Collection&lt;? super E&gt; c)</h4><p><strong>移除此队列中所有可用的元素，并将它们添加到给定 Collection 中</strong>。此操作可能比反复轮询此队列更有效。在试图向 Collection c 中添加元素没有成功时，可能导致在抛出相关异常时，元素会同时在两个 Collection 中出现，或者在其中一个 Collection 中出现，也可能在两个 Collection 中都不出现。如果试图将一个队列放入自身队列中，则会导致 IllegalArgumentException 异常。此外，如果正在进行此操作时修改指定的 Collection，则此操作行为是不确定的。</p>
<ul>
<li>UnsupportedOperationException - 如果指定 Collection 不支持添加元素</li>
<li>ClassCastException - 如果此队列元素的类不允许将其添加到指定 Collection</li>
<li>NullPointerException - 如果指定 Collection 为 null</li>
<li>IllegalArgumentException - 如果指定 Collection 是此队列，或者此队列元素的某些属性不允许将其添加到指定 Collection</li>
</ul>
<h4 id="int-drainTo-Collection-lt-super-E-gt-c-int-maxElements"><a href="#int-drainTo-Collection-lt-super-E-gt-c-int-maxElements" class="headerlink" title="int drainTo(Collection&lt;? super E&gt; c, int maxElements);"></a>int drainTo(Collection&lt;? super E&gt; c, int maxElements);</h4><ul>
<li>maxElements - 传输元素的最大数量</li>
</ul>
<p>最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 Collection 中。在试图向 Collection c 中添加元素没有成功时，可能导致在抛出相关异常时，元素会同时在两个 Collection 中出现，或者在其中一个 Collection 中出现，也可能在两个 Collection 中都不出现。如果试图将一个队列放入自身队列中，则会导致 IllegalArgumentException 异常。此外，如果正在进行此操作时修改指定的 Collection，则此操作行为是不确定的。</p>
<h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。队列的头部是在队列中存在时间最长的元素。队列的尾部 是在队列中存在时间最短的元素。新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。</p>
<p>这是一个典型的“有界缓存区”，固定大小的数组在其中保持生产者插入的元素和使用者提取的元素。<strong>一旦创建了这样的缓存区，就不能再增加其容量。试图向已满队列中放入元素会导致操作受阻塞；试图从空队列中提取元素将导致类似阻塞</strong>。</p>
<p>此类<strong>支持对等待的生产者线程和消费者线程进行排序的可选公平策略</strong>。默认情况下，不保证是这种排序。然而，通过将公平性 (fairness) 设置为 true 而构造的队列允许按照 FIFO 顺序访问线程。公平性通常会降低吞吐量，但也减少了可变性和避免了“不平衡性”。</p>
<p><font color='red'>该队列不允许插入null元素</font>。</p>
<p>源码分析可以参考**<a href="http://www.cnblogs.com/leesf456/p/5533770.html">http://www.cnblogs.com/leesf456/p/5533770.html</a>**</p>
<h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p>基于优先级堆（二叉堆）的<strong>无界优先级队列</strong>，优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的Comparator进行排序，具体取决于所使用的构造方法。</p>
<p><strong>优先级队列不允许使用null元素</strong>，依靠自然顺序的优先级队列还不允许插入不可比较的对象（避免可能导致的ClassCastException）。</p>
<p><em><em>此队列的</em>头* 是按指定排序方式确定的*最小</em> 元素**。如果多个元素都是最小值，则头是其中一个元素——选择方法是任意的。队列获取操作 <code>poll</code>、<code>remove</code>、<code>peek</code> 和 <code>element</code> 访问处于队列头的元素。 </p>
<p><strong>优先级队列是无界的</strong>，但是有一个内部<em>容量</em>，控制着用于存储队列元素的数组大小。它通常至少等于队列的大小。随着不断向优先级队列添加元素，<strong>其容量会自动增加</strong>。无需指定容量增加策略的细节。 </p>
<p>此类及其迭代器实现了 <a href="http://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Collection.html"><code>Collection</code></a> 和 <a href="http://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Iterator.html"><code>Iterator</code></a> 接口的所有<em>可选</em> 方法。方法 <a href="http://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/PriorityQueue.html#iterator()"><code>iterator()</code></a> 中提供的迭代器<em>不</em> 保证以任何特定的顺序遍历优先级队列中的元素。如果需要按顺序遍历，请考虑用 <code>Arrays.sort(pq.toArray())</code>。 </p>
<p><strong>注意，此实现不是同步的。</strong>如果多个线程中的任意线程修改了队列，则这些线程不应同时访问 <code>PriorityQueue</code> 实例。相反，请使用线程安全的 <a href="http://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/concurrent/PriorityBlockingQueue.html"><code>PriorityBlockingQueue</code></a> 类。 </p>
<h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p>无界阻塞队列，线程安全</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础</title>
    <url>/2018/06/12/Linux%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="硬盘分区"><a href="#硬盘分区" class="headerlink" title="硬盘分区"></a>硬盘分区</h3><p>先分区再格式化 —— 分区完成后可以格式化不同的文件系统</p>
<p>硬盘的分区主要分为基本分区（primary partion，也可以叫主分区）和扩展分区(extension partion)两种</p>
<p>基本分区和扩展分区的数目之和不能大于四个 —— 分区表上最多只能记录四条记录</p>
<p>基本分区可以马上被使用但不能再分区</p>
<p>扩展分区必须再进行分区后才能使用，也就是说它必须还要进行二次分区。那么由扩展分区再分下去的是什么呢？它就是逻辑分区（logical partion），况且逻辑分区没有数量上限制。</p>
<p>对red hat linux用户来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构。red hat linux中每个分区都是用来组成整个文件系统的一部分，因为它采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个 分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。</p>
<p>对red hat linux来说，你可以把系统文件分几个区来装（必须要说明载入点），也可以就装在同一个分区中（载入点是“&#x2F;”）</p>
<h4 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h4><p>带有硬盘分区信息</p>
<p>分区名的前两个字母标明分区所在设备的类型，通常是hd(IDE磁盘)或sd(SCSI磁盘)</p>
<p>最后的数字代表分区，前四个分区是用数字1到4排列的，记录主分区和扩展分区的信息，逻辑分区从5开始</p>
<h4 id="挂载点-mount-point"><a href="#挂载点-mount-point" class="headerlink" title="挂载点 mount point"></a>挂载点 mount point</h4><h4 id="磁盘的物理结构"><a href="#磁盘的物理结构" class="headerlink" title="磁盘的物理结构"></a>磁盘的物理结构</h4><p>硬盘有数个盘片，每隔盘片有两个面，每个面一个磁头</p>
<p>盘片被划分为多个扇形区域即扇区</p>
<p>同一盘片不同半径的同心圆为磁道</p>
<p>不同盘片相同半径构成的圆柱面即柱面</p>
<p>存储容量 &#x3D; 磁头数 x 磁道（柱面）数 x 每道扇区数 x 每扇区字节数</p>
<p>信息记录可以表示为：</p>
<p>xx磁道（柱面）， xx磁头， xx扇区</p>
<h4 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h4><p>MBR位于硬盘第一个物理扇区（绝对扇区）柱面0，磁头0，扇区1处</p>
<p>MBR中包含硬盘的主引导程序和硬盘分区表</p>
<h4 id="分区方案"><a href="#分区方案" class="headerlink" title="分区方案"></a>分区方案</h4><p>至少两个分区</p>
<p>&#x2F; 分区</p>
<p>SWAP分区</p>
<h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><p><a href="https://www.linuxidc.com/Linux/2014-03/97502.htm">https://www.linuxidc.com/Linux/2014-03/97502.htm</a><br><a href="https://blog.csdn.net/jackyu651/article/details/53070607">https://blog.csdn.net/jackyu651/article/details/53070607</a></p>
<h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><p><a href="https://blog.csdn.net/huaweitman/article/details/51637054">https://blog.csdn.net/huaweitman/article/details/51637054</a></p>
<h3 id="Linux系统文件构成"><a href="#Linux系统文件构成" class="headerlink" title="Linux系统文件构成"></a>Linux系统文件构成</h3><ul>
<li><p>&#x2F; Linux文件系统的入口，最高级目录</p>
</li>
<li><p>&#x2F;usr&#x2F;bin、&#x2F;bin ： 存放所有用户可以执行的命令</p>
</li>
<li><p>&#x2F;usr&#x2F;sbin、&#x2F;sbin ： 存放只有root可以执行的命令</p>
</li>
<li><p>&#x2F;home : 用户缺省的宿主目录</p>
</li>
<li><p>&#x2F;proc ： 虚拟文件系统，存放当前进程信息</p>
</li>
<li><p>&#x2F;dev : 存放设备文件，因为分区在硬盘上，硬盘是设备，所以分区信息全部在&#x2F;dev下</p>
</li>
<li><p>&#x2F;lib : 存放系统程序运行所需的共享库</p>
</li>
<li><p>&#x2F;lost+found : 存放系统出错的检查结果</p>
</li>
<li><p>&#x2F;tmp : 存放临时文件</p>
</li>
<li><p>&#x2F;etc : 存储系统的配置</p>
</li>
<li><p>&#x2F;var : 包含经常发生变动的文件，如日志文件、计划任务等，存放临时文件</p>
</li>
<li><p>&#x2F;usr : 存放所有命令、库、手册等</p>
</li>
<li><p>&#x2F;usr&#x2F;local ： 软件安装的目录</p>
</li>
<li><p>&#x2F;boot ： 内核文件及自举程序文件保存位置，存放启动文件 128M足够</p>
</li>
<li><p>&#x2F;mnt ： 临时系统文件的安装点</p>
</li>
</ul>
<h4 id="SWAP-交换分区"><a href="#SWAP-交换分区" class="headerlink" title="SWAP 交换分区"></a>SWAP 交换分区</h4><p>虚拟内存，配置为实际物理内存的两倍</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux启动顺序</title>
    <url>/2018/06/13/Linux%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="加载BIOS（load-bios）"><a href="#加载BIOS（load-bios）" class="headerlink" title="加载BIOS（load bios）"></a>加载BIOS（load bios）</h3><p>当你打开计算机电源，计算机会首先加载BIOS信息，BIOS信息是如此的重要，以至于计算机必须在最开始就找到它。这是因为BIOS中包含了CPU的相关信息、设备启动顺序信息、硬盘信息、内存信息、时钟信息、PnP特性等等。在此之后，计算机心里就有谱了，知道应该去读取哪个硬件设备了。</p>
<h3 id="读取MBR（read-MBR’s-config-to-find-out-the-OS）"><a href="#读取MBR（read-MBR’s-config-to-find-out-the-OS）" class="headerlink" title="读取MBR（read MBR’s config to find out the OS）"></a>读取MBR（read MBR’s config to find out the OS）</h3><p>众所周知，硬盘上第0磁道第一个扇区被称为MBR，也就是Master Boot Record，即主引导记录，它的大小是512字节，别看地方不大，可里面却存放了预启动信息、分区表信息。</p>
<p>系统找到BIOS所指定的硬盘的MBR后，就会将其复制到0×7c00地址所在的物理内存中。其实被复制到物理内存的内容就是Boot Loader，而具体到你的电脑，那就是lilo或者grub了。</p>
<h3 id="Boot-Loader"><a href="#Boot-Loader" class="headerlink" title="Boot Loader"></a>Boot Loader</h3><p>Boot Loader 就是在操作系统内核运行之前运行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核做好一切准备。</p>
<p>Boot Loader有若干种，其中Grub、Lilo和spfdisk是常见的Loader。</p>
<p>我们以Grub为例来讲解吧，毕竟用lilo和spfdisk的人并不多。</p>
<p>系统读取内存中的grub配置信息（一般为menu.lst或grub.lst），并依照此配置信息来启动不同的操作系统。</p>
<h3 id="加载内核-load-the-kernel-of-the-OS"><a href="#加载内核-load-the-kernel-of-the-OS" class="headerlink" title="加载内核 load the kernel of the OS"></a>加载内核 load the kernel of the OS</h3><p>根据grub设定的内核映像所在路径，系统读取内存映像，并进行解压缩操作。此时，屏幕一般会输出“Uncompressing Linux”的提示。当解压缩内核完成后，屏幕输出“OK, booting the kernel”。</p>
<p>系统将解压后的内核放置在内存之中，并调用start_kernel()函数来启动一系列的初始化函数并初始化各种设备，完成Linux核心环境的建立。至此，Linux内核已经建立起来了，基于Linux的程序应该可以正常运行了。</p>
<h3 id="用户层init依据inittab文件来设定运行等级-init-process-starts"><a href="#用户层init依据inittab文件来设定运行等级-init-process-starts" class="headerlink" title="用户层init依据inittab文件来设定运行等级 init process starts"></a>用户层init依据inittab文件来设定运行等级 init process starts</h3><p>内核被加载后，第一个运行的程序便是&#x2F;sbin&#x2F;init，该文件会读取&#x2F;etc&#x2F;inittab文件，并依据此文件来进行初始化工作。</p>
<p>其实&#x2F;etc&#x2F;inittab文件最主要的作用就是设定Linux的运行等级，其设定形式是“：id:5:initdefault:”，这就表明Linux需要运行在等级5上。Linux的运行等级设定如下：</p>
<p>0：关机<br>1：单用户模式<br>2：无网络支持的多用户模式<br>3：有网络支持的多用户模式<br>4：保留，未使用<br>5：有网络支持有X-Window支持的多用户模式<br>6：重新引导系统，即重启</p>
<p>关于&#x2F;etc&#x2F;inittab文件的学问，其实还有很多</p>
<h3 id="init进程执行rc-sysinit-execute-x2F-etc-x2F-rc-d-x2F-sysinit"><a href="#init进程执行rc-sysinit-execute-x2F-etc-x2F-rc-d-x2F-sysinit" class="headerlink" title="init进程执行rc.sysinit execute &#x2F;etc&#x2F;rc.d&#x2F;sysinit"></a>init进程执行rc.sysinit execute &#x2F;etc&#x2F;rc.d&#x2F;sysinit</h3><p>在设定了运行等级后，Linux系统执行的第一个用户层文件就是&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit脚本程序，它做的工作非常多，包括设定PATH、设定网络配置（&#x2F;etc&#x2F;sysconfig&#x2F;network）、启动swap分区、设定&#x2F;proc等等。如果你有兴趣，可以到&#x2F;etc&#x2F;rc.d中查看一下rc.sysinit文件，里面的脚本够你看几天的</p>
<h3 id="启动内核模块-start-other-modules-x2F-etc-x2F-modules-conf"><a href="#启动内核模块-start-other-modules-x2F-etc-x2F-modules-conf" class="headerlink" title="启动内核模块 start other modules(&#x2F;etc&#x2F;modules.conf)"></a>启动内核模块 start other modules(&#x2F;etc&#x2F;modules.conf)</h3><p>具体是依据&#x2F;etc&#x2F;modules.conf文件或&#x2F;etc&#x2F;modules.d目录下的文件来装载内核模块。</p>
<h3 id="执行不同运行级别的脚本程序-execute-the-run-level-scripts"><a href="#执行不同运行级别的脚本程序-execute-the-run-level-scripts" class="headerlink" title="执行不同运行级别的脚本程序 execute the run level scripts"></a>执行不同运行级别的脚本程序 execute the run level scripts</h3><p>根据运行级别的不同，系统会运行rc0.d到rc6.d中的相应的脚本程序，来完成相应的初始化工作和启动相应的服务。</p>
<h3 id="执行-x2F-etc-x2F-rc-d-x2F-rc-local-execute-x2F-etc-x2F-rc-d-x2F-rc-local"><a href="#执行-x2F-etc-x2F-rc-d-x2F-rc-local-execute-x2F-etc-x2F-rc-d-x2F-rc-local" class="headerlink" title="执行&#x2F;etc&#x2F;rc.d&#x2F;rc.local execute &#x2F;etc&#x2F;rc.d&#x2F;rc.local"></a>执行&#x2F;etc&#x2F;rc.d&#x2F;rc.local execute &#x2F;etc&#x2F;rc.d&#x2F;rc.local</h3><p>你如果打开了此文件，里面有一句话，读过之后，你就会对此命令的作用一目了然：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># This script will be executed *after* all the other init scripts.</span><br><span class="line"># You can put your own initialization stuff in here if you don’t</span><br><span class="line"># want to do the full Sys V style init stuff.</span><br></pre></td></tr></table></figure>

<p>rc.local就是在一切初始化工作后，Linux留给用户进行个性化的地方。你可以把你想设置和启动的东西放到这里。</p>
<h3 id="执行-x2F-bin-x2F-login程序，进入登录状态-execute-x2F-bin-x2F-login"><a href="#执行-x2F-bin-x2F-login程序，进入登录状态-execute-x2F-bin-x2F-login" class="headerlink" title="执行&#x2F;bin&#x2F;login程序，进入登录状态 execute &#x2F;bin&#x2F;login"></a>执行&#x2F;bin&#x2F;login程序，进入登录状态 execute &#x2F;bin&#x2F;login</h3><p>此时，系统已经进入到了等待用户输入username和password的时候了，你已经可以用自己的帐号登入系统了。:)</p>
<p>原文链接：<a href="https://blog.csdn.net/wangzhen209/article/details/72377317">https://blog.csdn.net/wangzhen209/article/details/72377317</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件系统的实现</title>
    <url>/2018/06/12/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<blockquote>
<p>本文转自网络，侵删。 原文地址<a href="https://blog.csdn.net/bv1315008634/article/details/53327002">https://blog.csdn.net/bv1315008634/article/details/53327002</a></p>
</blockquote>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Linux文件管理从用户的层面介绍了Linux管理文件的方式。Linux有一个树状结构来组织文件。树的顶端为根目录(&#x2F;)，节点为目录，而末端的叶子为包含数据的文件。当我们给出一个文件的完整路径时，我们从根目录出发，经过沿途各个目录，最终到达文件。</p>
<p>我们可以对文件进行许多操作，比如打开和读写。在Linux文件管理相关命令中，我们看到许多对文件进行操作的命令。它们大都基于对文件的打开和读写操作。比如cat可以打开文件，读取数据，最后在终端显示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> test.txt</span></span><br></pre></td></tr></table></figure>

<p>对于Linux下的程序员来说，了解文件系统的底层组织方式，是深入进行系统编程所必备的。即使是普通的Linux用户，也可以根据相关的内容，设计出更好的系统维护方案。</p>
<p>操作系统的很多核心组件都是相互关联的，比如虚拟内存管理，物理内存管理，文件系统，缓存系统，IO，设备管理等等，都要放在一起来看才能从整体上理解各个模块到底是如何交互和工作的。这个系列的目的也就是从整体上来理解计算机底层硬件和操作系统的一些重要的组件是如何工作的，从而来指导应用层的开发。这篇讲讲文件系统的重要概念，为后面的IO系统做铺垫。</p>
<p>文件系统主要有三类 </p>
<ol>
<li>位于磁盘的文件系统，在物理磁盘上存储文件，比如NTFS, FAT, ext3, ext4 </li>
<li>虚拟文件系统，在内核中生成，没有物理的存储介质 </li>
<li>网络文件系统，位于远程主机上的文件系统，通过网络访问</li>
</ol>
<p>一个操作系统可以支持多种底层不同的文件系统，为了给内核和用户进程提供统一的文件系统视图，Linux在用户进程和底层文件系统之间加入了一个抽象层，即虚拟文件系统(Virtual File System, VFS)，进程所有的文件操作都通过VFS，由VFS来适配各种底层不同的文件系统，完成实际的文件操作。 </p>
<p>通俗的说，VFS就是定义了一个通用文件系统的接口层和适配层，一方面为用户进程提供了一组统一的访问文件，目录和其他对象的统一方法，另一方面又要和不同的底层文件系统进行适配。 </p>
<p><img src="https://img-blog.csdn.net/20150921111202926"></p>
<p>VFS采用了面向对象的思路来设计它的核心组件，只是VFS是用C写的，没有对象的语法，只能用struct来表示。我们按照面向对象的思路来理解VFS。<br>它有4个主要的对象类型： </p>
<ol>
<li>超级块对象，代表一个具体的已安装(mount)的文件系统 </li>
<li>inode对象，表示一个具体的文件 </li>
<li>目录项对象，代表一个目录项，是路径的一部分，比如一个路径 &#x2F;home&#x2F;foo&#x2F;hello.txt，那么目录项有home, foo, hello.txt </li>
<li>打开文件对象，表示一个打开的文件，有读写的pos位置，也叫文件句柄，说白了就是open系统调用在内核创建的一个数据结构</li>
</ol>
<p>VFS给每个对象都定义了一组操作对象(函数指针)，给出了这些操作的默认实现，底层不同的文件系统可以重写(override)VFS的操作函数来给出自己的具体操作实现，也可以复用VFS的默认实现。实际情况是底层文件系统部分操作由自己单独实现，部分复用了VFS的默认实现。<br>操作对象有: </p>
<ol>
<li>super_operations对象，针对超级块对象，包含了内核对特定文件系统所能调用的方法，比如wirte_inode()，sync_fs()等 </li>
<li>inode_operations对象，针对inode对象，包含了内核对特定文件所能调用的方法，比如create(), link()等 </li>
<li>dentry_operations对象(directory entry)，针对目录项对象，包含了内核对特定目录所能调用的方法，比如d_compare()和d_delete()方法等 </li>
<li>file_operations对象，针对打开文件对象，包含了进程对打开文件对象所能调用的方法，比如read()和write()等</li>
</ol>
<p>文件系统说白了就是文件内容和存储系统对应的块的映射关系，是来管理文件的存储的。inode-block结构把文件分为了两部分，inode表示元数据，block表示存储文件内容的具体的逻辑块。VFS没有用单独的对象来表示block，block的属性在超级块和inode块中包含了。</p>
<h3 id="存储设备分区"><a href="#存储设备分区" class="headerlink" title="存储设备分区"></a>存储设备分区</h3><p>文件系统的最终目的是把大量数据有组织的放入持久性(persistant)的存储设备中，比如硬盘和磁盘。这些存储设备与内存不同。它们的存储能力具有持久性，不会因为断电而消失；存储量大，但读取速度慢。</p>
<p>观察常见存储设备。最开始的区域是MBR，用于Linux开机启动(参考Linux开机启动)。剩余的空间可能分成数个分区(partition)。每个分区有一个相关的分区表(Partition table)，记录分区的相关信息。这个分区表是储存在分区之外的。分区表说明了对应分区的起始位置和分区的大小</p>
<p><img src="https://img-blog.csdn.net/20150921121719849"></p>
<p>我们在Windows系统常常看到C分区、D分区等。Linux系统下也可以有多个分区，但都被挂载在同一个文件系统树上。</p>
<p>数据被存入到某个分区中。一个典型的Linux分区(partition)包含有下面各个部分:</p>
<p><img src="https://img-blog.csdn.net/20150921121751207"></p>
<p>分区的第一个部分是启动区(Boot block)，它主要是为计算机开机服务的。Linux开机启动后，会首先载入MBR，随后MBR从某个硬盘的启动区加载程序。该程序负责进一步的操作系统的加载和启动。为了方便管理，即使某个分区中没有安装操作系统，Linux也会在该分区预留启动区。</p>
<p>启动区之后的是超级区(Super block)。它存储有文件系统的相关信息，包括文件系统的类型，inode的数目，数据块的数目。</p>
<p>随后是多个inodes，它们是实现文件存储的关键。在Linux系统中，一个文件可以分成几个数据块存储，就好像是分散在各地的龙珠一样。为了顺利的收集齐龙珠，我们需要一个“雷达”的指引：该文件对应的inode。每个文件对应一个inode。这个inode中包含多个指针，指向属于该文件各个数据块。当操作系统需要读取文件时，只需要对应inode的”地图”，收集起分散的数据块，就可以收获我们的文件了。</p>
<p>最后一部分，就是真正储存数据的数据块们(data blocks)了。</p>
<h3 id="inode简介"><a href="#inode简介" class="headerlink" title="inode简介"></a>inode简介</h3><p>上面我们看到了存储设备的宏观结构。我们要深入到分区的结构，特别是文件在分区中的存储方式。</p>
<p>文件是文件系统对数据的分割单元。文件系统用目录来组织文件，赋予文件以上下分级的结构。在硬盘上实现这一分级结构的关键，是使用inode来虚拟普通文件和目录文件对象。</p>
<p>在Linux文件管理中，我们知道，一个文件除了自身的数据之外，还有一个附属信息，即文件的元数据(metadata)。这个元数据用于记录文件的许多信息，比如文件大小，拥有人，所属的组，修改日期等等。元数据并不包含在文件的数据中，而是由操作系统维护的。事实上，这个所谓的元数据就包含在inode中。我们可以用$ls -l filename来查看这些元数据。正如我们上面看到的，inode所占据的区域与数据块的区域不同。每个inode有一个唯一的整数编号(inode number)表示。</p>
<p>在保存元数据，inode是“文件”从抽象到具体的关键。正如上一节中提到的，inode储存由一些指针，这些指针指向存储设备中的一些数据块，文件的内容就储存在这些数据块中。当Linux想要打开一个文件时，只需要找到文件对应的inode，然后沿着指针，将所有的数据块收集起来，就可以在内存中组成一个文件的数据了。</p>
<p><img src="https://img-blog.csdn.net/20150921121847465"></p>
<p>数据块在1, 32, 0, …</p>
<p>inode并不是组织文件的唯一方式。最简单的组织文件的方法，是把文件依次顺序的放入存储设备，DVD就采取了类似的方式。但如果有删除操作，删除造成的空余空间夹杂在正常文件之间，很难利用和管理。</p>
<p>复杂的方式可以使用链表，每个数据块都有一个指针，指向属于同一文件的下一个数据块。这样的好处是可以利用零散的空余空间，坏处是对文件的操作必须按照线性方式进行。如果想随机存取，那么必须遍历链表，直到目标位置。由于这一遍历不是在内存进行，所以速度很慢。</p>
<p>FAT系统是将上面链表的指针取出，放入到内存的一个数组中。这样，FAT可以根据内存的索引，迅速的找到一个文件。这样做的主要问题是，索引数组的大小与数据块的总数相同。因此，存储设备很大的话，这个索引数组会比较大。</p>
<p>inode既可以充分利用空间，在内存占据空间不与存储设备相关，解决了上面的问题。但inode也有自己的问题。每个inode能够存储的数据块指针总数是固定的。如果一个文件需要的数据块超过这一总数，inode需要额外的空间来存储多出来的指针。</p>
<h3 id="inode示例"><a href="#inode示例" class="headerlink" title="inode示例"></a>inode示例</h3><p>在Linux中，我们通过解析路径，根据沿途的目录文件来找到某个文件。目录中的条目除了所包含的文件名，还有对应的inode编号。当我们输入$cat &#x2F;var&#x2F;test.txt时，Linux将在根目录文件中找到var这个目录文件的inode编号，然后根据inode合成var的数据。随后，根据var中的记录，找到text.txt的inode编号，沿着inode中的指针，收集数据块，合成text.txt的数据。整个过程中，我们参考了三个inode：根目录文件，var目录文件，text.txt文件的inodes。</p>
<p>在Linux下，可以使用$stat filename，来查询某个文件对应的inode编号。</p>
<p><img src="https://img-blog.csdn.net/20150921121955861"></p>
<p>在存储设备中实际上存储为：</p>
<p><img src="https://img-blog.csdn.net/20150921122004392"></p>
<p>当我们读取一个文件时，实际上是在目录中找到了这个文件的inode编号，然后根据inode的指针，把数据块组合起来，放入内存供进一步的处理。当我们写入一个文件时，是分配一个空白inode给该文件，将其inode编号记入该文件所属的目录，然后选取空白的数据块，让inode的指针指像这些数据块，并放入内存中的数据。</p>
<h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><p>在Linux的进程中，当我们打开一个文件时，返回的是一个文件描述符。这个文件描述符是一个数组的下标，对应数组元素为一个指针。有趣的是，这个指针并没有直接指向文件的inode，而是指向了一个文件表格，再通过该表格，指向加载到内存中的目标文件的inode。如下图，一个进程打开了两个文件。</p>
<p><img src="https://img-blog.csdn.net/20150921122052859"></p>
<p>可以看到，每个文件表格中记录了文件打开的状态(status flags)，比如只读，写入等，还记录了每个文件的当前读写位置(offset)。当有两个进程打开同一个文件时，可以有两个文件表格，每个文件表格对应的打开状态和当前位置不同，从而支持一些文件共享的操作，比如同时读取。</p>
<p>要注意的是进程fork之后的情况，子进程将只复制文件描述符的数组，而和父进程共享内核维护的文件表格和inode。此时要特别小心程序的编写。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis-Plus基于PostgreSQL的代码自动生成</title>
    <url>/2018/07/13/MyBatisPlus%E5%9F%BA%E4%BA%8EPostgreSQL%E7%9A%84%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<p>在MyBatis Plus的代码自动生成器基础上做了一定的修改和优化，配置更加清晰、易懂</p>
<h4 id="相关jar包引入"><a href="#相关jar包引入" class="headerlink" title="相关jar包引入"></a>相关jar包引入</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.plus.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.plus.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;velocity.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>MP默认使用的是velocity模板引擎，所以还是要引入这个包的，如果是使用其他的模板引擎，如FreeMarker，则可以引入FreeMarker的包</p>
<p>引入了mybatis-plus-boot-starter和mybatis-plus的包后，不要再引入mybatis-spring-boot-starter相关的包，以免引起jar包冲突</p>
<h4 id="配置数据库连接信息"><a href="#配置数据库连接信息" class="headerlink" title="配置数据库连接信息"></a>配置数据库连接信息</h4><p>在配置文件中配置数据库连接的信息，代码生成器中直接读取配置文件的信息，不需要重复配置</p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostgreSQLGenerator</span> <span class="keyword">implements</span> <span class="title class_">EnvironmentAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String driverClassName;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PostgreSQLGenerator</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.driverClassName = env.getProperty(<span class="string">&quot;spring.datasource.driverClassName&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.username = env.getProperty(<span class="string">&quot;spring.datasource.username&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.password = env.getProperty(<span class="string">&quot;spring.datasource.password&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.url = env.getProperty(<span class="string">&quot;spring.datasource.url&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generator</span><span class="params">(String[] tables, Integer result)</span> &#123;</span><br><span class="line">        <span class="type">AutoGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoGenerator</span>();</span><br><span class="line">        generator.setGlobalConfig(globalConfig());</span><br><span class="line">        generator.setDataSource(dataSourceConfig());</span><br><span class="line">        generator.setStrategy(strategyConfig(tables));</span><br><span class="line">        generator.setPackageInfo(packageConfig());</span><br><span class="line">        <span class="comment">//generator.setCfg(injectionConfig(result));</span></span><br><span class="line"><span class="comment">//        if (1 == result) &#123;</span></span><br><span class="line"><span class="comment">//            generator.setTemplateEngine(new FreemarkerTemplateEngine());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        generator.execute();</span><br><span class="line">        <span class="comment">// 打印注入设置</span></span><br><span class="line">        <span class="comment">//System.err.println(generator.getCfg().getMap().get(&quot;abc&quot;));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> GlobalConfig <span class="title function_">globalConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GlobalConfig</span> <span class="variable">gc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GlobalConfig</span>();</span><br><span class="line">        gc.setOutputDir(<span class="string">&quot;D://mybatis//&quot;</span>);</span><br><span class="line">        gc.setFileOverride(<span class="literal">true</span>);</span><br><span class="line">        gc.setActiveRecord(<span class="literal">true</span>);<span class="comment">// 开启 activeRecord 模式</span></span><br><span class="line">        gc.setEnableCache(<span class="literal">false</span>);<span class="comment">// XML 二级缓存</span></span><br><span class="line">        gc.setBaseResultMap(<span class="literal">true</span>);<span class="comment">// XML ResultMap</span></span><br><span class="line">        gc.setBaseColumnList(<span class="literal">false</span>);<span class="comment">// XML columList</span></span><br><span class="line">        <span class="comment">//gc.setKotlin(true) 是否生成 kotlin 代码</span></span><br><span class="line">        gc.setAuthor(<span class="string">&quot;wangxinglei&quot;</span>);</span><br><span class="line">        <span class="comment">// 自定义文件命名，注意 %s 会自动填充表实体属性！</span></span><br><span class="line">        <span class="comment">// gc.setEntityName(&quot;%sEntity&quot;);</span></span><br><span class="line">        <span class="comment">// gc.setMapperName(&quot;%sDao&quot;);</span></span><br><span class="line">        <span class="comment">// gc.setXmlName(&quot;%sDao&quot;);</span></span><br><span class="line">        <span class="comment">// gc.setServiceName(&quot;MP%sService&quot;);</span></span><br><span class="line">        <span class="comment">// gc.setServiceImplName(&quot;%sServiceDiy&quot;);</span></span><br><span class="line">        <span class="comment">// gc.setControllerName(&quot;%sAction&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> gc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板引擎配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> TemplateConfig <span class="title function_">templateConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据源配置，从配置文件获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DataSourceConfig <span class="title function_">dataSourceConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        <span class="type">DataSourceConfig</span> <span class="variable">dsc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceConfig</span>();</span><br><span class="line">        dsc.setSchemaname(<span class="string">&quot;public&quot;</span>);</span><br><span class="line">        dsc.setDbType(DbType.POSTGRE_SQL);</span><br><span class="line">        dsc.setTypeConvert(<span class="keyword">new</span> <span class="title class_">PostgreSqlTypeConvert</span>());</span><br><span class="line">        dsc.setDbQuery(<span class="keyword">new</span> <span class="title class_">PostgreSqlQuery</span>());</span><br><span class="line">        dsc.setDriverName(driverClassName);</span><br><span class="line">        dsc.setUsername(username);</span><br><span class="line">        dsc.setPassword(password);</span><br><span class="line">        dsc.setUrl(url);</span><br><span class="line">        <span class="keyword">return</span> dsc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 策略配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> StrategyConfig <span class="title function_">strategyConfig</span><span class="params">(String[] tables)</span> &#123;</span><br><span class="line">        <span class="comment">// 策略配置</span></span><br><span class="line">        <span class="type">StrategyConfig</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrategyConfig</span>();</span><br><span class="line">        <span class="comment">// strategy.setCapitalMode(true);// 全局大写命名</span></span><br><span class="line">        <span class="comment">// strategy.setDbColumnUnderline(true);//全局下划线命名</span></span><br><span class="line">        strategy.setTablePrefix(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;tbl_&quot;</span>&#125;);<span class="comment">// 此处可以修改为您的表前缀</span></span><br><span class="line">        <span class="comment">//strategy.setFieldPrefix(new String[]&#123;&quot;A_&quot;&#125;);</span></span><br><span class="line">        strategy.setNaming(NamingStrategy.underline_to_camel);<span class="comment">// 表名生成策略</span></span><br><span class="line">        strategy.setColumnNaming(NamingStrategy.underline_to_camel);<span class="comment">// 允许字段策略独立设置，默认为 naming 策略</span></span><br><span class="line">        strategy.setInclude(tables); <span class="comment">// 需要生成的表</span></span><br><span class="line"><span class="comment">//        strategy.setExclude(new String[]&#123;&quot;test&quot;&#125;); // 排除生成的表</span></span><br><span class="line">        <span class="comment">// 自定义实体父类</span></span><br><span class="line">        <span class="comment">// strategy.setSuperEntityClass(&quot;com.baomidou.demo.TestEntity&quot;);</span></span><br><span class="line">        <span class="comment">// 自定义实体，公共字段</span></span><br><span class="line">        <span class="comment">// strategy.setSuperEntityColumns(new String[] &#123; &quot;test_id&quot;, &quot;age&quot; &#125;);</span></span><br><span class="line">        <span class="comment">// 自定义 mapper 父类</span></span><br><span class="line">        strategy.setSuperMapperClass(<span class="string">&quot;com.baomidou.mybatisplus.mapper.BaseMapper&quot;</span>);</span><br><span class="line">        <span class="comment">// 自定义 service 父类</span></span><br><span class="line">        strategy.setSuperServiceClass(<span class="string">&quot;com.baomidou.mybatisplus.service.IService&quot;</span>);</span><br><span class="line">        <span class="comment">// 自定义 service 实现类父类</span></span><br><span class="line">        strategy.setSuperServiceImplClass(<span class="string">&quot;com.baomidou.springwind.service.impl.ServiceImpl&quot;</span>);</span><br><span class="line">        <span class="comment">// 自定义 controller 父类</span></span><br><span class="line">        <span class="comment">// strategy.setSuperControllerClass(&quot;com.baomidou.demo.TestController&quot;);</span></span><br><span class="line">        <span class="comment">// 【实体】是否生成字段常量（默认 false）</span></span><br><span class="line">        <span class="comment">// public static final String ID = &quot;test_id&quot;;</span></span><br><span class="line">        <span class="comment">// strategy.setEntityColumnConstant(true);</span></span><br><span class="line">        <span class="comment">// 【实体】是否为构建者模型（默认 false）</span></span><br><span class="line">        <span class="comment">// public User setName(String name) &#123;this.name = name; return this;&#125;</span></span><br><span class="line">        <span class="comment">// strategy.setEntityBuliderModel(true);</span></span><br><span class="line">        <span class="keyword">return</span> strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 包配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> PackageConfig <span class="title function_">packageConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">PackageConfig</span> <span class="variable">pc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageConfig</span>();</span><br><span class="line">        <span class="comment">//pc.setModuleName(&quot;test&quot;);</span></span><br><span class="line">        pc.setParent(<span class="string">&quot;com.lemon.rabbit&quot;</span>);<span class="comment">// 自定义包路径</span></span><br><span class="line">        pc.setController(<span class="string">&quot;controller&quot;</span>);<span class="comment">// 这里是控制器包名，默认 web</span></span><br><span class="line">        pc.setEntity(<span class="string">&quot;model&quot;</span>);</span><br><span class="line">        pc.setMapper(<span class="string">&quot;mapper&quot;</span>);</span><br><span class="line">        pc.setXml(<span class="string">&quot;mapping&quot;</span>);</span><br><span class="line">        pc.setService(<span class="string">&quot;service&quot;</span>);</span><br><span class="line">        pc.setServiceImpl(<span class="string">&quot;service.impl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> pc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> InjectionConfig <span class="title function_">injectionConfig</span><span class="params">(Integer result)</span> &#123;</span><br><span class="line">        <span class="comment">// 注入自定义配置，可以在 VM 中使用 cfg.abc 设置的值</span></span><br><span class="line">        <span class="type">InjectionConfig</span> <span class="variable">cfg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InjectionConfig</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMap</span><span class="params">()</span> &#123;</span><br><span class="line">                Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                map.put(<span class="string">&quot;abc&quot;</span>, <span class="built_in">this</span>.getConfig().getGlobalConfig().getAuthor() + <span class="string">&quot;-mp&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.setMap(map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        List&lt;FileOutConfig&gt; focList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        focList.add(<span class="keyword">new</span> <span class="title class_">FileOutConfig</span>(<span class="string">&quot;/templates/dto.java&quot;</span> + ((<span class="number">1</span> == result) ? <span class="string">&quot;.ftl&quot;</span> : <span class="string">&quot;.vm&quot;</span>)) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">outputFile</span><span class="params">(TableInfo tableInfo)</span> &#123;</span><br><span class="line">                <span class="comment">// 自定义输入文件名称</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;D://test/my_&quot;</span> + tableInfo.getEntityName() + <span class="string">&quot;.java&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        cfg.setFileOutConfigList(focList);</span><br><span class="line">        <span class="keyword">return</span> cfg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEnvironment</span><span class="params">(Environment environment)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.env = environment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>在单元测试中直接调用postgreSQLGenerator的generator方法即可，第一个参数填入对应的表名，可以写一个，也可以写多个，然后执行用例即可生成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseGeneratorTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PostgreSQLGenerator postgreSQLGenerator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        String[] tables = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;tbl_city&quot;</span>&#125;;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        postgreSQLGenerator.generator(tables, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatisPlus主键设置策略</title>
    <url>/2018/12/12/MyBatisPlus%E4%B8%BB%E9%94%AE%E8%AE%BE%E7%BD%AE%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>根据一次插入失败报错来深入了解MyBatis Plus主键设置策略.</p>
<p>今天学习使用MyBatis Plus，发现使用代码生成器生成对应的实体类、Service和Mapper后，在保存数据时报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.baomidou.mybatisplus.exceptions.MybatisPlusException: java.lang.reflect.InvocationTargetException</span><br><span class="line"></span><br><span class="line">	at com.baomidou.mybatisplus.MybatisSqlSessionTemplate$SqlSessionInterceptor.invoke(MybatisSqlSessionTemplate.java:<span class="number">405</span>)</span><br><span class="line">	at com.sun.proxy.$Proxy70.insert(Unknown Source)</span><br><span class="line">	at com.baomidou.mybatisplus.MybatisSqlSessionTemplate.insert(MybatisSqlSessionTemplate.java:<span class="number">243</span>)</span><br><span class="line">	at com.baomidou.mybatisplus.activerecord.Model.insert(Model.java:<span class="number">56</span>)</span><br><span class="line">	at com.lemon.rabbit.common.base.city.CityInitial.printInfo(CityInitial.java:<span class="number">112</span>)</span><br><span class="line">	at com.lemon.rabbit.common.base.city.CityInitial.parseNextLevel(CityInitial.java:<span class="number">87</span>)</span><br><span class="line">	at com.lemon.rabbit.common.base.city.CityInitial.test(CityInitial.java:<span class="number">59</span>)</span><br><span class="line">	at com.lemon.rabbit.RabbitApplicationTests.contextLoads(RabbitApplicationTests.java:<span class="number">19</span>)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">	at org.junit.runners.model.FrameworkMethod$<span class="number">1.</span>runReflectiveCall(FrameworkMethod.java:<span class="number">50</span>)</span><br><span class="line">	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:<span class="number">12</span>)</span><br><span class="line">	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:<span class="number">47</span>)</span><br><span class="line">	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:<span class="number">17</span>)</span><br><span class="line">	at org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:<span class="number">73</span>)</span><br><span class="line">	at org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:<span class="number">83</span>)</span><br><span class="line">	at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:<span class="number">75</span>)</span><br><span class="line">	at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:<span class="number">86</span>)</span><br><span class="line">	at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:<span class="number">84</span>)</span><br><span class="line">	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:<span class="number">325</span>)</span><br><span class="line">	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:<span class="number">251</span>)</span><br><span class="line">	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:<span class="number">97</span>)</span><br><span class="line">	at org.junit.runners.ParentRunner$<span class="number">3.</span>run(ParentRunner.java:<span class="number">290</span>)</span><br><span class="line">	at org.junit.runners.ParentRunner$<span class="number">1.</span>schedule(ParentRunner.java:<span class="number">71</span>)</span><br><span class="line">	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:<span class="number">288</span>)</span><br><span class="line">	at org.junit.runners.ParentRunner.access$<span class="number">000</span>(ParentRunner.java:<span class="number">58</span>)</span><br><span class="line">	at org.junit.runners.ParentRunner$<span class="number">2.</span>evaluate(ParentRunner.java:<span class="number">268</span>)</span><br><span class="line">	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:<span class="number">61</span>)</span><br><span class="line">	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:<span class="number">70</span>)</span><br><span class="line">	at org.junit.runners.ParentRunner.run(ParentRunner.java:<span class="number">363</span>)</span><br><span class="line">	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:<span class="number">190</span>)</span><br><span class="line">	at org.junit.runner.JUnitCore.run(JUnitCore.java:<span class="number">137</span>)</span><br><span class="line">	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:<span class="number">68</span>)</span><br><span class="line">	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:<span class="number">47</span>)</span><br><span class="line">	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:<span class="number">242</span>)</span><br><span class="line">	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:<span class="number">70</span>)</span><br><span class="line">Caused by: java.lang.reflect.InvocationTargetException</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">	at com.baomidou.mybatisplus.MybatisSqlSessionTemplate$SqlSessionInterceptor.invoke(MybatisSqlSessionTemplate.java:<span class="number">401</span>)</span><br><span class="line">	... <span class="number">37</span> more</span><br><span class="line">Caused by: org.apache.ibatis.exceptions.PersistenceException: </span><br><span class="line">### Error updating database.  Cause: org.apache.ibatis.reflection.ReflectionException: Could not set property <span class="string">&#x27;id&#x27;</span> of <span class="string">&#x27;class com.lemon.rabbit.model.City&#x27;</span> with value <span class="string">&#x27;1017367047558582273&#x27;</span> Cause: java.lang.IllegalArgumentException: argument type mismatch</span><br><span class="line">### Cause: org.apache.ibatis.reflection.ReflectionException: Could not set property <span class="string">&#x27;id&#x27;</span> of <span class="string">&#x27;class com.lemon.rabbit.model.City&#x27;</span> with value <span class="string">&#x27;1017367047558582273&#x27;</span> Cause: java.lang.IllegalArgumentException: argument type mismatch</span><br><span class="line">	at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:<span class="number">30</span>)</span><br><span class="line">	at org.apache.ibatis.session.defaults.DefaultSqlSession.update(DefaultSqlSession.java:<span class="number">200</span>)</span><br><span class="line">	at org.apache.ibatis.session.defaults.DefaultSqlSession.insert(DefaultSqlSession.java:<span class="number">185</span>)</span><br><span class="line">	... <span class="number">42</span> more</span><br><span class="line">Caused by: org.apache.ibatis.reflection.ReflectionException: Could not set property <span class="string">&#x27;id&#x27;</span> of <span class="string">&#x27;class com.lemon.rabbit.model.City&#x27;</span> with value <span class="string">&#x27;1017367047558582273&#x27;</span> Cause: java.lang.IllegalArgumentException: argument type mismatch</span><br><span class="line">	at org.apache.ibatis.reflection.wrapper.BeanWrapper.setBeanProperty(BeanWrapper.java:<span class="number">185</span>)</span><br><span class="line">	at org.apache.ibatis.reflection.wrapper.BeanWrapper.set(BeanWrapper.java:<span class="number">59</span>)</span><br><span class="line">	at org.apache.ibatis.reflection.MetaObject.setValue(MetaObject.java:<span class="number">140</span>)</span><br><span class="line">	at com.baomidou.mybatisplus.MybatisDefaultParameterHandler.populateKeys(MybatisDefaultParameterHandler.java:<span class="number">217</span>)</span><br><span class="line">	at com.baomidou.mybatisplus.MybatisDefaultParameterHandler.processBatch(MybatisDefaultParameterHandler.java:<span class="number">156</span>)</span><br><span class="line">	at com.baomidou.mybatisplus.MybatisDefaultParameterHandler.&lt;init&gt;(MybatisDefaultParameterHandler.java:<span class="number">71</span>)</span><br><span class="line">	at com.baomidou.mybatisplus.MybatisXMLLanguageDriver.createParameterHandler(MybatisXMLLanguageDriver.java:<span class="number">37</span>)</span><br><span class="line">	at org.apache.ibatis.session.Configuration.newParameterHandler(Configuration.java:<span class="number">545</span>)</span><br><span class="line">	at org.apache.ibatis.executor.statement.BaseStatementHandler.&lt;init&gt;(BaseStatementHandler.java:<span class="number">69</span>)</span><br><span class="line">	at org.apache.ibatis.executor.statement.PreparedStatementHandler.&lt;init&gt;(PreparedStatementHandler.java:<span class="number">40</span>)</span><br><span class="line">	at org.apache.ibatis.executor.statement.RoutingStatementHandler.&lt;init&gt;(RoutingStatementHandler.java:<span class="number">46</span>)</span><br><span class="line">	at org.apache.ibatis.session.Configuration.newStatementHandler(Configuration.java:<span class="number">558</span>)</span><br><span class="line">	at org.apache.ibatis.executor.SimpleExecutor.doUpdate(SimpleExecutor.java:<span class="number">48</span>)</span><br><span class="line">	at org.apache.ibatis.executor.BaseExecutor.update(BaseExecutor.java:<span class="number">117</span>)</span><br><span class="line">	at org.apache.ibatis.executor.CachingExecutor.update(CachingExecutor.java:<span class="number">76</span>)</span><br><span class="line">	at org.apache.ibatis.session.defaults.DefaultSqlSession.update(DefaultSqlSession.java:<span class="number">198</span>)</span><br><span class="line">	... <span class="number">43</span> more</span><br><span class="line">Caused by: java.lang.IllegalArgumentException: argument type mismatch</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">	at org.apache.ibatis.reflection.invoker.MethodInvoker.invoke(MethodInvoker.java:<span class="number">41</span>)</span><br><span class="line">	at org.apache.ibatis.reflection.wrapper.BeanWrapper.setBeanProperty(BeanWrapper.java:<span class="number">180</span>)</span><br><span class="line">	... <span class="number">58</span> more</span><br></pre></td></tr></table></figure>

<p>实体类City的主键是Integer类型的，在进行insert操作时，MyBatis Plus自动生成了一个Long类型的主键id，导致参数类型不匹配，出现上述错误</p>
<p>经过查看日志和调试发现，MyBatis最终调用BeanWrapper的setBeanProperty方法，通过反射执行最终的插入操作（增删改查应该都是通过此处的反射，不过暂时只调试了insert方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setBeanProperty</span><span class="params">(PropertyTokenizer prop, Object object, Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Invoker</span> <span class="variable">method</span> <span class="operator">=</span> metaClass.getSetInvoker(prop.getName());</span><br><span class="line">        Object[] params = &#123;value&#125;;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method.invoke(object, params);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReflectionException</span>(<span class="string">&quot;Could not set property &#x27;&quot;</span> + prop.getName() + <span class="string">&quot;&#x27; of &#x27;&quot;</span> + object.getClass() + <span class="string">&quot;&#x27; with value &#x27;&quot;</span> + value + <span class="string">&quot;&#x27; Cause: &quot;</span> + t.toString(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此处传入的object即为我们想要保存到数据库的实体信息（不带ID信息），value为主键信息，此时主键值已经是一个Long类型的值，我们接着向上看value是哪里传过来的</p>
<p>setBeanProperty是一个私有方法，在本类调用，查询看到set(PropertyTokenizer prop, Object value)方法调用了它</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(PropertyTokenizer prop, Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop.getIndex() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">collection</span> <span class="operator">=</span> resolveCollection(prop, object);</span><br><span class="line">        setCollectionValue(prop, collection, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      setBeanProperty(prop, object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>set方法中的value也是其他地方传入的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: org.apache.ibatis.reflection.ReflectionException: Could not set property <span class="string">&#x27;id&#x27;</span> of <span class="string">&#x27;class com.lemon.rabbit.model.City&#x27;</span> with value <span class="string">&#x27;1017367047558582273&#x27;</span> Cause: java.lang.IllegalArgumentException: argument type mismatch</span><br><span class="line">	at org.apache.ibatis.reflection.wrapper.BeanWrapper.setBeanProperty(BeanWrapper.java:<span class="number">185</span>)</span><br><span class="line">	at org.apache.ibatis.reflection.wrapper.BeanWrapper.set(BeanWrapper.java:<span class="number">59</span>)</span><br><span class="line">	at org.apache.ibatis.reflection.MetaObject.setValue(MetaObject.java:<span class="number">140</span>)</span><br><span class="line">	at com.baomidou.mybatisplus.MybatisDefaultParameterHandler.populateKeys(MybatisDefaultParameterHandler.java:<span class="number">217</span>)</span><br><span class="line">	at com.baomidou.mybatisplus.MybatisDefaultParameterHandler.processBatch(MybatisDefaultParameterHandler.java:<span class="number">156</span>)</span><br><span class="line">	at com.baomidou.mybatisplus.MybatisDefaultParameterHandler.&lt;init&gt;(MybatisDefaultParameterHandler.java:<span class="number">71</span>)</span><br><span class="line">	at com.baomidou.mybatisplus.MybatisXMLLanguageDriver.createParameterHandler(MybatisXMLLanguageDriver.java:<span class="number">37</span>)</span><br><span class="line">	at org.apache.ibatis.session.Configuration.newParameterHandler(Configuration.java:<span class="number">545</span>)</span><br><span class="line">	at org.apache.ibatis.executor.statement.BaseStatementHandler.&lt;init&gt;(BaseStatementHandler.java:<span class="number">69</span>)</span><br><span class="line">	at org.apache.ibatis.executor.statement.PreparedStatementHandler.&lt;init&gt;(PreparedStatementHandler.java:<span class="number">40</span>)</span><br><span class="line">	at org.apache.ibatis.executor.statement.RoutingStatementHandler.&lt;init&gt;(RoutingStatementHandler.java:<span class="number">46</span>)</span><br><span class="line">	at org.apache.ibatis.session.Configuration.newStatementHandler(Configuration.java:<span class="number">558</span>)</span><br><span class="line">	at org.apache.ibatis.executor.SimpleExecutor.doUpdate(SimpleExecutor.java:<span class="number">48</span>)</span><br><span class="line">	at org.apache.ibatis.executor.BaseExecutor.update(BaseExecutor.java:<span class="number">117</span>)</span><br><span class="line">	at org.apache.ibatis.executor.CachingExecutor.update(CachingExecutor.java:<span class="number">76</span>)</span><br><span class="line">	at org.apache.ibatis.session.defaults.DefaultSqlSession.update(DefaultSqlSession.java:<span class="number">198</span>)</span><br><span class="line">	... <span class="number">43</span> more</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看报错日志可以看到，BeanWrapper的上一层是MetaObject，我们找到MetaObject，看到在getValue方法中调用了BeanWrapper的set方法(BeanWrapper实现了ObjectWrapper)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(String name, Object value)</span> &#123;</span><br><span class="line">    <span class="type">PropertyTokenizer</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyTokenizer</span>(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">        <span class="type">MetaObject</span> <span class="variable">metaValue</span> <span class="operator">=</span> metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">        <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">null</span> &amp;&amp; prop.getChildren() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// don&#x27;t instantiate child path if value is null</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                metaValue = objectWrapper.instantiatePropertyValue(name, prop, objectFactory);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        metaValue.setValue(prop.getChildren(), value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        objectWrapper.set(prop, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MetaObject中的主键值也是上层调用传入的，继续根据错误日志向上看：MybatisDefaultParameterHandler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 自定义元对象填充控制器</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metaObjectHandler 元数据填充处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tableInfo         数据库表反射信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ms                MappedStatement</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameterObject   插入数据库对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> Object <span class="title function_">populateKeys</span><span class="params">(MetaObjectHandler metaObjectHandler, TableInfo tableInfo,</span></span><br><span class="line"><span class="params">                                     MappedStatement ms, Object parameterObject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == tableInfo || StringUtils.isEmpty(tableInfo.getKeyProperty()) || <span class="literal">null</span> == tableInfo.getIdType()) &#123;</span><br><span class="line">        <span class="comment">/* 不处理 */</span></span><br><span class="line">        <span class="keyword">return</span> parameterObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 自定义元对象填充控制器 */</span></span><br><span class="line">    <span class="type">MetaObject</span> <span class="variable">metaObject</span> <span class="operator">=</span> ms.getConfiguration().newMetaObject(parameterObject);</span><br><span class="line">    <span class="keyword">if</span> (ms.getSqlCommandType() == SqlCommandType.INSERT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tableInfo.getIdType().getKey() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">idValue</span> <span class="operator">=</span> metaObject.getValue(tableInfo.getKeyProperty());</span><br><span class="line">            <span class="comment">/* 自定义 ID */</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.checkValNull(idValue)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tableInfo.getIdType() == IdType.ID_WORKER) &#123;</span><br><span class="line">                    metaObject.setValue(tableInfo.getKeyProperty(), IdWorker.getId());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tableInfo.getIdType() == IdType.ID_WORKER_STR) &#123;</span><br><span class="line">                    metaObject.setValue(tableInfo.getKeyProperty(), IdWorker.getIdStr());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tableInfo.getIdType() == IdType.UUID) &#123;</span><br><span class="line">                    metaObject.setValue(tableInfo.getKeyProperty(), IdWorker.get32UUID());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入填充</span></span><br><span class="line">        <span class="keyword">if</span> (metaObjectHandler.openInsertFill()) &#123;</span><br><span class="line">            metaObjectHandler.insertFill(metaObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ms.getSqlCommandType() == SqlCommandType.UPDATE &amp;&amp; metaObjectHandler.openUpdateFill()) &#123;</span><br><span class="line">        <span class="comment">// 更新填充</span></span><br><span class="line">        metaObjectHandler.updateFill(metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> metaObject.getOriginalObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在populateKeys方法中调用了metaObject.setValue()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (StringUtils.checkValNull(idValue)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tableInfo.getIdType() == IdType.ID_WORKER) &#123;</span><br><span class="line">        metaObject.setValue(tableInfo.getKeyProperty(), IdWorker.getId());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tableInfo.getIdType() == IdType.ID_WORKER_STR) &#123;</span><br><span class="line">        metaObject.setValue(tableInfo.getKeyProperty(), IdWorker.getIdStr());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tableInfo.getIdType() == IdType.UUID) &#123;</span><br><span class="line">        metaObject.setValue(tableInfo.getKeyProperty(), IdWorker.get32UUID());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，此处根据IdType生成不同类型的主键id，IdType是一个枚举类，定义了生成ID的类型</p>
<ul>
<li>AUTO 数据库ID自增</li>
<li>INPUT 用户输入ID</li>
<li>ID_WORKER 全局唯一ID，Long类型的主键</li>
<li>ID_WORKER_STR 字符串全局唯一ID</li>
<li>UUID 全局唯一ID，UUID类型的主键</li>
<li>NONE 该类型为未设置主键类型</li>
</ul>
<p>当IdType的类型为ID_WORKER、ID_WORKER_STR或者UUID时，主键由MyBatis Plus的IdWorker类生成</p>
<h4 id="ID-WORKER"><a href="#ID-WORKER" class="headerlink" title="ID_WORKER"></a>ID_WORKER</h4><p>调用IdWorker的getId()方法，生成一个与时间相关的主键id</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> worker.nextId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IdWorker的getId()方法引用了Sequence的nextId()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> timeGen();</span><br><span class="line">    <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;<span class="comment">//闰秒</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> lastTimestamp - timestamp;</span><br><span class="line">        <span class="keyword">if</span> (offset &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait(offset &lt;&lt; <span class="number">1</span>);</span><br><span class="line">                timestamp = timeGen();</span><br><span class="line">                <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(String.format(<span class="string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>, offset));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(String.format(<span class="string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>, offset));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line">        <span class="comment">// 相同毫秒内，序列号自增</span></span><br><span class="line">        sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">        <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 同一毫秒的序列数已经达到最大</span></span><br><span class="line">            timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不同毫秒内，序列号置为 1 - 3 随机数</span></span><br><span class="line">        sequence = ThreadLocalRandom.current().nextLong(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastTimestamp = timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift)    <span class="comment">// 时间戳部分</span></span><br><span class="line">        | (datacenterId &lt;&lt; datacenterIdShift)           <span class="comment">// 数据中心部分</span></span><br><span class="line">        | (workerId &lt;&lt; workerIdShift)                   <span class="comment">// 机器标识部分</span></span><br><span class="line">        | sequence;                                     <span class="comment">// 序列号部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="ID-WORKER-STR"><a href="#ID-WORKER-STR" class="headerlink" title="ID_WORKER_STR"></a>ID_WORKER_STR</h4><p>将worker.nextId()的返回值转化为字符串，和getId()方法相似</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getIdStr</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(worker.nextId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h4><p>去除中划线的UUID字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> String <span class="title function_">get32UUID</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，已经基本可以确认，问题出在IdType的配置上，那么这个IdType从哪里获取的呢？TableInfo中获取的！</p>
<p>TableInfo是数据库表反射信息实体类，此处由其他方法传入的，查看日志：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">at com.baomidou.mybatisplus.MybatisDefaultParameterHandler.populateKeys(MybatisDefaultParameterHandler.java:<span class="number">217</span>)</span><br><span class="line">at com.baomidou.mybatisplus.MybatisDefaultParameterHandler.processBatch(MybatisDefaultParameterHandler.java:<span class="number">156</span>)</span><br></pre></td></tr></table></figure>
<p>通过日志可以看出，populateKeys()方法是在processBatch()方法中调用的，找到该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 批量（填充主键 ID）</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ms</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameterObject 插入数据库对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> Object <span class="title function_">processBatch</span><span class="params">(MappedStatement ms, Object parameterObject)</span> &#123;</span><br><span class="line">    <span class="comment">//检查parameterObject</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == parameterObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isFill</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 全局配置是否配置填充器</span></span><br><span class="line">    <span class="type">MetaObjectHandler</span> <span class="variable">metaObjectHandler</span> <span class="operator">=</span> GlobalConfigUtils.getMetaObjectHandler(ms.getConfiguration());</span><br><span class="line">    <span class="comment">/* 只处理插入或更新操作 */</span></span><br><span class="line">    <span class="keyword">if</span> (ms.getSqlCommandType() == SqlCommandType.INSERT) &#123;</span><br><span class="line">        isFill = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ms.getSqlCommandType() == SqlCommandType.UPDATE</span><br><span class="line">        &amp;&amp; metaObjectHandler.openUpdateFill()) &#123;</span><br><span class="line">        isFill = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isFill) &#123;</span><br><span class="line">        Collection&lt;Object&gt; parameters = getParameters(parameterObject);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != parameters) &#123;</span><br><span class="line">            List&lt;Object&gt; objList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Object parameter : parameters) &#123;</span><br><span class="line">                <span class="type">TableInfo</span> <span class="variable">tableInfo</span> <span class="operator">=</span> TableInfoHelper.getTableInfo(parameter.getClass());</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != tableInfo) &#123;</span><br><span class="line">                    objList.add(populateKeys(metaObjectHandler, tableInfo, ms, parameter));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 非表映射类不处理</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">                    objList.add(parameter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> objList;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">TableInfo</span> <span class="variable">tableInfo</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (parameterObject <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">                <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> (Map) parameterObject;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(<span class="string">&quot;et&quot;</span>)) &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">et</span> <span class="operator">=</span> map.get(<span class="string">&quot;et&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (et != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (et <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">                            <span class="type">Map</span> <span class="variable">realEtMap</span> <span class="operator">=</span> (Map) et;</span><br><span class="line">                            <span class="keyword">if</span> (realEtMap.containsKey(<span class="string">&quot;MP_OPTLOCK_ET_ORIGINAL&quot;</span>)) &#123;<span class="comment">//refer to OptimisticLockerInterceptor.MP_OPTLOCK_ET_ORIGINAL</span></span><br><span class="line">                                tableInfo = TableInfoHelper.getTableInfo(realEtMap.get(<span class="string">&quot;MP_OPTLOCK_ET_ORIGINAL&quot;</span>).getClass());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            tableInfo = TableInfoHelper.getTableInfo(et.getClass());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tableInfo = TableInfoHelper.getTableInfo(parameterObject.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> populateKeys(metaObjectHandler, tableInfo, ms, parameterObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parameterObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面对TableInfo生成的这段代码做个说明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TableInfo</span> <span class="variable">tableInfo</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (parameterObject <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> (Map) parameterObject;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(<span class="string">&quot;et&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">et</span> <span class="operator">=</span> map.get(<span class="string">&quot;et&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (et != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (et <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">                <span class="type">Map</span> <span class="variable">realEtMap</span> <span class="operator">=</span> (Map) et;</span><br><span class="line">                <span class="keyword">if</span> (realEtMap.containsKey(<span class="string">&quot;MP_OPTLOCK_ET_ORIGINAL&quot;</span>)) &#123;<span class="comment">//refer to OptimisticLockerInterceptor.MP_OPTLOCK_ET_ORIGINAL</span></span><br><span class="line">                    tableInfo = TableInfoHelper.getTableInfo(realEtMap.get(<span class="string">&quot;MP_OPTLOCK_ET_ORIGINAL&quot;</span>).getClass());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tableInfo = TableInfoHelper.getTableInfo(et.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    tableInfo = TableInfoHelper.getTableInfo(parameterObject.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>parameterObject：要保存到数据库中的实体类信息</p>
<p>我在保存数据时，参数形式并不是Map类型的，所以直接跳转到else中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tableInfo = TableInfoHelper.getTableInfo(parameterObject.getClass());</span><br></pre></td></tr></table></figure>

<p>根据保存的实体类的类型去获取数据库表反射信息</p>
<p>我们看下getTableInfo()方法的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TableInfo <span class="title function_">getTableInfo</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tableInfoCache.get(ClassUtils.getUserClass(clazz).getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从tableInfoCache中获取指定类型的数据库反射信息。tableInfoCache是一个线程安全的私有静态Map，主要用于存放类型和数据库表的映射关系。断点调试到此处，看下tableInfoCache的内容</p>
<p><img src="https://images.gitee.com/uploads/images/2018/1213/202427_49858b4c_1305976.png" alt="tableInfoCache" title="tablecache.png"></p>
<p>可以看到，idType的值为ID_WORKER，即生成一个与时间相关的Long类型的id。在放入到tableInfoCache的时候就已经指定了idType的值。</p>
<p>查看TableInfoHelper的源码可以得知，initTableInfo()方法负责initTableInfo的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> TableInfo <span class="title function_">initTableInfo</span><span class="params">(MapperBuilderAssistant builderAssistant, Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">    <span class="comment">//检测是否已存在</span></span><br><span class="line">    <span class="type">TableInfo</span> <span class="variable">tableInfo</span> <span class="operator">=</span> tableInfoCache.get(clazz.getName());</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.checkValNotNull(tableInfo)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.checkValNotNull(builderAssistant)) &#123;</span><br><span class="line">            tableInfo.setConfigMark(builderAssistant.getConfiguration());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tableInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    tableInfo = <span class="keyword">new</span> <span class="title class_">TableInfo</span>();</span><br><span class="line">    GlobalConfiguration globalConfig;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != builderAssistant) &#123;</span><br><span class="line">        tableInfo.setCurrentNamespace(builderAssistant.getCurrentNamespace());</span><br><span class="line">        tableInfo.setConfigMark(builderAssistant.getConfiguration());</span><br><span class="line">        <span class="comment">//获取全局配置，其中包括了idType</span></span><br><span class="line">        globalConfig = GlobalConfigUtils.getGlobalConfig(builderAssistant.getConfiguration());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 兼容测试场景</span></span><br><span class="line">        globalConfig = GlobalConfigUtils.DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 表名 */</span></span><br><span class="line">    <span class="type">TableName</span> <span class="variable">table</span> <span class="operator">=</span> clazz.getAnnotation(TableName.class);</span><br><span class="line">    <span class="type">String</span> <span class="variable">tableName</span> <span class="operator">=</span> clazz.getSimpleName();</span><br><span class="line">    <span class="keyword">if</span> (table != <span class="literal">null</span> &amp;&amp; StringUtils.isNotEmpty(table.value())) &#123;</span><br><span class="line">        tableName = table.value();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 开启字段下划线申明</span></span><br><span class="line">        <span class="keyword">if</span> (globalConfig.isDbColumnUnderline()) &#123;</span><br><span class="line">            tableName = StringUtils.camelToUnderline(tableName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 大写命名判断</span></span><br><span class="line">        <span class="keyword">if</span> (globalConfig.isCapitalMode()) &#123;</span><br><span class="line">            tableName = tableName.toUpperCase();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 首字母小写</span></span><br><span class="line">            tableName = StringUtils.firstToLowerCase(tableName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存在表前缀</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != globalConfig.getTablePrefix()) &#123;</span><br><span class="line">            tableName = globalConfig.getTablePrefix() + tableName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tableInfo.setTableName(tableName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启了自定义 KEY 生成器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != globalConfig.getKeyGenerator()) &#123;</span><br><span class="line">        tableInfo.setKeySequence(clazz.getAnnotation(KeySequence.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 表结果集映射 */</span></span><br><span class="line">    <span class="keyword">if</span> (table != <span class="literal">null</span> &amp;&amp; StringUtils.isNotEmpty(table.resultMap())) &#123;</span><br><span class="line">        tableInfo.setResultMap(table.resultMap());</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;TableFieldInfo&gt; fieldList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Field&gt; list = getAllFields(clazz);</span><br><span class="line">    <span class="comment">// 标记是否读取到主键</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isReadPK</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">existTableId</span> <span class="operator">=</span> existTableId(list);</span><br><span class="line">    <span class="keyword">for</span> (Field field : list) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 主键ID 初始化</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!isReadPK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (existTableId) &#123;</span><br><span class="line">                isReadPK = initTableId(globalConfig, tableInfo, field, clazz);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isReadPK = initFieldId(globalConfig, tableInfo, field, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isReadPK) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 字段初始化</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (initTableField(globalConfig, tableInfo, fieldList, field, clazz)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 字段, 使用 camelToUnderline 转换驼峰写法为下划线分割法, 如果已指定 TableField , 便不会执行这里</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        fieldList.add(<span class="keyword">new</span> <span class="title class_">TableFieldInfo</span>(globalConfig, tableInfo, field));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 字段列表 */</span></span><br><span class="line">    tableInfo.setFieldList(globalConfig, fieldList);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 未发现主键注解，提示警告信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(tableInfo.getKeyColumn())) &#123;</span><br><span class="line">        logger.warn(String.format(<span class="string">&quot;Warn: Could not find @TableId in Class: %s.&quot;</span>, clazz.getName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 注入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    tableInfoCache.put(clazz.getName(), tableInfo);</span><br><span class="line">    <span class="keyword">return</span> tableInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在existTableId方法中判断主键注解@TableId是否存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 判断主键注解是否存在</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list 字段列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">existTableId</span><span class="params">(List&lt;Field&gt; list)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exist</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Field field : list) &#123;</span><br><span class="line">        <span class="type">TableId</span> <span class="variable">tableId</span> <span class="operator">=</span> field.getAnnotation(TableId.class);</span><br><span class="line">        <span class="keyword">if</span> (tableId != <span class="literal">null</span>) &#123;</span><br><span class="line">            exist = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当不存在主键注解时，会调用initFieldId()方法对主键属性进行初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">initFieldId</span><span class="params">(GlobalConfiguration globalConfig, TableInfo tableInfo, Field field, Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">column</span> <span class="operator">=</span> field.getName();</span><br><span class="line">    <span class="keyword">if</span> (globalConfig.isCapitalMode()) &#123;</span><br><span class="line">        column = column.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEFAULT_ID_NAME.equalsIgnoreCase(column)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(tableInfo.getKeyColumn())) &#123;</span><br><span class="line">            tableInfo.setIdType(globalConfig.getIdType());</span><br><span class="line">            tableInfo.setKeyColumn(column);</span><br><span class="line">            tableInfo.setKeyProperty(field.getName());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            throwExceptionId(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此， 我们基本可以判断是因为在实体类City中id属性没有加@TableId注解，我们看下TableId的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TableId &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 字段值（驼峰命名方式，该值可无）</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 主键ID</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> IdType&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IdType <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> IdType.NONE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TableId的类型通过type来指定，默认是IdType.NONE（该类型为未设置主键类型），City表是通过数据库的自增序列实现的，所以设置为AUTO</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableId(type = IdType.AUTO)</span></span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br></pre></td></tr></table></figure>

<p>然后测试，程序正常运行，保存数据成功。</p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>对于tableInfo默认的idType值配置，可以看出用的是全局配置的idType，全局配置的值是在initTableInfo()方法中获取的，有兴趣的话可以去看看全局配置的实现，此处暂不深入了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GlobalConfiguration globalConfig;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> != builderAssistant) &#123;</span><br><span class="line">    tableInfo.setCurrentNamespace(builderAssistant.getCurrentNamespace());</span><br><span class="line">    tableInfo.setConfigMark(builderAssistant.getConfiguration());</span><br><span class="line">    globalConfig = GlobalConfigUtils.getGlobalConfig(builderAssistant.getConfiguration());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 兼容测试场景</span></span><br><span class="line">    globalConfig = GlobalConfigUtils.DEFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL查询缓存</title>
    <url>/2018/12/18/MySQL%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>MySQL 查询缓存存储客户端请求的查询结果信息( SELECT 语句)。MySQL 服务器在接收到相同的请求时，会直接将查询缓存中的结果返回给客户端，不再去数据库中重新查询。而且，查询缓存是在多个会话中共享的，一个客户端的查询缓存结果可以被另一个客户端的相同请求复用，从而加快了查询效率。</p>
<p>需要注意的是，查询缓存在 <strong>MySQL5.7.20 版本已过时，在 MySQL8.0 版本中被移除</strong>，所以使用时需要注意 MySQL 服务器的版本信息。</p>
<h3 id="查询缓存配置"><a href="#查询缓存配置" class="headerlink" title="查询缓存配置"></a>查询缓存配置</h3><h4 id="查询缓存的数据库支持"><a href="#查询缓存的数据库支持" class="headerlink" title="查询缓存的数据库支持"></a>查询缓存的数据库支持</h4><p>可以使用 <strong>SHOW VARIABLES LIKE ‘have_query_cache’</strong> 指令查询当前的 MySQL 数据库是否支持查询缓存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;have_query_cache&#x27;;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| have_query_cache | YES   |</span><br><span class="line">+------------------+-------+</span><br><span class="line">1 row in set</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h4><p>也可以通过 <strong>SHOW VARIABLES LIKE ‘%query_cache%’</strong> 来查看查询缓存的详细配置信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;%query_cache%&#x27;;</span><br><span class="line">+------------------------------+---------+</span><br><span class="line">| Variable_name                | Value   |</span><br><span class="line">+------------------------------+---------+</span><br><span class="line">| have_query_cache             | YES     |</span><br><span class="line">| query_cache_limit            | 1048576 |</span><br><span class="line">| query_cache_min_res_unit     | 4096    |</span><br><span class="line">| query_cache_size             | 0       |</span><br><span class="line">| query_cache_type             | ON      |</span><br><span class="line">| query_cache_wlock_invalidate | OFF     |</span><br><span class="line">+------------------------------+---------+</span><br></pre></td></tr></table></figure>

<h5 id="query-cache-limit"><a href="#query-cache-limit" class="headerlink" title="query_cache_limit"></a>query_cache_limit</h5><p>指定单个查询能够使用的缓冲区的大小，默认值是1M大小</p>
<h5 id="query-cache-min-res-unit"><a href="#query-cache-min-res-unit" class="headerlink" title="query_cache_min_res_unit"></a>query_cache_min_res_unit</h5><p>查询缓存分配的最小块的大小，默认大小是 4KB。</p>
<p>MySQL 用于查询的缓存的内存被分成一个个变长数据块，用来存储类型，大小，数据等信息。当服务器启动的时候，会初始化缓存需要的内存。当查询结果需要缓存的时候，先从空闲块中申请一个数据块大于参数 query_cache_min_res_unit 的配置，即使缓存数据很小，申请数据块也是这个，因为查询开始返回结果的时候就分配空间，此时无法预知结果多大。分配内存块需要先锁住空间块，所以操作很慢，MySQL 会尽量避免这个操作，选择尽可能小的内存块，如果不够，继续申请，如果存储完时有多余的空间，则多余的空间将会被释放。</p>
<h5 id="query-cache-size"><a href="#query-cache-size" class="headerlink" title="query_cache_size"></a>query_cache_size</h5><p>查询缓存可用的内存大小，默认情况下是 0，表示无法使用查询缓存。</p>
<p>查询缓存的内存可以手动配置，最小值不能小于 40K，具体的值需要参考系统的数据量和应用场景。如果设置的值太小，则设置不生效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL query_cache_size  = 40000;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;query_cache_size&#x27;;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| query_cache_size | 0     |</span><br><span class="line">+------------------+-------+</span><br></pre></td></tr></table></figure>

<p>官方文档中说明，该情况下，MySQL 服务器还会返回一个警告，我本地的 MySQL 版本是 5.0.96-community-nt 的，并没有返回该警告。如果想看警告效果的话，可以去<a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache-configuration.html">官网</a>进行查看。</p>
<p>query_cache_size 设置的值，如果不是 1024byte 的整数倍，将自动转化为最靠近 1024byte 的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt;  SET GLOBAL query_cache_size = 1000000;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;query_cache_size&#x27;;</span><br><span class="line">+------------------+--------+</span><br><span class="line">| Variable_name    | Value  |</span><br><span class="line">+------------------+--------+</span><br><span class="line">| query_cache_size | 999424 |</span><br><span class="line">+------------------+--------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure>

<h5 id="query-cache-type"><a href="#query-cache-type" class="headerlink" title="query_cache_type"></a>query_cache_type</h5><p>当 query_cache_size 大于 0 的时候，查询缓存的应用将受到 query_cache_type 的影响。</p>
<ul>
<li><p>0 表示不使用查询缓存</p>
</li>
<li><p>1 表示使用使用查询缓存；如果不想用查询缓存的话，可以使用 <strong>SELECT SQL_NO_CACHE</strong> 进行查询操作</p>
</li>
<li><p>2 表示按需使用查询缓存，SQL 语句以 <strong>SELECT SQL_CACHE</strong> 开头表示使用查询缓存</p>
</li>
</ul>
<p>当 query_cache_size 为 0 时，应该同步将 query_cache_type 设置为 0，这样的话 MySQL 服务在执行查询语句的时候讲不再检查查询互斥锁，从而可以提高查询的效率。</p>
<p>query_cache_type 是全局生效的，所有连接到 MySQL 服务的客户端都会共用这个配置，如果某个客户端想设置自己的 query_cache_type 属性，可以通过以下指令实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET SESSION query_cache_type = OFF;</span><br></pre></td></tr></table></figure>

<p>在启动时也可以设置 query_cache_type 的值，但是只能设置数字（0，1，2），不能再使用 ON 和 OFF。</p>
<h4 id="状态监控"><a href="#状态监控" class="headerlink" title="状态监控"></a>状态监控</h4><p>通过 <strong>SHOW STATUS LIKE ‘Qcache%’</strong> 命令可以查询查询缓存当前的情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW STATUS LIKE &#x27;Qcache%&#x27;;</span><br><span class="line">+-------------------------+--------+</span><br><span class="line">| Variable_name           | Value  |</span><br><span class="line">+-------------------------+--------+</span><br><span class="line">| Qcache_free_blocks      | 1      |</span><br><span class="line">| Qcache_free_memory      | 990760 |</span><br><span class="line">| Qcache_hits             | 0      |</span><br><span class="line">| Qcache_inserts          | 0      |</span><br><span class="line">| Qcache_lowmem_prunes    | 0      |</span><br><span class="line">| Qcache_not_cached       | 2      |</span><br><span class="line">| Qcache_queries_in_cache | 0      |</span><br><span class="line">| Qcache_total_blocks     | 1      |</span><br><span class="line">+-------------------------+--------+</span><br></pre></td></tr></table></figure>


<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>查询缓存适用于进行大量重复的查询操作、并且改动量小的表。</p>
<p>如果数据库表中数据和结构发生变化时（增删改、表结构调整），查询缓存将会失效并被清除。</p>
<h3 id="缓存清理"><a href="#缓存清理" class="headerlink" title="缓存清理"></a>缓存清理</h3><p>可以使用以下对查询缓存进行清理操作</p>
<ul>
<li><p>FLUSH QUERY CACHE 清空查询缓存中的碎片</p>
</li>
<li><p>RESET QUERY CACHE 从查询缓存中移除所有查询</p>
</li>
<li><p>FLUSH TABLES 关闭所有打开的表，该操作将同步清空查询缓存中的内容</p>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中使用UUID函数作为主键的问题</title>
    <url>/2018/07/31/MySQL%E4%B8%AD%E4%BD%BF%E7%94%A8UUID%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>对于 InnoDB 这种聚集主键类型的引擎来说，数据会按照主键进行物理排序，这对 auto_increment int 是个好消息，因为后一次插入的主键位置总是在最后。但是对 uuid 来说，这却是个坏消息，因为 uuid 是杂乱无章的，每次插入的主键位置是不确定的，可能在开头，也可能在中间，在进行主键物理排序的时候，势必会造成大量的 IO操作影响效率，因此不适合使用 UUID 做物理主键。比较适合的做法是把uuid作为逻辑主键，物理主键依然使用自增ID。</p>
<h3 id="GUID"><a href="#GUID" class="headerlink" title="GUID"></a>GUID</h3><p>全局唯一标识符，简称GUID（Globally Unique Identifier），是一种由算法生成的唯一标识，通常表示成32个十六进制数字组成的字符串，实质上是一个128位长的二进制整数。</p>
<p>GUID的主要目的是产生完全唯一的数字，在理想情况下，任何计算机和计算机集群都不会生成两个相同的GUID，GUID的总量也足够大，达到了2^128个，所以随机生成两个相同的GUID的可能性是非常小的，但是并不为0；所以，用于生成GUID的算法通常都加入了非随机的参数（如时间），以保证重复的情况不会发生。</p>
<p>GUID已经广泛使用于数据库表格的主键。由于主键需要用作索引，于是就产生了一个性能问题：<strong>当主键足够随机时，新的记录就必须插入到原有的索引中间，而不能仅仅排在最后</strong>。</p>
<p>为缓解这个问题并仍然提供足够的随机程度以避免GUID的重复，人们就创造了一些新的算法来生成序列化的GUID。</p>
<p>2002年8月，吉米尼尔森（Jimmy Nilsson）给出了第一种方法，并称之为“COMB”（combined guid&#x2F;timestamp，意思是：组合GUID&#x2F;时间戳）。他将GUID中数据4的最后6字节用系统时间的最低位替换。经测试，这对随机性的影响很小，但是有一个副作用即是其创建的时间可以从GUID中轻松还原。</p>
<p>自从Microsoft SQL Server 2005版开始，微软在Transact-SQL中加入了一个新函数，叫做NEWSEQUENTIALID()，用来生成主键增大的GUID，<strong>但一旦服务器重新启动，其再次生成的GUID可能反而变小（但仍然保持唯一）</strong>。这在很大程度上提高了索引的性能，但并不能保证所生成的GUID已知增大。这个函数产生的GUID很简单就可以预测，因此不适合用于安全目的。</p>
<p>2006年，一些程序员发现，在一些平台上的Oracle软件中，SYS_GUID函数能返回序列化的GUID。但这个实际上是一个BUG导致的。</p>
<h3 id="全局唯一性ID问题"><a href="#全局唯一性ID问题" class="headerlink" title="全局唯一性ID问题"></a>全局唯一性ID问题</h3><p><a href="https://tech.meituan.com/MT_Leaf.html">https://tech.meituan.com/MT_Leaf.html</a></p>
<p>文中的思路可以借鉴，目前先只使用snowflake来处理</p>
<p><a href="https://www.cnblogs.com/relucent/p/4955340.html">https://www.cnblogs.com/relucent/p/4955340.html</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx入门</title>
    <url>/2018/06/12/Nginx%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="Nginx简介"><a href="#Nginx简介" class="headerlink" title="Nginx简介"></a>Nginx简介</h3><h4 id="常见的Web服务器"><a href="#常见的Web服务器" class="headerlink" title="常见的Web服务器"></a>常见的Web服务器</h4><p>Web服务器也称为WWW服务器、HTTP服务器，其主要功能是提供网上信息浏览服务。</p>
<p>Unix和Linux平台下常用的Web服务器有以下几种：</p>
<ul>
<li>Apache</li>
<li>Nginx</li>
<li>Lighttpd</li>
<li>Tomcat</li>
<li>IBM WebSphere</li>
</ul>
<p>其中应用最广泛的是Apache。</p>
<p>嗯，但是我们这篇文章的主角是Nginx，所以如果有同学想了解Apache的话，可以去自己查询相关资料。</p>
<h4 id="Nginx诞生"><a href="#Nginx诞生" class="headerlink" title="Nginx诞生"></a>Nginx诞生</h4><p>Nginx是俄罗斯人Igor Sysoev编写的一款高性能的HTTP和反向代理服务器，也是一个 IMAP&#x2F;POP3&#x2F;SMTP 代理服务器。于2004年10月4日发布第一个公开版本1.0，开源协议是类BSD许可协议，目前最新版本是1.15.0（2018-06-05发布）</p>
<h4 id="选择理由"><a href="#选择理由" class="headerlink" title="选择理由"></a>选择理由</h4><h5 id="支持高并发链接"><a href="#支持高并发链接" class="headerlink" title="支持高并发链接"></a>支持高并发链接</h5><p>官方测试Nginx能够支持5万并发连接，在实际生产环境中可以支撑2~4万并发连接数。这得益于Nginx使用了最新的epoll（Linux2.6内核）和kqueue（freebsd）网络I&#x2F;O模型.</p>
<h5 id="内存消耗少"><a href="#内存消耗少" class="headerlink" title="内存消耗少"></a>内存消耗少</h5><h5 id="成本低廉"><a href="#成本低廉" class="headerlink" title="成本低廉"></a>成本低廉</h5><p>开源软件，可以免费使用，并且可以用于商业用途</p>
<h5 id="配置文件非常简单"><a href="#配置文件非常简单" class="headerlink" title="配置文件非常简单"></a>配置文件非常简单</h5><h5 id="支持Rewrite重写规则"><a href="#支持Rewrite重写规则" class="headerlink" title="支持Rewrite重写规则"></a>支持Rewrite重写规则</h5><p>能够根据域名、URL的不同，将HTTP请求分到不同的后端服务器群组</p>
<h5 id="内置的健康检查功能"><a href="#内置的健康检查功能" class="headerlink" title="内置的健康检查功能"></a>内置的健康检查功能</h5><p>如果Nginx Proxy后端的某个Web服务器宕机了，不会影响前端访问</p>
<h5 id="节省带宽"><a href="#节省带宽" class="headerlink" title="节省带宽"></a>节省带宽</h5><p>支持GZIP压缩，可以添加浏览器本地缓存的Header头</p>
<h5 id="稳定性高"><a href="#稳定性高" class="headerlink" title="稳定性高"></a>稳定性高</h5><p>用于反向代理，宕机的概率微乎其微</p>
<h5 id="支持热部署"><a href="#支持热部署" class="headerlink" title="支持热部署"></a>支持热部署</h5><p>可以在不间断服务的情况下对软件版本进行升级</p>
<h3 id="Nginx安装配置"><a href="#Nginx安装配置" class="headerlink" title="Nginx安装配置"></a>Nginx安装配置</h3><h4 id="pcre安装"><a href="#pcre安装" class="headerlink" title="pcre安装"></a>pcre安装</h4><p>pcre是一个正则表达式库，让nginx支持rewrite需要安装这个库。</p>
<h5 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h5><p><a href="https://ftp.pcre.org/pub/pcre/">https://ftp.pcre.org/pub/pcre/</a></p>
<h5 id="常用支持库安装"><a href="#常用支持库安装" class="headerlink" title="常用支持库安装"></a>常用支持库安装</h5><p>在CentOS安装软件的时候，可能缺少一部分支持库，而报错。这里首先安装系统常用的支持库。那么在安装的时候就会减少很多的错误的出现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># yum install -y gcc gdb strace gcc-c++ autoconf libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel ncurses ncurses-devel curl curl-devel e2fsprogs patch e2fsprogs-devel krb5-devel libidn libidn-devel openldap-devel nss_ldap openldap-clients openldap-servers libevent-devel libevent uuid-devel uuid mysql-devel</span><br></pre></td></tr></table></figure>

<h5 id="gcc安装"><a href="#gcc安装" class="headerlink" title="gcc安装"></a>gcc安装</h5><p>检查是否安装了g++、gcc。rpm -qa | grep gcc 之后需要出现3个包如下图所示。</p>
<p><img src="https://www.linuxidc.com/upload/2016_08/16081010262925.png"></p>
<p>如果没有出现。需要安装g++、gcc。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># yum install gcc-c++</span><br></pre></td></tr></table></figure>
<h5 id="上传pcre安装包到-x2F-usr-x2F-local-x2F-soft-x2F-pcre下"><a href="#上传pcre安装包到-x2F-usr-x2F-local-x2F-soft-x2F-pcre下" class="headerlink" title="上传pcre安装包到&#x2F;usr&#x2F;local&#x2F;soft&#x2F;pcre下"></a>上传pcre安装包到&#x2F;usr&#x2F;local&#x2F;soft&#x2F;pcre下</h5><h5 id="解压压缩包"><a href="#解压压缩包" class="headerlink" title="解压压缩包"></a>解压压缩包</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cd /usr/local/soft/pcre</span><br><span class="line"># tar -zxvf pcre.tar.gz</span><br></pre></td></tr></table></figure>

<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cd pcre</span><br><span class="line"># ./configure</span><br></pre></td></tr></table></figure>

<h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># make</span><br></pre></td></tr></table></figure>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># make install</span><br></pre></td></tr></table></figure>

<h4 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h4><h5 id="判断系统是否安装了zlib-devel"><a href="#判断系统是否安装了zlib-devel" class="headerlink" title="判断系统是否安装了zlib-devel"></a>判断系统是否安装了zlib-devel</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># rpm -qa | grep zlib-devel</span><br></pre></td></tr></table></figure>

<p>如果未安装，则使用yum进行安装</p>
<h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><p><a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a></p>
<p>下载稳定版本，不要下载最新版本</p>
<h5 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># tar -zxvf nginx-1.14.0.tar.gz</span><br></pre></td></tr></table></figure>

<h5 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h5><p>将软件安装在&#x2F;usr&#x2F;local&#x2F;webserver目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cd nginx-1.14.0</span><br><span class="line"># ./configure --prefix=/usr/local/webserver/nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre=/var/server/soft/pcre </span><br></pre></td></tr></table></figure>

<h5 id="编译和安装"><a href="#编译和安装" class="headerlink" title="编译和安装"></a>编译和安装</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># make</span><br><span class="line"># make install</span><br></pre></td></tr></table></figure>

<h5 id="检查是否安装成功"><a href="#检查是否安装成功" class="headerlink" title="检查是否安装成功"></a>检查是否安装成功</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cd /usr/local/webserver/nginx/sbin</span><br><span class="line"># ./nginx -t</span><br></pre></td></tr></table></figure>

<p>显示以下内容表示安装成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx: the configuration file /usr/local/webserver/nginx/conf/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /usr/local/webserver/nginx/conf/nginx.conf test is successful</span><br></pre></td></tr></table></figure>


















]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx平滑启动</title>
    <url>/2018/06/25/Nginx%E5%B9%B3%E7%BC%93%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p>在使用Nginx的过程中，如果修改了Nginx的配置文件nginx.conf，需要重启Nginx。此时，可以通过发送系统信号给Nginx的<font color="red">主进程</font>的方式来进行重启。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@iZbp15pfzhnlrnbckvwflmZ conf]# ps -ef | grep nginx</span><br><span class="line">root     23013     1  0 10:02 ?        00:00:00 nginx: master process ./nginx -c /usr/local/webserver/nginx/conf/nginx.conf</span><br><span class="line">nobody   23014 23013  0 10:02 ?        00:00:31 nginx: worker process                                </span><br><span class="line">root     25400 25361  0 14:49 pts/3    00:00:00 grep nginx</span><br><span class="line">[root@iZbp15pfzhnlrnbckvwflmZ conf]# kill -HUP 23013</span><br></pre></td></tr></table></figure>

<p>当Nginx接收到HUP信号之后，它会尝试解析指定的配置文件，如果可以使用，就应用新的配置文件，否则使用默认的配置文件。</p>
<p>如果解析成功，Nginx重新打开日志文件或监听的套接字，Nginx运行新的的工作进程，并从容关闭旧的工作进程，通知工作进程监听套接字，但是，继续为当前连接的客户提供服务，所有客户端的服务完成之后，旧的工作进程将关闭。</p>
<p>如果，新的配置文件应用失败，Nginx将继续使用旧的配置进行工作。</p>
<p>可以使用以下指令来检测配置文件是否正确：</p>
<p>切换到nginx的sbin目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ./nginx -t</span><br></pre></td></tr></table></figure>

<p>如果配置文件正确，将显示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx: the configuration file /usr/local/webserver/nginx/conf/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /usr/local/webserver/nginx/conf/nginx.conf test is successful</span><br></pre></td></tr></table></figure>

<p>如果配置文件有问题，将抛出异常，并标识哪一行有问题</p>
<p>Nginx支持的信号如下</p>
<ul>
<li>TERM, INT 快速关闭</li>
<li>QUIT 从容关闭</li>
<li>HUP 平滑重启，重新加载配置文件</li>
<li>USR1 重新打开日志文件，在切割日志时用途较大</li>
<li>USR2 平滑升级可执行程序，用于Nginx程序升级时使用</li>
<li>WINCH 从容关闭工作进程</li>
</ul>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置SSL证书</title>
    <url>/2018/06/22/Nginx%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">server <span class="punctuation">&#123;</span></span><br><span class="line">     listen     <span class="number">443</span>;</span><br><span class="line">     server_name  <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>;</span><br><span class="line"></span><br><span class="line">     ssl on; </span><br><span class="line"></span><br><span class="line">     ssl_certificate   /usr/local/cert/证书名.pem;</span><br><span class="line">     ssl_certificate_key  /usr/local/cert/证书名.key;</span><br><span class="line">     ssl_session_timeout <span class="number">5</span>m;</span><br><span class="line">     ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256<span class="punctuation">:</span>ECDHE<span class="punctuation">:</span>ECDH<span class="punctuation">:</span>AES<span class="punctuation">:</span>HIGH<span class="punctuation">:</span>!NULL<span class="punctuation">:</span>!aNULL<span class="punctuation">:</span>!MD5<span class="punctuation">:</span>!ADH<span class="punctuation">:</span>!RC4;</span><br><span class="line">     ssl_protocols TLSv1 TLSv1<span class="number">.1</span> TLSv1<span class="number">.2</span>;</span><br><span class="line">     ssl_prefer_server_ciphers on;</span><br><span class="line">     ssl_ciphers  HIGH<span class="punctuation">:</span>!aNULL<span class="punctuation">:</span>!MD5;</span><br><span class="line"></span><br><span class="line">     location / <span class="punctuation">&#123;</span></span><br><span class="line">        proxy_pass http<span class="punctuation">:</span><span class="comment">//127.0.0.1:8089;        </span></span><br><span class="line">     <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">     error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /<span class="number">50</span>x.html;</span><br><span class="line">     location = /<span class="number">50</span>x.html <span class="punctuation">&#123;</span></span><br><span class="line">            root   html;</span><br><span class="line">     <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>OpenSSL</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>OpenSSL</tag>
      </tags>
  </entry>
  <entry>
    <title>NoSQL简介</title>
    <url>/2018/03/27/NoSQL%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>泛指非关系型数据库</p>
<p>四大分类</p>
<p>1.键值存储数据库（KV）</p>
<p>Redis、Memecached</p>
<p>2.列存储数据库</p>
<p>通常用来应对分布式存储的海量数据</p>
<p>键仍然存在，但是指向了多个列</p>
<p>HBase、Riak</p>
<p>3.文档型数据库</p>
<p>MongoDB</p>
<p>4.图形数据库</p>
<p>特点：</p>
<p>数据模型比较简单</p>
<p>需要灵活性更强的IT系统</p>
<p>对数据库性能要求较高</p>
<p>不需要高度的数据一致性</p>
<p>对于给定Key，比较容易映射复杂值的环境</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenSSL生成SSL证书之Shell脚本</title>
    <url>/2018/06/23/OpenSSL%E7%94%9F%E6%88%90SSL%E8%AF%81%E4%B9%A6%E4%B9%8BShell%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h3 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">create self-signed server certificate:</span></span><br><span class="line"></span><br><span class="line">read -p &quot;Enter your domain [www.example.com]: &quot; DOMAIN</span><br><span class="line"></span><br><span class="line">echo &quot;Create server key...&quot;</span><br><span class="line"></span><br><span class="line">openssl genrsa -des3 -out $DOMAIN.key 2048</span><br><span class="line"></span><br><span class="line">echo &quot;Create server certificate signing request...&quot;</span><br><span class="line"></span><br><span class="line">SUBJECT=&quot;/C=CN/ST=ZHEJIANG/L=HANGZHOU/O=qinghuazs/OU=qinghuazs/CN=$DOMAIN&quot;</span><br><span class="line"></span><br><span class="line">openssl req -new -subj $SUBJECT -key $DOMAIN.key -out $DOMAIN.csr</span><br><span class="line"></span><br><span class="line">echo &quot;Remove password...&quot;</span><br><span class="line"></span><br><span class="line">mv $DOMAIN.key $DOMAIN.origin.key</span><br><span class="line">openssl rsa -in $DOMAIN.origin.key -out $DOMAIN.key</span><br><span class="line"></span><br><span class="line">echo &quot;Sign SSL certificate...&quot;</span><br><span class="line"></span><br><span class="line">openssl x509 -req -days 36500 -in $DOMAIN.csr -signkey $DOMAIN.key -out $DOMAIN.crt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;TODO:&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;Copy <span class="variable">$DOMAIN</span>.crt to /var/nginx/ssl/<span class="variable">$DOMAIN</span>.crt&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;Copy <span class="variable">$DOMAIN</span>.key to /var/nginx/ssl/<span class="variable">$DOMAIN</span>.key&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;Add configuration in nginx:&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;server &#123;&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;    ...&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;    listen 443 ssl;&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;    ssl_certificate     /etc/nginx/ssl/<span class="variable">$DOMAIN</span>.crt;&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;    ssl_certificate_key /etc/nginx/ssl/<span class="variable">$DOMAIN</span>.key;&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;&#125;&quot;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>DOMAIN需要是服务器IP对应的域名，否则证书不生效</p>
]]></content>
      <categories>
        <category>OpenSSL</category>
      </categories>
      <tags>
        <tag>OpenSSL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL常用命令学习</title>
    <url>/2018/06/21/PostgreSQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>主要是常用的一些系统操作的指令，和DDL和DML语句无关</p>
<span id="more"></span>

<h3 id="进入控制台"><a href="#进入控制台" class="headerlink" title="进入控制台"></a>进入控制台</h3><p>系统的root用户不能执行psql命令，需要su postgres进入bash脚本，再使用psql命令进入数据库</p>
<h3 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a>角色管理</h3><h4 id="创建角色"><a href="#创建角色" class="headerlink" title="创建角色"></a>创建角色</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ROLE name;</span><br></pre></td></tr></table></figure>

<h4 id="查看角色"><a href="#查看角色" class="headerlink" title="查看角色"></a>查看角色</h4><p>角色存在pg_roles系统表中，可以通过查询该表查看数据库中已有的角色</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> rolename <span class="keyword">FROM</span> pg_roles;</span><br></pre></td></tr></table></figure>

<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> sample PASSWORD <span class="string">&#x27;123456&#x27;</span> LOGIN CREATEDB;</span><br></pre></td></tr></table></figure>

<h4 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> wangxinglei PASSWORD <span class="string">&#x27;1234567890&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="对用户授权"><a href="#对用户授权" class="headerlink" title="对用户授权"></a>对用户授权</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> wangxinglei CREATEROLE;</span><br></pre></td></tr></table></figure>

<h3 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h3><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE actuator； </span><br></pre></td></tr></table></figure>

<h4 id="修改数据库的拥有者"><a href="#修改数据库的拥有者" class="headerlink" title="修改数据库的拥有者"></a>修改数据库的拥有者</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE actuator OWNER <span class="keyword">TO</span> wangxinglei;</span><br></pre></td></tr></table></figure>

<h4 id="查询所有的数据库"><a href="#查询所有的数据库" class="headerlink" title="查询所有的数据库"></a>查询所有的数据库</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> datname <span class="keyword">FROM</span> pg_database;</span><br></pre></td></tr></table></figure>

<h3 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h3><h4 id="查询所有的数据库表"><a href="#查询所有的数据库表" class="headerlink" title="查询所有的数据库表"></a>查询所有的数据库表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tablename <span class="keyword">FROM</span> pg_tables;</span><br></pre></td></tr></table></figure>

<h4 id="查询某个数据库下的所有表"><a href="#查询某个数据库下的所有表" class="headerlink" title="查询某个数据库下的所有表"></a>查询某个数据库下的所有表</h4><p>PostgreSQL不支持查询某个数据库下表的操作，但是但是可以列出用户自定义的表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tablename, <span class="operator">*</span> <span class="keyword">FROM</span> pg_tables <span class="keyword">WHERE</span> schemaname <span class="operator">=</span> <span class="string">&#x27;public&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>用户自定义的表，如果未经特殊处理，默认都是放在名为public的schema下</p>
<h4 id="查询表结构"><a href="#查询表结构" class="headerlink" title="查询表结构"></a>查询表结构</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.columns <span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;cpu&#x27;</span>; <span class="comment">-- cpu是表名</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
        <category>postgreSQL</category>
      </categories>
      <tags>
        <tag>postgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL分区</title>
    <url>/2018/07/09/PostgreSQL%E5%88%86%E5%8C%BA/</url>
    <content><![CDATA[<p>分区的具体好处是：</p>
<p>某些类型的查询性能可以得到极大提升</p>
<p>更新的性能也可以得到提升，因为表的每块的索引要比在整个数据集上的索引要小。如果索引不能全部放在内存里，那么在索引上的读和写都会产生更多的磁盘访问</p>
<p>批量删除可以用简单的删除某个分区来实现</p>
<p>可以将很少用的数据移动到便宜的、转速慢的存储介质上</p>
<span id="more"></span>

<p>在PostgreSQL里表分区是通过表继承来实现的，一般都是建立一个主表，里面是空，然后每个分区都去继承它。无论何时，都应保证主表里面是空的。</p>
<p><font color="red">当表本身大小超过了机器物理内存的实际大小时（the size of the table should exceed the physical memory of the database server），可以考虑分区。</font></p>
<p>PostgreSQL目前仅支持范围分区和列表分区，尚未支持散列分区</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="创建主表"><a href="#创建主表" class="headerlink" title="创建主表"></a>创建主表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl_weather_partition(</span><br><span class="line">  id <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">primary</span> key ,</span><br><span class="line">  city_code <span class="type">smallint</span> ,</span><br><span class="line">  created_time <span class="type">timestamp</span>,</span><br><span class="line">  weather <span class="type">char</span>(<span class="number">6</span>),</span><br><span class="line">  temperature <span class="type">smallint</span>,</span><br><span class="line">  wind <span class="type">smallint</span>,</span><br><span class="line">  humidity <span class="type">smallint</span>,</span><br><span class="line">  air_quality <span class="type">smallint</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">comment <span class="keyword">on</span> <span class="keyword">table</span> tbl_weather_partition <span class="keyword">is</span> <span class="string">&#x27;天气表主表&#x27;</span>;</span><br><span class="line"></span><br><span class="line">comment <span class="keyword">on</span> <span class="keyword">column</span> tbl_weather_partition.city_code <span class="keyword">is</span> <span class="string">&#x27;城市编码&#x27;</span>;</span><br><span class="line">comment <span class="keyword">on</span> <span class="keyword">column</span> tbl_weather_partition.created_time <span class="keyword">is</span> <span class="string">&#x27;创建时间&#x27;</span>;</span><br><span class="line">comment <span class="keyword">on</span> <span class="keyword">column</span> tbl_weather_partition.weather <span class="keyword">is</span> <span class="string">&#x27;天气情况&#x27;</span>;</span><br><span class="line">comment <span class="keyword">on</span> <span class="keyword">column</span> tbl_weather_partition.temperature <span class="keyword">is</span> <span class="string">&#x27;温度&#x27;</span>;</span><br><span class="line">comment <span class="keyword">on</span> <span class="keyword">column</span> tbl_weather_partition.wind <span class="keyword">is</span> <span class="string">&#x27;风力&#x27;</span>;</span><br><span class="line">comment <span class="keyword">on</span> <span class="keyword">column</span> tbl_weather_partition.humidity <span class="keyword">is</span> <span class="string">&#x27;湿度&#x27;</span>;</span><br><span class="line">comment <span class="keyword">on</span> <span class="keyword">column</span> tbl_weather_partition.air_quality <span class="keyword">is</span> <span class="string">&#x27;空气质量&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="创建分区表"><a href="#创建分区表" class="headerlink" title="创建分区表"></a>创建分区表</h4><p>暂时只创建两个分区，作为示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl_weather_partition_20180709 (</span><br><span class="line">  <span class="keyword">check</span> (created_time <span class="operator">&gt;=</span> <span class="type">DATE</span> <span class="string">&#x27;2018-07-09&#x27;</span> <span class="keyword">and</span> created_time <span class="operator">&lt;</span> <span class="type">DATE</span> <span class="string">&#x27;2018-07-10&#x27;</span>)</span><br><span class="line">) inherits (tbl_weather_partition);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl_weather_partition_20180710 (</span><br><span class="line">  <span class="keyword">check</span> (created_time <span class="operator">&gt;=</span> <span class="type">DATE</span> <span class="string">&#x27;2018-07-10&#x27;</span> <span class="keyword">and</span> created_time <span class="operator">&lt;</span> <span class="type">DATE</span> <span class="string">&#x27;2018-07-11&#x27;</span>)</span><br><span class="line">) inherits (tbl_weather_partition);</span><br></pre></td></tr></table></figure>

<h4 id="分区键上建立索引"><a href="#分区键上建立索引" class="headerlink" title="分区键上建立索引"></a>分区键上建立索引</h4><p>分区用于查询，所以索引应该建立在分区表上，不能建立在主表上</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index tbl_weather_partition_20180709_created_time_index <span class="keyword">on</span> tbl_weather_partition_20180709 (created_time);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> index tbl_weather_partition_20180709_city_code_index <span class="keyword">on</span> tbl_weather_partition_20180709 (city_code);</span><br></pre></td></tr></table></figure>

<h4 id="创建触发器函数"><a href="#创建触发器函数" class="headerlink" title="创建触发器函数"></a>创建触发器函数</h4><p>对于开发人员来说，希望数据库是透明的，只管 insert into tbl_partition。对于数据插向哪个分区，则希望由DB决定。这点，ORACLE实现了，但是PG不行，需要前期人工处理下。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> tbl_weather_partition_insert_trigger()</span><br><span class="line">  <span class="keyword">RETURNS</span> <span class="keyword">TRIGGER</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  IF ( NEW.created_time <span class="operator">&gt;=</span> <span class="type">DATE</span> <span class="string">&#x27;2018-07-09&#x27;</span> <span class="keyword">AND</span></span><br><span class="line">       NEW.created_time <span class="operator">&lt;</span> <span class="type">DATE</span> <span class="string">&#x27;2018-07-10&#x27;</span> ) <span class="keyword">THEN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_weather_partition_20180709 <span class="keyword">VALUES</span> (NEW.<span class="operator">*</span>);</span><br><span class="line">  ELSIF ( NEW.created_time <span class="operator">&gt;=</span> <span class="type">DATE</span> <span class="string">&#x27;2018-07-10&#x27;</span> <span class="keyword">AND</span></span><br><span class="line">          NEW.created_time <span class="operator">&lt;</span> <span class="type">DATE</span> <span class="string">&#x27;2018-07-11&#x27;</span> ) <span class="keyword">THEN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_weather_partition_20180710 <span class="keyword">VALUES</span> (NEW.<span class="operator">*</span>);</span><br><span class="line">  <span class="keyword">ELSE</span></span><br><span class="line">    RAISE EXCEPTION <span class="string">&#x27;Date out of range. Fix the tbl_weather_partition_insert_trigger() function!&#x27;</span>;</span><br><span class="line">  <span class="keyword">END</span> IF;</span><br><span class="line">  <span class="keyword">RETURN</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$</span><br><span class="line"><span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>

<h4 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h4><p>触发器的作用是当进行插入操作时触发tbl_weather_partition_insert_trigger函数，将数据插入到分区表中</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> insert_tbl_partition_trigger</span><br><span class="line">  before <span class="keyword">insert</span> <span class="keyword">on</span> tbl_weather_partition</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> <span class="keyword">execute</span> <span class="keyword">procedure</span> tbl_weather_partition_insert_trigger();</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在主表中插入一条数据，在分区表中可实时查询到该数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tbl_weather_partition <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;2018-07-09 18:02:00&#x27;</span>, <span class="string">&#x27;多云&#x27;</span>, <span class="number">32</span>, <span class="number">2</span>, <span class="number">80</span>, <span class="number">78</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl_weather_partition_20180709;</span><br></pre></td></tr></table></figure>

<p>更新或删除主表中的数据，则分区表中的数据也会同步更新或删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> tbl_weather_partition <span class="keyword">set</span> temperature <span class="operator">=</span> <span class="number">35</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl_weather_partition_20180709;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis主从配置</title>
    <url>/2018/04/02/Redis%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>Redis支持将数据同步到多个从服务器上</p>
<p>1.Master可以有多个slave</p>
<p>2.多个slave可以练到同一个Master上，也可以连接到其他slave上</p>
<p>3.主从复制不会阻塞Master，Master可以继续处理客户端发来的请求，反而slave在初次同步数据时则会阻塞不能处理客户端的请求</p>
<p>4.主从复制可以提高系统的伸缩性，可以用多个slave专门用于客户端的读请求，也可以做简单的数据冗余</p>
<p>5.可以在Master禁用数据持久化，只在slave上配置数据持久化</p>
<h4 id="主从复制过程"><a href="#主从复制过程" class="headerlink" title="主从复制过程"></a>主从复制过程</h4><p>1.slave与master建立连接，发送sync同步命令</p>
<p>2.master启动一个后台进程，将数据库快照保存在文件中，同时master主进程会开始收集新的写命令并缓存起来</p>
<p>3.后台进程完成写文件后，master就发送文件给slave，slave将文件保存在磁盘上，然后加载到内存恢复数据库快照到slave上</p>
<p>4.接着master就会把缓存命令转发给slave，而且后续master收到的写命令都会通过开始建立的连接发送给slave</p>
<p>注意：</p>
<p>master到slave的同步数据的命令和从客户端发送的命令使用相同的协议格式</p>
<p>当master和slave的连接断开时slave可以自动重新建立连接</p>
<p>如果master同时收到多个slave发来的同步连接命令，只会启动一个进程来写数据库镜像，然后发送给所有slave</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>在配置文件中写入配置即可</p>
<pre><code>slaveof 1.1.1.1 6379      #指定master的IP和端口
</code></pre>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis项目中使用时的配置</title>
    <url>/2018/06/23/Redis%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>基于实际项目的配置，会陆续的进行改进</p>
<span id="more"></span>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Redis configuration file example</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note on units: when memory size is needed, it is possible to specify</span></span><br><span class="line"><span class="comment"># it in the usual form of 1k 5GB 4M and so forth:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1k =&gt; 1000 bytes</span></span><br><span class="line"><span class="comment"># 1kb =&gt; 1024 bytes</span></span><br><span class="line"><span class="comment"># 1m =&gt; 1000000 bytes</span></span><br><span class="line"><span class="comment"># 1mb =&gt; 1024*1024 bytes</span></span><br><span class="line"><span class="comment"># 1g =&gt; 1000000000 bytes</span></span><br><span class="line"><span class="comment"># 1gb =&gt; 1024*1024*1024 bytes</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">################################ GENERAL  #####################################</span></span><br><span class="line"><span class="string">daemonize</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">pidfile</span> <span class="string">/var/run/redis.pid</span></span><br><span class="line"><span class="string">port</span> <span class="number">6379</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">tcp-backlog</span> <span class="number">511</span></span><br><span class="line"></span><br><span class="line"><span class="string">requirepass</span> <span class="string">asdf12331aafjdahj1312jhj131111ghghgh</span></span><br><span class="line"></span><br><span class="line"><span class="string">timeout</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="string">tcp-keepalive</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="string">loglevel</span> <span class="string">notice</span></span><br><span class="line"></span><br><span class="line"><span class="string">logfile</span> <span class="string">&quot;/var/server/redis/redis-3.0.0-rc2/logs/redis.log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">databases</span> <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################ SNAPSHOTTING  ################################</span></span><br><span class="line"></span><br><span class="line"><span class="string">save</span> <span class="number">900</span> <span class="number">1</span></span><br><span class="line"><span class="string">save</span> <span class="number">300</span> <span class="number">10</span></span><br><span class="line"><span class="string">save</span> <span class="number">60</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="string">stop-writes-on-bgsave-error</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="string">rdbcompression</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="string">rdbchecksum</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">dump.rdb</span></span><br><span class="line"></span><br><span class="line"><span class="string">dir</span> <span class="string">/var/server/redis/redis-3.0.0-rc2/etc/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################# REPLICATION #################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">slave-serve-stale-data</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="string">slave-read-only</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="string">repl-diskless-sync</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="string">repl-diskless-sync-delay</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="string">repl-disable-tcp-nodelay</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="string">slave-priority</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################## SECURITY ###################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">################################### LIMITS ####################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">############################## APPEND ONLY MODE ###############################</span></span><br><span class="line"></span><br><span class="line"><span class="string">appendonly</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="string">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">appendfsync</span> <span class="string">everysec</span></span><br><span class="line"></span><br><span class="line"><span class="literal">no</span><span class="string">-appendfsync-on-rewrite</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="string">auto-aof-rewrite-percentage</span> <span class="number">100</span></span><br><span class="line"><span class="string">auto-aof-rewrite-min-size</span> <span class="string">64mb</span></span><br><span class="line"></span><br><span class="line"><span class="string">aof-load-truncated</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################ LUA SCRIPTING  ###############################</span></span><br><span class="line"></span><br><span class="line"><span class="string">lua-time-limit</span> <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################ REDIS CLUSTER  ###############################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">################################## SLOW LOG ###################################</span></span><br><span class="line"></span><br><span class="line"><span class="string">slowlog-log-slower-than</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="string">slowlog-max-len</span> <span class="number">128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################ LATENCY MONITOR ##############################</span></span><br><span class="line"></span><br><span class="line"><span class="string">latency-monitor-threshold</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################# Event notification ##############################</span></span><br><span class="line"></span><br><span class="line"><span class="string">notify-keyspace-events</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################### ADVANCED CONFIG ###############################</span></span><br><span class="line"></span><br><span class="line"><span class="string">hash-max-ziplist-entries</span> <span class="number">512</span></span><br><span class="line"><span class="string">hash-max-ziplist-value</span> <span class="number">64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">list-max-ziplist-entries</span> <span class="number">512</span></span><br><span class="line"><span class="string">list-max-ziplist-value</span> <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="string">set-max-intset-entries</span> <span class="number">512</span></span><br><span class="line"></span><br><span class="line"><span class="string">zset-max-ziplist-entries</span> <span class="number">128</span></span><br><span class="line"><span class="string">zset-max-ziplist-value</span> <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="string">hll-sparse-max-bytes</span> <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="string">activerehashing</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="string">client-output-buffer-limit</span> <span class="string">normal</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="string">client-output-buffer-limit</span> <span class="string">slave</span> <span class="string">256mb</span> <span class="string">64mb</span> <span class="number">60</span></span><br><span class="line"><span class="string">client-output-buffer-limit</span> <span class="string">pubsub</span> <span class="string">32mb</span> <span class="string">8mb</span> <span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="string">hz</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="string">aof-rewrite-incremental-fsync</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础类型</title>
    <url>/2018/03/30/Redis%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h4 id="String-字符串类型"><a href="#String-字符串类型" class="headerlink" title="String 字符串类型"></a>String 字符串类型</h4><p>二进制安全，可以包含任何数据，比如jpg图片或者序列化的对象；从内部实现看，string其实可以看做byte数组，最大上限是1G字节</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><pre><code>set name qinghuazangshui --赋值 set key value

get name --获取内容 get key

setnx (not exist)

setnx name qinghua  --存在则修改，不存在则赋值  setnx key value

setex (expired)

setex name 10 qinghua2 --设置过期时间

setrange name 2 qaq --从第二位开始替换，替换成qaq

mset key1 value1 key2 value2 --设置多个键值

mget key1 key2 key3 --一次性取多个值

getset name qinghua3 --返回旧值，返回新值 getset key value

incr age  --递增操作，数字类型 incr key,相当于++操作，如果value不是int类型的会返回错误，incr一个不存在的key，则设置key的值为1

decr age --递减操作，数字类型 decr key， 相当于--操作，decr一个不存在的key，则设置key的值为-1

incrby/decrby age 3 --增加/减少指定的值 incrby/decrby key integer 

append name 123 --追加
</code></pre>
<h4 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h4><p>Hash类型是String类型key和value的映射表，或者说是一个String集合</p>
<p>添加、删除操作都是O(1)(平均)</p>
<p>适合存储对象</p>
<p>相对而言，将一个对象类型存储在Hash类型里要比存储在String类型里占用更少的内存空间，并方便存取整个对象；省内存的原因是新建一个hash对象时开始使用zipmap来存储的。</p>
<p>如果field或者value的大小超出一定限制后，redis会在内部自动将zipmap替换成正常的hash实现，可以在配置文件中设置最大值</p>
<pre><code>hash-max-zipmap-entries 64 #配置字段最多64个

hash-max-zipmap-value 512 #配置value最大为512字节
</code></pre>
<h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><pre><code>hset user id 1 --设置属性和值 hset key field value

hset user name qinghua

hset user age 18

hget user id --取值 hget key field

hget user name 

hmset user id  2 name qinghua2 age 20 --批量设置键值 hmset key field1 value1 field2 value2...

hmget user id name age --批量取值 hmget key field1 field2...

hexists user age --是否存在键值 hexists key field 

hlen user --user的长度 hlen key 返回指定hash的field的数量 

hkeys user --获取user的所有键  返回hash的所有field

hvals user --获取user下的所有值 hvals key

hgetall user --返回hash的所有的键值 hgetall key 

hdel key field --删除指定的hash field

hincrby key field integer --将制定hash field加上指定值
</code></pre>
<h4 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h4><p>链表结构（双向链表）的集合，即可以理解为一个每个子元素都是string类型的双向链表</p>
<p>主要功能有push、pop、获取元素等，可以在头部或尾部增删元素，操作中key理解为链表的名字</p>
<p>既可以作为栈，也可以作为队列</p>
<pre><code>lpush list qinghua  --从头部添加元素，返回1表示成功，0表示key存在且不是list类型 lpush key string

rpush list zangshui --在尾部添加元素 rpush key string

linsert list before zangshui qaq --插入

lrange list 0 -1 --遍历List，-1代表最后的索引位置  lrange key start end 返回指定区间内的元素，下标从0开始，复制表示从后面计算，-1表示倒数第一个元素，key不存在返回空列表

lset key index value--将制定下表的元素替换掉，成功返回1

lrem list 1 qinghua --删除元素，返回删除的元素个数 lrem key count value 从list的头部（正数）或尾部（负数）删除一定数量匹配value的元素，返回删除的元素数量，count为0时删除全部

ltrim key start end--保留指定key的值范围内的数据，截取 list指定区间内元素，成功返回 1，key不存在返回错误

lpop key--从头部删除元素，并返回删除元素

rpop key--从尾部删除元素，并返回删除元素

rpoplpush --从尾部删除元素，然后从头部插入元素

lindex --返回名称为key的list中index位置的元素

llen key--返回元素的个数,即返回key对应的list的长度，如果key不存在返回0，如果key对应类型不是list返回错误    
</code></pre>
<h4 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h4><p>string类型的无序集合，通过hashtable实现，实现集合的交集、并集、差集操作，查找的复杂度为O(1)，hashtable会随着添加或者删除自动的调整大小，需要注意的是调整hash table大小的时候需要同步（获取写锁），会阻塞其他读写操作。</p>
<p>最大可以包含2^32-1个元素</p>
<p>set中不允许重复</p>
<pre><code>sadd set1 aaa --添加元素 sadd key member 成功返回1,如果元素以及在集合中则返回0，key对应的set不存在则返回错误

srem key member --从key对应set中移除指定元素，成功返回1，如果member在集合中不存在或者key不存在返回0，如果key对应的不是set类型的值返回错误

spop key --删除并返回key对应set中随机的一个元素，如果set是空或者key不存在返回nil

srandmember key -- 同spop，随机取set中的一个元素，但是不删除元素

smove srckey destkey member --从srckey对应set中移除member并添加到destkey对应set中，整个操作是原子的。成功返回1，如果member在srckey中不存在返回0，如果key不是set类型返回错误

scard key --返回set中元素的个数，如果set是空或者key不存在返回0

smembers key --返回key对应set的所有元素，结果是无序的

sinter key1 key2 --返回所有给定key的交集

sinterstore destkey key1 key2 --取交集结果，并存储到指定集合destkey中

sunion key1 key2 --取并集

sunionstore destkey key1 key2 --取并集结果，并存储到指定集合destkey中

sdiff key1 key2 --返回所有给定key的差集

sdiffstore destkey key1 key2 --取差集结果，并存储到指定集合destkey中

sismember key member --判断member是否在set中，存在返回1,0表示不存在或者key不存在
</code></pre>
<h4 id="zset-有序集合"><a href="#zset-有序集合" class="headerlink" title="zset 有序集合"></a>zset 有序集合</h4><p>可以做搜索排行</p>
<pre><code>zadd key score member--向有序集合中添加一个元素，元素在集合中存在则更新对应score

zrem key member --删除指定元素，1表示成功，如果元素不存在返回0

zincrby key incr member --增加对应member的score值，然后移动元素并保持skip list保持有序。返回更新后的score值

zrank key member --返回指定元素在级合格中的排名（下标），集合中元素是按score从小到大排序的

zrevrank key member --同上，但是结合中元素是按score从大到小排序

zrange key start end --类似lrange操作从集合中去指定区间的元素，返回的是有序结果

zrevrange key start end --同上，返回结果是按score逆序的

zrangebyscore key min max --返回集合中score在给定区间的数量

zcount key min max --返回集合中score在给定区间的数量

zcard key --返回集合中元素个数

zscore key element --返回给定元素对应的score      

zremrangebyrank  key min max --删除集合中排名在给定区间的元素

zremrangebyscore key min max --删除集合中score在给定区间的元素
</code></pre>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下Redis安装</title>
    <url>/2018/03/28/Redis%E5%AE%89%E8%A3%85-Linux%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<ol>
<li><p>首先需要安装gcc，把下载好的redis-3.0.0-rc2.tar.gz放到linux的&#x2F;usr&#x2F;local文件夹</p>
</li>
<li><p>进行解压 </p>
<pre><code> # tar -zxvf redis-3.0.0-rc2.tar.gz
</code></pre>
</li>
<li><p>进入到redis-3.0.0目录下，进行编译 </p>
<pre><code> # cd redis-3.0.0-rc2

 # make
</code></pre>
<p> 验证(ll查看src下的目录，有redis-server 、redis-cil即可)</p>
</li>
<li><p>建立俩个文件夹存放redis命令和配置文件</p>
<pre><code>    # mkdir -p /usr/local/redis/etc

    # mkdir -p /usr/local/redis/bin
</code></pre>
</li>
<li><p>把redis-3.0.0下的redis.conf 移动到&#x2F;usr&#x2F;local&#x2F;redis&#x2F;etc下，</p>
<pre><code>    # cp redis.conf /usr/local/redis/etc/
</code></pre>
</li>
<li><p>把redis-3.0.0&#x2F;src里的mkreleasehdr.sh、redis-benchmark、redis-check-aof、redis-check-dump、redis-cli、redis-server文件移动到bin下</p>
<pre><code>    # mv mkreleasehdr.sh redis-benchmark redis-check-aof redis-check-dump redis-cli redis-server /usr/local/redis/bin
</code></pre>
<p> redis-server： Redis服务器的daemon启动程序</p>
<p> redis-cli： Redis命令行操作工具</p>
<p> redis-benchmark： Redis的性能测试工具，测试Redis在你的系统及你的配置下的读写性能</p>
<pre><code> # redis-benchmark -n 100000 -c 50 --模拟同时由50个客户端发送100000个SETs/GETs查询
</code></pre>
<p> redi-check-aof：更新日志检查</p>
<p> redis-check-dump：本地数据库检查</p>
</li>
<li><p>启动时并指定配置文件：</p>
<pre><code>    # cd /usr/local/redis/bin

    # ./redis-server /usr/local/redis/etc/redis.conf
</code></pre>
<p> 注意要使用后台启动，所以修改redis.conf里的 daemonize 改为yes</p>
</li>
<li><p>验证启动是否成功：</p>
<pre><code>    # ps -ef | grep redis 
</code></pre>
<p> 查看是否有redis服务 </p>
<p> 或者 </p>
<p> 查看端口：</p>
<pre><code> # netstat -tunpl | grep 6379
</code></pre>
</li>
<li><p>进入redis客户端 </p>
<pre><code> # ./redis-cli 
</code></pre>
<p> 退出客户端</p>
<pre><code> # quit
</code></pre>
</li>
<li><p>退出redis服务</p>
<p>（1）pkill redis-server</p>
<p>（2）kill 进程号      </p>
<p>（3）&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-cli shutdown </p>
<p>（4） 关闭指定端口的redis服务</p>
<pre><code># redis-cli -p 6379 shutdown
</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis安全配置</title>
    <url>/2018/04/01/Redis%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>1.设置Redis密码</p>
<p>修改redid.conf文件</p>
<pre><code>#requirepass foobared
requirepass yourpassword
</code></pre>
<p>重启Redis服务</p>
<p>2.设置防火墙，关闭Redis的6379端口的对外访问</p>
<p>一般不建议设置密码，只需要关闭端口的对外访问即可</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis虚拟内存</title>
    <url>/2018/04/03/Redis%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<p>Redis的虚拟内存和操作系统的虚拟内存不是一码事，但是思路和目的都是相同的：</p>
<p>就是暂时把不常访问的数据从内存交换到磁盘中，从而腾出宝贵的内存空间</p>
<p>Redis在用户态实现了自己的虚拟内存机制</p>
<p>主要的理由有以下两点：</p>
<ol>
<li><p>操作系统的虚拟内存是以4k&#x2F;页为最小单位进行交换的。而Redis 的大多数对象都远小于4k，所以一个操作系统页上可能有多个Redis对象。另外Redis的集合对象类型如list,set可能存在于多个操作系统页上，最终可能造成只有10%的key 被经常访问，但是所有操作系统页都会被操作系统认为是活跃的，这样只有内存真正耗尽时操作系统才会进行页的交换。</p>
</li>
<li><p>相比操作系统的交换方式，Redis 可以将被交换到磁盘的对象进行压缩,保存到磁盘的对象可以去除指针和对象元数据信息。一般压缩后的对象会比内存中的对象小10 倍。这样Redis 的虚拟内存会比操作系统的虚拟内存少做很多IO 操作。</p>
</li>
</ol>
<h4 id="虚拟内存配置"><a href="#虚拟内存配置" class="headerlink" title="虚拟内存配置"></a>虚拟内存配置</h4><pre><code>#开启虚拟内存的功能
vm-enabled yes

#交换出来value保存的文件路径/tmp/redis.swap
vm-swap-file /tmp/redis.swap

#redis使用的最大内存上限，超出上限后redis开始狡猾value到磁盘swap文件中，建议设置为系统空闲内存的60%~80%
vm-max-memory 268435456

#每个Redis页的大小 字节
vm-page-size 32

#最多在文件中使用多少个页，交换文件的大小 = (vm-page-size * vm-pages)
vm-pages 1334217728

#用于执行value对象换入换出的工作线程数量，0表示不使用工作线程
vm-max-threads 8
</code></pre>
<p>Redis的虚拟内存在设计上为了保证key 的查询速度，只会将value 交换到swap 文件中。如果是由于太多key很小的value造成的内存问题，那么redis 的虚拟内存并不能解决问题。和操作系统一样redis 也是按页来交换对象的。redis 规定同一个页只能保存一个对象。但是一个对象可以保存在多个页中。在redis 使用的内存没超过vm-max-memory 之前是不会交换任何value 的。当超过最大内存限制后，redis 会选择把较老的对象交换到swap文件中去。如果两个对象一样老会优先交换比较大的对象， 精确的交换计算公式swappability &#x3D; age*log(size_in_memory)。对于vm-page-size 的设置应该根据自己应用将页的大小设置为可以容纳大多数对象的尺寸。太大了会浪费磁盘空间，太小了会造成交换文件出现过多碎片。对于交换文件中的每个页，redis 会在内存中用一个1bit 值来对应记录页的空闲状态。所以像上面配置中页数量(vm-pages 134217728 )会占用16MB 内存用来记录页的空闲状态。vm-max-threads 表示用做交换任务的工作线程数量。如果大于0 推荐设为服务器的cpu 的核心数。如果是0 则交换过程在主线程进行。</p>
<h4 id="Redis虚拟内存工作方式简介"><a href="#Redis虚拟内存工作方式简介" class="headerlink" title="Redis虚拟内存工作方式简介"></a>Redis虚拟内存工作方式简介</h4><h5 id="当vm-max-threads设置为0时（阻塞方式）"><a href="#当vm-max-threads设置为0时（阻塞方式）" class="headerlink" title="当vm-max-threads设置为0时（阻塞方式）"></a>当vm-max-threads设置为0时（阻塞方式）</h5><h6 id="换出"><a href="#换出" class="headerlink" title="换出"></a>换出</h6><p>主线程定期检查发现内存超出最大上限后，会直接以阻塞的方式，将选中的对象保存到swap文件中，并释放对象占用的内存空间，此过程会一直重复直到下面条件满足：</p>
<p>1.内存使用降到最大限制以下</p>
<p>2.swap文件满了</p>
<p>3.几乎全部的对象都被交换到磁盘</p>
<h6 id="换入"><a href="#换入" class="headerlink" title="换入"></a>换入</h6><p>当有客户端请求已经被换出的value时，主线程会以阻塞的方式从swap文件中加载对应的value对象，加载时会阻塞所有客户端，然后处理该客户端的请求</p>
<h5 id="当vm-max-threads设置为大于0时（工作线程方式）"><a href="#当vm-max-threads设置为大于0时（工作线程方式）" class="headerlink" title="当vm-max-threads设置为大于0时（工作线程方式）"></a>当vm-max-threads设置为大于0时（工作线程方式）</h5><h6 id="换出-1"><a href="#换出-1" class="headerlink" title="换出"></a>换出</h6><p>当主线程检测到使用内存超过最大上限，会将选中要交换的对象信息放到一个队列中交给工作线程后台处理，主线程会继续处理客户端请求</p>
<h6 id="换入-1"><a href="#换入-1" class="headerlink" title="换入"></a>换入</h6><p>如果有客户端请求的key已经被换出了，主线程会先阻塞发出命令的客户端，然后将加载对象的信息放到一个队列中，让工作线程去加载。加载完毕后工作线程通知主线程，主线程再执行客户端的命令，这种方式值阻塞请求的value是已经被换出key的客户端</p>
<p>总的来说，阻塞方式的性能更好一点，因为不需要线程同步、创建线程和恢复被阻塞的客户端等开销，但是也相应的牺牲了响应性</p>
<p>工作线程方式主线程不会阻塞在磁盘IO上，所以响应性更好</p>
<p>如果应用不太经常发生换入换出，而且也不太在意有点延迟的话，推荐使用阻塞方式</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis配置文件</title>
    <url>/2018/03/29/Redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>该篇主要是针对Redis的配置文件中各项配置的一个简单说明，为后期Redis的应用提供一个参考</p>
<span id="more"></span>

<pre><code># daemonize no 默认情况下，redis不是在后台运行的，如果需要在后台运行，把该项的值更改为yes
daemonize yes

# 当redis在后台运行的时候，Redis默认会把pid文件放在/var/run/redis.pid，你可以配置到其他地址。
# 当运行多个redis服务时，需要指定不同的pid文件和端口
pidfile /var/run/redis.pid

# 指定redis运行的端口，默认是6379
port 6379

# 指定redis只接收来自于该IP地址的请求，如果不进行设置，那么将处理所有请求，
# 在生产环境中最好设置该项，如果Redis单独部署在一台服务器上，则需要放开限制
bind 127.0.0.1

# 设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，那么关闭该连接
# 0是关闭此设置
timeout 0

# 指定日志记录级别
# Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose
# debug  记录很多信息，用于开发和测试
# varbose 有用的信息，不像debug会记录那么多
# notice 普通的verbose，常用于生产环境
# warning 只有非常重要或者严重的信息会记录到日志
loglevel debug

# 配置log文件地址
# 默认值为stdout，标准输出，若后台模式会输出到/dev/null
#logfile stdout
logfile /var/log/redis/redis.log

# 可用数据库数
# 默认值为16，默认数据库为0，数据库范围在0-（database-1）之间
databases 16

################################ 快照  #################################
#
# 保存数据到磁盘，格式如下:
#
#   save &lt;seconds&gt; &lt;changes&gt;
#
#   指出在多长时间内，有多少次更新操作，就将数据同步到数据文件rdb。
#   相当于条件触发抓取快照，这个可以多个条件配合
#   
#   比如默认配置文件中的设置，就设置了三个条件
#
#   save 900 1  900秒内至少有1个key被改变
#   save 300 10  300秒内至少有300个key被改变
#   save 60 10000  60秒内至少有10000个key被改变

save 900 1
save 300 10
save 60 10000

# 存储至本地数据库时（持久化到rdb文件）是否压缩数据，默认为yes
rdbcompression yes

# 本地持久化数据库文件名，默认值为dump.rdb
dbfilename dump.rdb

# 工作目录
#
# 数据库镜像备份的文件放置的路径。
# 这里的路径跟文件名要分开配置是因为redis在进行备份时，先会将当前数据库的状态写入到一个临时文件中，等备份完成时，
# 再把该该临时文件替换为上面所指定的文件，而这里的临时文件和上面所配置的备份文件都会放在这个指定的路径当中。
#
# AOF文件也会存放在这个目录下面
#
# 注意这里必须制定一个目录而不是文件  最好是设置为/usr/local/redis/data/
dir ./

################################# 复制 #################################

# 主从复制. 设置该数据库为其他数据库的从数据库.
# 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步
#
# slaveof &lt;masterip&gt; &lt;masterport&gt;

# 当master服务设置了密码保护时(用requirepass制定的密码)
# slav服务连接master的密码
#
# masterauth &lt;master-password&gt;


# 当从库同主机失去连接或者复制正在进行，从机库有两种运行方式：
#
# 1) 如果slave-serve-stale-data设置为yes(默认设置)，从库会继续相应客户端的请求
#
# 2) 如果slave-serve-stale-data是指为no，出去INFO和SLAVOF命令之外的任何请求都会返回一个错误&quot;SYNC with master in progress&quot;
#
slave-serve-stale-data yes

# 从库会按照一个时间间隔向主库发送PINGs.可以通过repl-ping-slave-period设置这个时间间隔，默认是10秒
#
#
repl-ping-slave-period 10

# repl-timeout 设置主库批量数据传输时间或者ping回复时间间隔，默认值是60秒
# 一定要确保repl-timeout大于repl-ping-slave-period
# repl-timeout 60

################################## 安全 ###################################

# 设置客户端连接后进行任何其他指定前需要使用的密码。
# 警告：因为redis速度相当快，所以在一台比较好的服务器下，一个外部的用户可以在一秒钟进行150K次的密码尝试，这意味着你需要指定非常非常强大的密码来防止暴力破解
#
#
requirepass foobared

# 命令重命名.
#
# 在一个共享环境下可以重命名相对危险的命令。比如把CONFIG重名为一个不容易猜测的字符。
#
# 举例:
# 
# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
#
# 如果想删除一个命令，直接把它重命名为一个空字符&quot;&quot;即可，如下：
#
# rename-command CONFIG &quot;&quot;

################################### 约束 ####################################

# 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数
# 如果设置 maxclients 0，表示不作限制，当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息
#
# maxclients 128

# 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key
# Redis同时也会移除空的list对象
#
# 当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作
#
# 注意：Redis新的vm机制，会把Key存放内存，Value会存放在swap区
#
# maxmemory的设置比较适合于把redis当作于类似memcached的缓存来使用，而不适合当做一个真实的DB。
# 当把Redis当做一个真实的数据库使用的时候，内存使用将是一个很大的开销
# maxmemory &lt;bytes&gt;

# 当内存达到最大值的时候Redis会选择删除哪些数据？有五种方式可供选择
#
# volatile-lru -&gt; 利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used )
# allkeys-lru -&gt; 利用LRU算法移除任何key
# volatile-random -&gt; 移除设置过过期时间的随机key
# allkeys-&gt;random -&gt; remove a random key, any key
# volatile-ttl -&gt; 移除即将过期的key(minor TTL)
# noeviction -&gt; 不移除任何可以，只是返回一个写错误
#
# 注意：对于上面的策略，如果没有合适的key可以移除，当写的时候Redis会返回一个错误
#    
#       写命令包括: set setnx setex append
#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd
#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby
#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby
#       getset mset msetnx exec sort
#
# 默认是:
#
# maxmemory-policy volatile-lru

# LRU 和 minimal TTL 算法都不是精准的算法，但是相对精确的算法(为了节省内存)，随意你可以选择样本大小进行检测。
# Redis默认的灰选择3个样本进行检测，你可以通过maxmemory-samples进行设置
#
# maxmemory-samples 3

############################## AOF ###############################

# 默认情况下，redis会在后台异步的把数据库镜像备份到磁盘，但是该备份是非常耗时的，而且备份也不能很频繁，如果发生诸如拉闸限电、拔插头等状况，那么将造成比较大范围的数据丢失。
# 所以redis提供了另外一种更加高效的数据库备份及灾难恢复方式。
# 开启appendonly模式之后，redis会把所接收到的每一次写操作请求都追加到appendonly.aof文件中，当redis重新启动时，会从该文件恢复出之前的状态。
# 但是这样会造成appendonly.aof文件过大，所以redis还支持了BGREWRITEAOF指令，对appendonly.aof 进行重新整理。
# 你可以同时开启asynchronous dumps 和 AOF

appendonly no

# AOF文件名称 (默认: &quot;appendonly.aof&quot;)
# appendfilename appendonly.aof

# Redis支持三种同步AOF文件的策略:
#
# no: 不进行同步，系统去操作 . Faster.
# always:always表示每次有写操作都进行同步. Slow, Safest.
# everysec: 表示对写操作进行累积，每秒同步一次.
#
# 默认是&quot;everysec&quot;，按照速度和安全折中这是最好的。
# 如果想让Redis能更高效的运行，你也可以设置为&quot;no&quot;，让操作系统决定什么时候去执行
# 或者相反想让数据更安全你也可以设置为&quot;always&quot;
#
# 如果不确定就用 &quot;everysec&quot;.

# appendfsync always
appendfsync everysec
# appendfsync no

# AOF策略设置为always或者everysec时，后台处理进程(后台保存或者AOF日志重写)会执行大量的I/O操作
# 在某些Linux配置中会阻止过长的fsync()请求。注意现在没有任何修复，即使fsync在另外一个线程进行处理
#
# 为了减缓这个问题，可以设置下面这个参数no-appendfsync-on-rewrite
#
# This means that while another child is saving the durability of Redis is
# the same as &quot;appendfsync none&quot;, that in pratical terms means that it is
# possible to lost up to 30 seconds of log in the worst scenario (with the
# default Linux settings).
#
# If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as
# &quot;no&quot; that is the safest pick from the point of view of durability.
no-appendfsync-on-rewrite no

# Automatic rewrite of the append only file.
# AOF 自动重写
# 当AOF文件增长到一定大小的时候Redis能够调用 BGREWRITEAOF 对日志文件进行重写
#
# 它是这样工作的：Redis会记住上次进行些日志后文件的大小(如果从开机以来还没进行过重写，那日子大小在开机的时候确定)
#
# 基础大小会同现在的大小进行比较。如果现在的大小比基础大小大制定的百分比，重写功能将启动
# 同时需要指定一个最小大小用于AOF重写，这个用于阻止即使文件很小但是增长幅度很大也去重写AOF文件的情况
# 设置 percentage为0就关闭这个特性

auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

################################## SLOW LOG ###################################

# Redis Slow Log 记录超过特定执行时间的命令。执行时间不包括I/O计算比如连接客户端，返回结果等，只是命令执行时间
#
# 可以通过两个参数设置slow log：一个是告诉Redis执行超过多少时间被记录的参数slowlog-log-slower-than(微妙)，
# 另一个是slow log 的长度。当一个新命令被记录的时候最早的命令将被从队列中移除

# 下面的时间以微妙微单位，因此1000000代表一分钟。
# 注意制定一个负数将关闭慢日志，而设置为0将强制每个命令都会记录
slowlog-log-slower-than 10000

# 对日志长度没有限制，只是要注意它会消耗内存
# 可以通过 SLOWLOG RESET 回收被慢日志消耗的内存
slowlog-max-len 1024

############################### ADVANCED CONFIG ###############################

# 当hash中包含超过指定元素个数并且最大的元素没有超过临界时，
# hash将以一种特殊的编码方式（大大减少内存使用）来存储，这里可以设置这两个临界值
# Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，
# 这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap,
#当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。
hash-max-zipmap-entries 512
hash-max-zipmap-value 64

# list数据类型多少节点以下会采用去指针的紧凑存储格式。
# list数据类型节点值大小小于多少字节会采用紧凑存储格式。
list-max-ziplist-entries 512
list-max-ziplist-value 64

# set数据类型内部数据如果全部是数值型，且包含多少节点以下会采用紧凑格式存储。
set-max-intset-entries 512

# zsort数据类型多少节点以下会采用去指针的紧凑存储格式。
# zsort数据类型节点值大小小于多少字节会采用紧凑存储格式。
zset-max-ziplist-entries 128
zset-max-ziplist-value 64

# Redis将在每100毫秒时使用1毫秒的CPU时间来对redis的hash表进行重新hash，可以降低内存的使用
#
# 当你的使用场景中，有非常严格的实时性需要，不能够接受Redis时不时的对请求有2毫秒的延迟的话，把这项配置为no。
#
# 如果没有这么严格的实时性要求，可以设置为yes，以便能够尽可能快的释放内存
activerehashing yes

################################## INCLUDES ###################################

# 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件
# include /path/to/local.conf
# include /path/to/other.conf
</code></pre>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis简介</title>
    <url>/2018/03/27/Redis%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>K-V形式存储</p>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>对数据高并发读写</p>
<p>对海量数据的高效率存储和访问</p>
<p>对数据的可扩展性和高可用性</p>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>ACID处理非常简单</p>
<p>无法做到太复杂的关系数据模型</p>
<h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><ul>
<li><p>string 字符串</p>
</li>
<li><p>哈希</p>
</li>
<li><p>list 链表</p>
</li>
<li><p>set 集合</p>
</li>
<li><p>zset 有序集合</p>
</li>
</ul>
<h5 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h5><p>RDB</p>
<p>AOF</p>
<h5 id="集群策略"><a href="#集群策略" class="headerlink" title="集群策略"></a>集群策略</h5><ol>
<li><p>主从形式</p>
</li>
<li><p>哨兵形式</p>
</li>
<li><p>3.0之后的集群模式</p>
</li>
</ol>
<h5 id="主从形式"><a href="#主从形式" class="headerlink" title="主从形式"></a>主从形式</h5><p>主节点写，从节点读</p>
<h5 id="哨兵形式"><a href="#哨兵形式" class="headerlink" title="哨兵形式"></a>哨兵形式</h5><p>哨兵节点去监控主从节点的状态，主节点挂掉之后，哨兵会在从节点之间选取一个节点，提升为主节点；如果主节点重新加入，则变成从节点</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis高级命令</title>
    <url>/2018/03/31/Redis%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h4 id="关于key的操作"><a href="#关于key的操作" class="headerlink" title="关于key的操作"></a>关于key的操作</h4><p>Redis的key是字符串类型的，不可以包含空格和换行字符</p>
<h5 id="获取所有的键"><a href="#获取所有的键" class="headerlink" title="获取所有的键"></a>获取所有的键</h5><pre><code>keys *
</code></pre>
<h5 id="查看数据库的key的数量"><a href="#查看数据库的key的数量" class="headerlink" title="查看数据库的key的数量"></a>查看数据库的key的数量</h5><pre><code>dbsize
</code></pre>
<h5 id="检测某个key是否存在，返回1表示存在，0表示不存在"><a href="#检测某个key是否存在，返回1表示存在，0表示不存在" class="headerlink" title="检测某个key是否存在，返回1表示存在，0表示不存在"></a>检测某个key是否存在，返回1表示存在，0表示不存在</h5><pre><code>exits key 
</code></pre>
<h5 id="删除给定的key，返回删除key的数目，如果返回0，则表示给定的key不存在"><a href="#删除给定的key，返回删除key的数目，如果返回0，则表示给定的key不存在" class="headerlink" title="删除给定的key，返回删除key的数目，如果返回0，则表示给定的key不存在"></a>删除给定的key，返回删除key的数目，如果返回0，则表示给定的key不存在</h5><pre><code>del key1, key2, ... 
</code></pre>
<h5 id="返回给定key值的类型，返回none表示key不存在"><a href="#返回给定key值的类型，返回none表示key不存在" class="headerlink" title="返回给定key值的类型，返回none表示key不存在"></a>返回给定key值的类型，返回none表示key不存在</h5><pre><code>type key 
</code></pre>
<h5 id="重命名一个key，如果newkey存在，将会被覆盖；返回1表示成功，返回0表示失败，可能是oldkey不存在或者和newkey相同"><a href="#重命名一个key，如果newkey存在，将会被覆盖；返回1表示成功，返回0表示失败，可能是oldkey不存在或者和newkey相同" class="headerlink" title="重命名一个key，如果newkey存在，将会被覆盖；返回1表示成功，返回0表示失败，可能是oldkey不存在或者和newkey相同"></a>重命名一个key，如果newkey存在，将会被覆盖；返回1表示成功，返回0表示失败，可能是oldkey不存在或者和newkey相同</h5><pre><code>rename oldkey newkey 
</code></pre>
<h5 id="重命名一个key-和rename类似，但是如果newkey存在会返回失败"><a href="#重命名一个key-和rename类似，但是如果newkey存在会返回失败" class="headerlink" title="重命名一个key,和rename类似，但是如果newkey存在会返回失败"></a>重命名一个key,和rename类似，但是如果newkey存在会返回失败</h5><pre><code>renamenx oldkey newkey
</code></pre>
<h5 id="为key指定过期时间，单位是秒；返回1成功，0表示key已经设置过过期时间或者key不存在"><a href="#为key指定过期时间，单位是秒；返回1成功，0表示key已经设置过过期时间或者key不存在" class="headerlink" title="为key指定过期时间，单位是秒；返回1成功，0表示key已经设置过过期时间或者key不存在"></a>为key指定过期时间，单位是秒；返回1成功，0表示key已经设置过过期时间或者key不存在</h5><pre><code>expire key seconds 
</code></pre>
<h5 id="返回设置了过期时间的key的剩余过期秒数，-1表示key不存在或者未设置过期时间"><a href="#返回设置了过期时间的key的剩余过期秒数，-1表示key不存在或者未设置过期时间" class="headerlink" title="返回设置了过期时间的key的剩余过期秒数，-1表示key不存在或者未设置过期时间"></a>返回设置了过期时间的key的剩余过期秒数，-1表示key不存在或者未设置过期时间</h5><pre><code>ttl key 
</code></pre>
<h5 id="取消过期时间"><a href="#取消过期时间" class="headerlink" title="取消过期时间"></a>取消过期时间</h5><pre><code>persist
</code></pre>
<h5 id="随机返回数据库里的一个key"><a href="#随机返回数据库里的一个key" class="headerlink" title="随机返回数据库里的一个key"></a>随机返回数据库里的一个key</h5><pre><code>randomkey
</code></pre>
<h5 id="将key从当前数据库移动到指定数据库，返回1表示成功，0表示key不存在或者已经在指定的数据库中"><a href="#将key从当前数据库移动到指定数据库，返回1表示成功，0表示key不存在或者已经在指定的数据库中" class="headerlink" title="将key从当前数据库移动到指定数据库，返回1表示成功，0表示key不存在或者已经在指定的数据库中"></a>将key从当前数据库移动到指定数据库，返回1表示成功，0表示key不存在或者已经在指定的数据库中</h5><pre><code>move key db-index
</code></pre>
<h4 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h4><h5 id="通过索引选择数据库，默认连接的数据库是0，默认数据库是16个；-返回1表示切换成功，0表示失败"><a href="#通过索引选择数据库，默认连接的数据库是0，默认数据库是16个；-返回1表示切换成功，0表示失败" class="headerlink" title="通过索引选择数据库，默认连接的数据库是0，默认数据库是16个； 返回1表示切换成功，0表示失败"></a>通过索引选择数据库，默认连接的数据库是0，默认数据库是16个； 返回1表示切换成功，0表示失败</h5><pre><code>select db-index 
</code></pre>
<h5 id="清空当前数据库，慎用"><a href="#清空当前数据库，慎用" class="headerlink" title="清空当前数据库，慎用"></a>清空当前数据库，<em>慎用</em></h5><pre><code>flushdb
</code></pre>
<h5 id="清空所有数据库，慎用"><a href="#清空所有数据库，慎用" class="headerlink" title="清空所有数据库，慎用"></a>清空所有数据库，<em>慎用</em></h5><pre><code>flushall
</code></pre>
<h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><h5 id="获取当前redis服务器状态和一些统计信息"><a href="#获取当前redis服务器状态和一些统计信息" class="headerlink" title="获取当前redis服务器状态和一些统计信息"></a>获取当前redis服务器状态和一些统计信息</h5><pre><code>info
</code></pre>
<h5 id="返回相关的配置信息"><a href="#返回相关的配置信息" class="headerlink" title="返回相关的配置信息"></a>返回相关的配置信息</h5><pre><code>config get paramter
</code></pre>
<h5 id="返回所有配置"><a href="#返回所有配置" class="headerlink" title="返回所有配置"></a>返回所有配置</h5><pre><code>config get *
</code></pre>
<h5 id="实时监听并返回redis服务器接收到的所有请求信息"><a href="#实时监听并返回redis服务器接收到的所有请求信息" class="headerlink" title="实时监听并返回redis服务器接收到的所有请求信息"></a>实时监听并返回redis服务器接收到的所有请求信息</h5><pre><code>monitor
</code></pre>
<h5 id="获取一个key的调试信息"><a href="#获取一个key的调试信息" class="headerlink" title="获取一个key的调试信息"></a>获取一个key的调试信息</h5><pre><code>debug object key
</code></pre>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="制造一次服务器当机"><a href="#制造一次服务器当机" class="headerlink" title="制造一次服务器当机"></a>制造一次服务器当机</h5><pre><code>debug segfault
</code></pre>
<h5 id="打印命令"><a href="#打印命令" class="headerlink" title="打印命令"></a>打印命令</h5><pre><code>echo
</code></pre>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Slow HTTP Denial Of Service Attack</title>
    <url>/2018/12/13/Slow%20HTTP%20Denial%20Of%20Service%20Attack/</url>
    <content><![CDATA[<p>近期使用WVS扫描工具对 Web 系统进行扫描，出现了<font color="red"> Slow HTTP Denial Of Service Attack </font>的安全漏洞，即缓慢的 HTTP DOS 攻击。 </p>
<p>该攻击依赖于 HTTP POST ，指定一个非常大的 content-length ，以很低的频率每次发送数据包的一部分，如果一个 HTTP 请求是不完整的或者数据传输的速率非常低，服务器将占用连接资源等待其余数据的传输，如果发送大量这样的请求，则服务器将拒绝其他的请求服务，导致服务器瘫痪。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>对 web 服务器的 HTTP 头部传输的最大许可时间进行限制，修改最大许可时间为 5s（建议为 5s~10s ）</p>
<p>Tomcat：修改 server.xml 的 connectionTimeout (默认为20000ms即 20s)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> </span></span><br><span class="line"><span class="tag">	<span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> </span></span><br><span class="line"><span class="tag">	<span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span> </span></span><br><span class="line"><span class="tag">	<span class="attr">connectionTimeout</span>=<span class="string">&quot;5000&quot;</span>  </span></span><br><span class="line"><span class="tag">	<span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> </span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot之Redis引入</title>
    <url>/2018/06/08/SpringBoot%E4%B9%8BRedis%E5%BC%95%E5%85%A5/</url>
    <content><![CDATA[<h3 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Redis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--spring2.0集成redis所需common-pool2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--fastjson--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.40<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"># REDIS (RedisProperties)</span><br><span class="line"># Redis数据库索引（默认为<span class="number">0</span>）</span><br><span class="line">spring.redis.database=<span class="number">0</span></span><br><span class="line"># Redis服务器地址</span><br><span class="line">spring.redis.host=<span class="number">47.97</span>.<span class="number">173.227</span></span><br><span class="line"># Redis服务器连接端口</span><br><span class="line">spring.redis.port=<span class="number">6379</span></span><br><span class="line"># Redis服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=asdf12331aafjdahj1312jhj131+_111ghghgh</span><br><span class="line"># 连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.jedis.pool.<span class="built_in">max</span>-active=<span class="number">8</span></span><br><span class="line"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">spring.redis.jedis.pool.<span class="built_in">max</span>-wait=-<span class="number">1</span>ms</span><br><span class="line"># 连接池中的最大空闲连接</span><br><span class="line">spring.redis.jedis.pool.<span class="built_in">max</span>-idle=<span class="number">8</span></span><br><span class="line"># 连接池中的最小空闲连接</span><br><span class="line">spring.redis.jedis.pool.<span class="built_in">min</span>-idle=<span class="number">0</span></span><br><span class="line"># 连接超时时间（毫秒）</span><br><span class="line">spring.redis.timeout=<span class="number">3000</span>ms</span><br></pre></td></tr></table></figure>

<h3 id="序列化问题"><a href="#序列化问题" class="headerlink" title="序列化问题"></a>序列化问题</h3><p>data-redis在进行存储时，key和value默认使用了基于JDK的序列化方式（JdkSerializationRedisSerializer），在使用连接工具查看时看到的都是编码后的信息，不方便查看，所以需要更改默认的序列化方式。此处对key值的序列化使用自定义的String序列化器(data-redis也提供了一个基于String的序列化器，但是该序列化器的泛型是String类型的，不能传入其他类型的值，所以基于官方提供的String序列化器再重写一个泛型为Object的序列化器)，对value使用基于FastJson的序列化器（FastJson也提供了一个序列化器，可以使用该序列化器，也可以仿照该序列化器自定义一个序列化器）</p>
<h4 id="自定义String序列化器"><a href="#自定义String序列化器" class="headerlink" title="自定义String序列化器"></a>自定义String序列化器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringRedisSerializer</span> <span class="keyword">implements</span> <span class="title class_">RedisSerializer</span>&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Charset charset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> <span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">replacement</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@link</span> org.springframework.data.redis.serializer.StringRedisSerializer&#125; using &#123;<span class="doctag">@link</span> StandardCharsets#UTF_8 UTF-8&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StringRedisSerializer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@link</span> org.springframework.data.redis.serializer.StringRedisSerializer&#125; using the given &#123;<span class="doctag">@link</span> Charset&#125; to encode and decode strings.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> charset must not be &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StringRedisSerializer</span><span class="params">(Charset charset)</span> &#123;</span><br><span class="line">        Assert.notNull(charset, <span class="string">&quot;Charset must not be null!&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.charset = charset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * (non-Javadoc)</span></span><br><span class="line"><span class="comment">     * @see org.springframework.data.redis.serializer.RedisSerializer#deserialize(byte[])</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deserialize</span><span class="params">(<span class="meta">@Nullable</span> <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (bytes == <span class="literal">null</span> ? <span class="literal">null</span> : <span class="keyword">new</span> <span class="title class_">String</span>(bytes, charset));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] serialize(<span class="meta">@Nullable</span> Object o) <span class="keyword">throws</span> SerializationException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> JSON.toJSONString(o);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(string)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string = string.replace(target, replacement);</span><br><span class="line">        <span class="keyword">return</span> string.getBytes(charset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="自定义FastJSON序列化器"><a href="#自定义FastJSON序列化器" class="headerlink" title="自定义FastJSON序列化器"></a>自定义FastJSON序列化器</h4><p>我这里用了官方提供的FastJSON序列化器，如果想自定义的话，可以参考以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastJsonRedisSerializer</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">RedisSerializer</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Charset</span> <span class="variable">DEFAULT_CHARSET</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; clazz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastJsonRedisSerializer</span><span class="params">(Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.clazz = clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] serialize(T t) <span class="keyword">throws</span> SerializationException &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> SerializationException &#123;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span> || bytes.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, DEFAULT_CHARSET);</span><br><span class="line">        <span class="keyword">return</span> (T) JSON.parseObject(str, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="指定序列化器"><a href="#指定序列化器" class="headerlink" title="指定序列化器"></a>指定序列化器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(RedisOperations.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RedisProperties.class)</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用fastjson序列化  目前采用的是FastJson提供的序列化器  也可以自定义FastJSON的序列化器</span></span><br><span class="line">        <span class="type">FastJsonRedisSerializer</span> <span class="variable">fastJsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FastJsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="comment">// value值的序列化采用fastJsonRedisSerializer</span></span><br><span class="line">        redisTemplate.setValueSerializer(fastJsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashValueSerializer(fastJsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key的序列化采用StringRedisSerializer</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot之基于Redis的Session共享</title>
    <url>/2018/06/08/SpringBoot%E4%B9%8BSession%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>在pom.xml中添加spring-session-data-redis依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Session共享 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 60*30)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionRedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<strong>maxInactiveIntervalInSeconds字段用来设置Session失效时间，使用Redis Session之后，原SpringBoot的server.session.timeout属性不再生效</strong></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/uid&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">uid</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line">    <span class="type">UUID</span> <span class="variable">uid</span> <span class="operator">=</span> (UUID) session.getAttribute(<span class="string">&quot;uid&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (uid == <span class="literal">null</span>) &#123;</span><br><span class="line">    	uid = UUID.randomUUID();</span><br><span class="line">    &#125;</span><br><span class="line">    session.setAttribute(<span class="string">&quot;uid&quot;</span>, uid);</span><br><span class="line">    <span class="keyword">return</span> session.getId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上述配置和代码写入到两个不同的项目中，然后访问<a href="http://127.0.0.1:8080/uid">http://127.0.0.1:8080/uid</a>和<a href="http://127.0.0.1:8081/uid">http://127.0.0.1:8081/uid</a>，返回的sessionId一致:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">71f3099c-dcc0-4445-8d5e-57ef96d84412</span><br></pre></td></tr></table></figure>

<p>通过Redis客户端连接可以看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;spring:session:sessions:71f3099c-dcc0-4445-8d5e-57ef96d84412&quot;</span><br><span class="line">2) &quot;spring:session:expirations:1531014420000&quot;</span><br><span class="line">3) &quot;spring:session:sessions:expires:71f3099c-dcc0-4445-8d5e-57ef96d84412&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot之Actuator监控</title>
    <url>/2018/06/06/SpringBoot%E4%B9%8Bactuator%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>在<code>pom.xml</code>中添加<code>spring-boot-starter-actuator</code>依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果只添加<code>actuator</code>依赖，用户可以直接访问监控系统，而不需要权限认证，有安全风险。所以，为了安全性考虑，需要添加<code>spring-boot-start-security</code>依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>添加之后，用户访问监控页面的时候就会跳转到监控的登录页面，输入用户名和密码之后才能进入到监控界面。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot:在spring-boot-starter-web中用jetty替代tomcat</title>
    <url>/2018/06/06/SpringBoot%E4%B9%8B%E5%9C%A8spring-boot-starter-web%E4%B8%AD%E7%94%A8jetty%E6%9B%BF%E4%BB%A3tomcat/</url>
    <content><![CDATA[<p>在spring-boot-starter-web中用jetty替代tomcat</p>
<p>在spring-boot-starter-web移除现有的依赖项，并把下面的配置加到pom中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>经验</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot之热启动</title>
    <url>/2018/06/06/SpringBoot%E4%B9%8B%E7%83%AD%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p>在开发调试阶段，可以配置SpringBoot的热启动，代码修改后实时更新，不需要重新启动项目。</p>
<h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>在pom.xml中添加依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h4><p>到此处，Eclipse已经能够自动编译了</p>
<h4 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h4><p>idea比较特殊，需要设置自动编译</p>
<h5 id="开启自动编译"><a href="#开启自动编译" class="headerlink" title="开启自动编译"></a>开启自动编译</h5><p>File-&gt;Settings-&gt; Build-Execution-Deployment -&gt; Compiler，勾选 Build Project Automatically.</p>
<p><img src="/images/idea01.png"></p>
<p>组合键Shift+Ctrl+A打开配置面板，找到<font color="red">Registry…</font>，点击</p>
<p><img src="/images/idea02.png"></p>
<p>找到<font color="red">compiler.automake.allow.when.app.running</font>，勾选，然后退出。</p>
<p><img src="/images/idea03.png"></p>
<h5 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h5><p>某些情况下，自动编辑可能不会生效，如果碰到这种情况，可以使用<font color="red">Ctrl + F9</font>手动编译，不需要去重启服务。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot之自定义配置</title>
    <url>/2018/12/17/SpringBoot%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="读取application-properties文件中的配置"><a href="#读取application-properties文件中的配置" class="headerlink" title="读取application.properties文件中的配置"></a>读取application.properties文件中的配置</h3><p>在 application.properties 文件中加入项目的标题、版本、作者等信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project.title=sample</span><br><span class="line">project.version=v1.0.0-SNAPSHOT</span><br><span class="line">project.author=lemon</span><br></pre></td></tr></table></figure>

<h4 id="Value注解"><a href="#Value注解" class="headerlink" title="@Value注解"></a>@Value注解</h4><p>新建一个配置类，存储项目的配置信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;project.title&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;project.version&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;project.author&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="声明配置的前缀（-ConfigurationProperties）"><a href="#声明配置的前缀（-ConfigurationProperties）" class="headerlink" title="声明配置的前缀（@ConfigurationProperties）"></a>声明配置的前缀（@ConfigurationProperties）</h4><p>也可以指定配置的前缀，这样的话就不需要使用 @Value 注解了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;project&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用Environment"><a href="#使用Environment" class="headerlink" title="使用Environment"></a>使用Environment</h4><p>在需要读取配置的地方注入 Environment，通过 Environmen t的 getProperty() 方法获取配置信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取标题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;title&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">title</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> env.getProperty(<span class="string">&quot;project.title&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="读取自定义的配置文件"><a href="#读取自定义的配置文件" class="headerlink" title="读取自定义的配置文件"></a>读取自定义的配置文件</h3><p>自定义配置文件 server.properties，放在 resources&#x2F;config 目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server.ip=127.0.0.1</span><br></pre></td></tr></table></figure>

<p>创建Bean，指定读取的配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&quot;classpath:/config/server.properties&quot;)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;server&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由此，可以读取到自定义的配置文件中的配置。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot内置Tocmat出现Trace请求漏洞</title>
    <url>/2019/01/05/SpringBoot%E5%86%85%E7%BD%AETocmat%E5%87%BA%E7%8E%B0Trace%E8%AF%B7%E6%B1%82%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>近期使用绿盟扫描工具对 Web 系统进行扫描，出现了检测到目标服务器启用了 TRACE 方法的高级漏洞，TRACE 是 HTTP 协议定义的一种请求方法，该方法会使服务器原样返回任意客户端请求的任何内容，因此可以用来进行跨站点脚本攻击（XSS 攻击），这种攻击方式又称为跨站跟踪攻击（XST）。 </p>
<p>绿盟的报告中给出了相应的方案：</p>
<ol>
<li>2.0.55 以上版本的 Apache 服务器，可以在<code>httpd.conf</code>的尾部添加：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TraceEnable off</span><br></pre></td></tr></table></figure>

<p>2.如果你使用的是 Apache： </p>
<ul>
<li>确认 rewrite 模块激活（httpd.conf）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LoadModule rewrite_module modules/mod_rewrite.so</span><br></pre></td></tr></table></figure>

<ul>
<li>在各虚拟主机的配置文件里添加如下语句：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RewriteEngine On RewriteCond %&#123;REQUEST_METHOD&#125; ^TRACE RewriteRule .*</span><br></pre></td></tr></table></figure>

<p>我们的项目是基于 SpringBoot的单机web项目，并没有使用到Apache服务器。查询相关资料，得知在Tomcat的web.xml文件中可以配置HTTP的请求方式，禁止不安全的请求类型： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">security-constraint</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">web-resource-collection</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">http-method</span>&gt;</span>PUT<span class="tag">&lt;/<span class="name">http-method</span>&gt;</span>  </span><br><span class="line">	  <span class="tag">&lt;<span class="name">http-method</span>&gt;</span>DELETE<span class="tag">&lt;/<span class="name">http-method</span>&gt;</span>  </span><br><span class="line">	  <span class="tag">&lt;<span class="name">http-method</span>&gt;</span>HEAD<span class="tag">&lt;/<span class="name">http-method</span>&gt;</span>  </span><br><span class="line">	  <span class="tag">&lt;<span class="name">http-method</span>&gt;</span>OPTIONS<span class="tag">&lt;/<span class="name">http-method</span>&gt;</span>  </span><br><span class="line">	  <span class="tag">&lt;<span class="name">http-method</span>&gt;</span>TRACE<span class="tag">&lt;/<span class="name">http-method</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">web-resource-collection</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">auth-constraint</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">auth-constraint</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">security-constraint</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">login-config</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">auth-method</span>&gt;</span>BASIC<span class="tag">&lt;/<span class="name">auth-method</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">login-config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果使用的是SpringBoot内置的Tomcat容器的话，可以配置Tomcat的配置类，将配置注入到Spring容器中： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TomcatConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TomcatServletWebServerFactory <span class="title function_">servletContainer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TomcatServletWebServerFactory</span> <span class="variable">tomcatServletContainerFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line">        tomcatServletContainerFactory.addContextCustomizers(<span class="keyword">new</span> <span class="title class_">TomcatContextCustomizer</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customize</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">                <span class="type">SecurityConstraint</span> <span class="variable">constraint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecurityConstraint</span>();</span><br><span class="line">                <span class="type">SecurityCollection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecurityCollection</span>();</span><br><span class="line">                <span class="comment">//http方法</span></span><br><span class="line">                collection.addMethod(<span class="string">&quot;PUT&quot;</span>);</span><br><span class="line">                collection.addMethod(<span class="string">&quot;DELETE&quot;</span>);</span><br><span class="line">                collection.addMethod(<span class="string">&quot;HEAD&quot;</span>);</span><br><span class="line">                collection.addMethod(<span class="string">&quot;OPTIONS&quot;</span>);</span><br><span class="line">                collection.addMethod(<span class="string">&quot;TRACE&quot;</span>);</span><br><span class="line">                <span class="comment">//url匹配表达式</span></span><br><span class="line">                collection.addPattern(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">                constraint.addCollection(collection);</span><br><span class="line">                constraint.setAuthConstraint(<span class="literal">true</span>);</span><br><span class="line">                context.addConstraint(constraint );</span><br><span class="line"></span><br><span class="line">                <span class="comment">//设置使用httpOnly</span></span><br><span class="line">                context.setUseHttpOnly(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> tomcatServletContainerFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 SpringBoot 的版本低于2.0，可以将 <code>TomcatServletWebServerFactory</code>替换成 <code>EmbeddedServletContainerFactory</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TomcatConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TomcatServletWebServerFactory <span class="title function_">servletContainer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TomcatServletWebServerFactory</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postProcessContext</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">                <span class="type">SecurityConstraint</span> <span class="variable">securityConstraint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecurityConstraint</span>();</span><br><span class="line">                securityConstraint.setUserConstraint(<span class="string">&quot;CONFIDENTIAL&quot;</span>);</span><br><span class="line">                <span class="type">SecurityCollection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecurityCollection</span>();</span><br><span class="line">                collection.addPattern(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">                collection.addMethod(<span class="string">&quot;HEAD&quot;</span>);</span><br><span class="line">                collection.addMethod(<span class="string">&quot;PUT&quot;</span>);</span><br><span class="line">                collection.addMethod(<span class="string">&quot;DELETE&quot;</span>);</span><br><span class="line">                collection.addMethod(<span class="string">&quot;OPTIONS&quot;</span>);</span><br><span class="line">                collection.addMethod(<span class="string">&quot;TRACE&quot;</span>);</span><br><span class="line">                collection.addMethod(<span class="string">&quot;COPY&quot;</span>);</span><br><span class="line">                collection.addMethod(<span class="string">&quot;SEARCH&quot;</span>);</span><br><span class="line">                collection.addMethod(<span class="string">&quot;PROPFIND&quot;</span>);</span><br><span class="line">                securityConstraint.addCollection(collection);</span><br><span class="line">                context.addConstraint(securityConstraint);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//如果需要禁用TRACE请求，需添加以下代码：</span></span><br><span class="line">        tomcat.addConnectorCustomizers(connector -&gt; &#123;</span><br><span class="line">            connector.setAllowTrace(<span class="literal">true</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> tomcat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>绿盟</category>
      </categories>
      <tags>
        <tag>绿盟</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot内置Tomcat参数配置</title>
    <url>/2018/12/21/SpringBoot%E5%86%85%E7%BD%AETomcat%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>SpringBoot的项目在使用内置的Tomcat部署时，需要定义相关的Tomcat参数，本文主要讲述需要配置哪些参数。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">tomcat:</span></span><br><span class="line">    <span class="attr">accesslog:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span> <span class="comment">#打开tomcat访问日志</span></span><br><span class="line">      <span class="attr">directory:</span> <span class="string">logs</span> <span class="comment"># 访问日志所在的目录</span></span><br><span class="line">    <span class="attr">accept-count:</span> <span class="comment">#允许HTTP请求缓存到请求队列的最大个数，默认不限制</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="comment">#最大连接数，默认不设置</span></span><br><span class="line">    <span class="attr">max-http-post-size:</span> <span class="comment">#HTTP POST内容最大长度，默认不限制</span></span><br><span class="line">    <span class="attr">max-threads:</span> <span class="comment">#最大工作线程数</span></span><br></pre></td></tr></table></figure>

<p>这些参数最终在ServerProperties.Tomcat类中体现</p>
<p>Tomcat是一个静态内部类，其中包含了一下属性</p>
<ul>
<li>maxThreads 最大工作线程数</li>
<li>minSpareThreads 最小工作线程数</li>
<li>maxHttpPostSize HTTP POST内容最大长度</li>
<li>internalProxies 受信任IP校验正则表达式</li>
<li>protocolHeader 协议头，通常设置为X-Forwarded-Proto</li>
<li>protocolHeaderHttpsValue 协议头的内容，判断是否使用了SSL，默认值是https</li>
<li>portHeader 用于覆盖原始端口值的HTTP头的名称，默认为X-Forwarded-Port</li>
<li>redirectContextRoot 对上下文根的请求是否应该通过附加**&#x2F;**到路径来重定向</li>
<li>useRelativeRedirects 设置通过调用sendRedirect生成的HTTP 1.1和后面的位置头是使用相对重定向还是使用绝对重定向</li>
<li>remoteIpHeader 提取远程IP的HTTP头的名称。例如X-FORWARDED-FOR</li>
<li>maxConnections 最大连接数，如果一旦连接数到达，剩下的连接将会保存到请求缓存队列里，也就是accept-count指定队列</li>
<li>maxHttpHeaderSize HTTP消息头的最大值(以字节为单位)</li>
<li>acceptCount 当所有可能的请求处理线程都在使用时，传入连接请求的最大队列长度</li>
</ul>
<p>Tomcat拥有一个静态内部类Accesslog，主要用于配置Tomcat访问日志的参数信息</p>
<ul>
<li>enabled 是否启用访问日志</li>
<li>pattern 访问日志的格式化模式，默认为common</li>
<li>directory  创建日志文件的目录。可以是绝对的或相对于Tomcat的基目录，默认是logs</li>
<li>prefix 日志文件名称前缀，默认为access_log</li>
<li>suffix 日志文件名称后缀，默认为.log</li>
<li>rotate 是否启用访问日志旋转，默认为true</li>
<li>renameOnRotate  是否推迟将日期戳包含在文件名中直到旋转时间。 </li>
<li>fileDateFormat 日志文件名称中的日期格式，默认为**.yyyy-MM-dd**。</li>
<li>requestAttributesEnabled 为请求使用的IP地址、主机名、协议和端口设置请求属性。</li>
<li>buffered  是否缓冲输出，使其只定期刷新，默认为true</li>
</ul>
<p>Tomcat还有名为Resource的静态内部类，主要用于配置静态资源缓存的生存周期</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot单元测试：Unable to find a @SpringBootConfiguration</title>
    <url>/2018/07/11/SpringBoot%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%9AUnable%20to%20find%20a%20@SpringBootConfiguration,%20you%20need%20to%20use%20@ContextConfiguration%20or%20@SpringBootTest(classes=...)%20with%20your%20test/</url>
    <content><![CDATA[<p>SpringBoot 下使用 Junit 进行单元测试时，报错：<code>java.lang.IllegalStateException: Unable to find a @SpringBootConfiguration, you need to use @ContextConfiguration or @SpringBootTest(classes=...) with your test</code>；</p>
<p>具体报错信息如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">信息: Could not detect <span class="keyword">default</span> configuration classes <span class="keyword">for</span> test class [com.qinghuazs.starlight.oss.AliOSSBucketClientTest]: AliOSSBucketClientTest does not declare any <span class="keyword">static</span>, non-<span class="keyword">private</span>, non-<span class="keyword">final</span>, nested classes annotated with <span class="meta">@Configuration</span>.</span><br><span class="line">  </span><br><span class="line">java.lang.IllegalStateException: Unable to find a <span class="meta">@SpringBootConfiguration</span>, you need to use <span class="meta">@ContextConfiguration</span> or <span class="meta">@SpringBootTest(classes=...)</span> with your test</span><br><span class="line"></span><br><span class="line">	at org.springframework.util.Assert.state(Assert.java:<span class="number">73</span>)</span><br><span class="line">	at org.springframework.boot.test.context.SpringBootTestContextBootstrapper.getOrFindConfigurationClasses(SpringBootTestContextBootstrapper.java:<span class="number">240</span>)</span><br><span class="line">	at org.springframework.boot.test.context.SpringBootTestContextBootstrapper.processMergedContextConfiguration(SpringBootTestContextBootstrapper.java:<span class="number">153</span>)</span><br><span class="line">	at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildMergedContextConfiguration(AbstractTestContextBootstrapper.java:<span class="number">395</span>)</span><br><span class="line">	at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildDefaultMergedContextConfiguration(AbstractTestContextBootstrapper.java:<span class="number">312</span>)</span><br><span class="line">	at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildMergedContextConfiguration(AbstractTestContextBootstrapper.java:<span class="number">265</span>)</span><br><span class="line">	at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildTestContext(AbstractTestContextBootstrapper.java:<span class="number">108</span>)</span><br><span class="line">	at org.springframework.boot.test.context.SpringBootTestContextBootstrapper.buildTestContext(SpringBootTestContextBootstrapper.java:<span class="number">97</span>)</span><br><span class="line">	at org.springframework.test.context.TestContextManager.&lt;init&gt;(TestContextManager.java:<span class="number">139</span>)</span><br><span class="line">	at org.springframework.test.context.TestContextManager.&lt;init&gt;(TestContextManager.java:<span class="number">124</span>)</span><br><span class="line">	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.createTestContextManager(SpringJUnit4ClassRunner.java:<span class="number">151</span>)</span><br><span class="line">	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.&lt;init&gt;(SpringJUnit4ClassRunner.java:<span class="number">142</span>)</span><br><span class="line">	at org.springframework.test.context.junit4.SpringRunner.&lt;init&gt;(SpringRunner.java:<span class="number">49</span>)</span><br><span class="line">	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:<span class="number">45</span>)</span><br><span class="line">	at java.lang.reflect.Constructor.newInstance(Constructor.java:<span class="number">423</span>)</span><br><span class="line">	at org.junit.internal.builders.AnnotatedBuilder.buildRunner(AnnotatedBuilder.java:<span class="number">104</span>)</span><br><span class="line">	at org.junit.internal.builders.AnnotatedBuilder.runnerForClass(AnnotatedBuilder.java:<span class="number">86</span>)</span><br><span class="line">	at org.junit.runners.model.RunnerBuilder.safeRunnerForClass(RunnerBuilder.java:<span class="number">59</span>)</span><br><span class="line">	at org.junit.internal.builders.AllDefaultPossibilitiesBuilder.runnerForClass(AllDefaultPossibilitiesBuilder.java:<span class="number">26</span>)</span><br><span class="line">	at org.junit.runners.model.RunnerBuilder.safeRunnerForClass(RunnerBuilder.java:<span class="number">59</span>)</span><br><span class="line">	at org.junit.internal.requests.ClassRequest.getRunner(ClassRequest.java:<span class="number">33</span>)</span><br><span class="line">	at org.junit.internal.requests.FilterRequest.getRunner(FilterRequest.java:<span class="number">36</span>)</span><br><span class="line">	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:<span class="number">49</span>)</span><br><span class="line">	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:<span class="number">47</span>)</span><br><span class="line">	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:<span class="number">242</span>)</span><br><span class="line">	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:<span class="number">70</span>)</span><br></pre></td></tr></table></figure>

<p>根据报错提示，可以得知 SpringBoot 应用下缺失 <code>@SpringBootConfiguration</code> 类，即 SpringBoot 启动类（<code>@SpringBootApplication</code> 是一个复合注解），增加一个 SpringBoot 启动类即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OSSApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OSSApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot工程创建</title>
    <url>/2018/06/05/SpringBoot%E5%B7%A5%E7%A8%8B%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<h4 id="项目的创建"><a href="#项目的创建" class="headerlink" title="项目的创建"></a>项目的创建</h4><p>访问<a href="http://start.spring.io/">start.spring.io</a>，选择相应的模块，生成代码，导入到IDE中即可</p>
<p>也可以直接使用IDE进行创建，以idea为例：</p>
<h5 id="点击新建项目，选择Spring-Initializr，选择JDK和URL"><a href="#点击新建项目，选择Spring-Initializr，选择JDK和URL" class="headerlink" title="点击新建项目，选择Spring Initializr，选择JDK和URL"></a>点击新建项目，选择Spring Initializr，选择JDK和URL</h5><p><img src="https://i.imgur.com/Fjludse.png" alt="输入图片说明" title="屏幕截图.png"></p>
<h5 id="填写项目相关信息，点击next"><a href="#填写项目相关信息，点击next" class="headerlink" title="填写项目相关信息，点击next"></a>填写项目相关信息，点击next</h5><p><img src="https://i.imgur.com/r3u7MpJ.png" alt="输入图片说明" title="屏幕截图.png"></p>
<h5 id="选择需要用到的模块，本例中先选择Web，后续如果有用到其他模块，可以再进行添加"><a href="#选择需要用到的模块，本例中先选择Web，后续如果有用到其他模块，可以再进行添加" class="headerlink" title="选择需要用到的模块，本例中先选择Web，后续如果有用到其他模块，可以再进行添加"></a>选择需要用到的模块，本例中先选择Web，后续如果有用到其他模块，可以再进行添加</h5><p><img src="https://i.imgur.com/uiG6lMX.png" alt="输入图片说明" title="屏幕截图.png"></p>
<h5 id="点击Finish，完成SpringBoot项目的创建"><a href="#点击Finish，完成SpringBoot项目的创建" class="headerlink" title="点击Finish，完成SpringBoot项目的创建"></a>点击Finish，完成SpringBoot项目的创建</h5><p><img src="https://i.imgur.com/kyQakKN.png"></p>
<p>创建完成后，会自动创建相应的文件夹，并生成一个【项目名+Application】的Java类，如我的项目名是rabbit，则创建的Java类为 <code>RabbitApplication</code></p>
<p>如图为自动创建的资源文件和Java类</p>
<p><img src="https://i.imgur.com/oykxaGv.png" alt="输入图片说明" title="屏幕截图.png"></p>
<p>RabbitApplication是整个项目的入口类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	SpringApplication.run(RabbitApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot日志配置</title>
    <url>/2018/07/01/SpringBoot%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>SpringBoot默认使用logback作为日志框架，可在resources文件夹下添加logback.xml文件进行配置。</p>
<p>文件内容如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">&quot;true&quot;</span> <span class="attr">scanPeriod</span>=<span class="string">&quot;60 seconds&quot;</span> <span class="attr">debug</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 工程名/项目名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>project_name<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">timestamp</span> <span class="attr">key</span>=<span class="string">&quot;bySecond&quot;</span> <span class="attr">datePattern</span>=<span class="string">&quot;yyyyMMdd&#x27;T&#x27;HHmmss&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--把&gt;=debug的日志输出到控制台 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;SDTOUT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%-4relative %date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;35&#125; - %msg %n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;INFO_FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/info.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">name</span>=<span class="string">&quot;50M_FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>logs/info.%i.log.zip<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">minIndex</span>&gt;</span>1<span class="tag">&lt;/<span class="name">minIndex</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxIndex</span>&gt;</span>500<span class="tag">&lt;/<span class="name">maxIndex</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>200MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%-4relative %date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;35&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;ERROR_FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/error.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">name</span>=<span class="string">&quot;50M_FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>logs/error.%i.log.zip<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">minIndex</span>&gt;</span>1<span class="tag">&lt;/<span class="name">minIndex</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxIndex</span>&gt;</span>100<span class="tag">&lt;/<span class="name">maxIndex</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>200MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%-4relative %date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;35&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开发阶段使用DEBUG  生产环境使用INFO --&gt;</span></span><br><span class="line">    　<span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;root level=&quot;INFO&quot;&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;SDTOUT&quot;</span> /&gt;</span></span><br><span class="line">    　  <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;INFO_FILE&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ERROR_FILE&quot;</span> /&gt;</span></span><br><span class="line">    　<span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot源码解析之SpringApplication</title>
    <url>/2018/07/11/SpringBoot%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BSpringApplication/</url>
    <content><![CDATA[<p>可以用于从Java主方法引导并启动Spring应用程序的类。默认情况下，类将执行以下步骤启动应用程序:</p>
<ul>
<li>创建适当的ApplicationContext实例(取决于类路径)</li>
<li>注册一个CommandLinePropertySource，以Spring属性的形式暴露命令行参数</li>
<li>刷新应用程序上下文，加载所有的单例bean</li>
<li>触发所有的CommandLineRunner bean</li>
</ul>
<p>在大多数情况下，静态方法run(Class&lt;?&gt;[] primarySources, String[] args)可以直接从主方法调用，从而引导应用程序:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... Bean definitions</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于更高级的配置，可以在运行之前创建和定制SpringApplication实例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="type">SpringApplication</span> <span class="variable">application</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(MyApplication.class);</span><br><span class="line">   <span class="comment">// ... customize application settings here</span></span><br><span class="line">   application.run(args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>springapplication可以从各种不同的来源读取bean。通常建议使用一个@Configuration类来引导应用程序，但是，您也可以从以下设置源:</p>
<ul>
<li>由AnnotatedBeanDefinitionReader加载的完全限定类名</li>
<li>XmlBeanDefinitionReader装载的XML资源的位置，或者GroovyBeanDefinitionReader装载的groovy脚本</li>
<li>ClassPathBeanDefinitionScanner要扫描的软件包的名称</li>
</ul>
<p>配置属性也绑定到SpringApplication。这使得可以动态地设置SpringApplication属性，比如额外的源(“spring.main”。来源“-一个CSV列表)标志以表示一个web环境(“spring.main.web-application-type&#x3D;none”)或标志以关闭横幅(“spring.main.bannermode &#x3D;off”)。</p>
<p>启动时调用main方法，主要执行***SpringApplication.run()***方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(RabbitApplication.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringApplication的run方法实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Static helper that can be used to run a &#123;<span class="doctag">@link</span> SpringApplication&#125; from the</span></span><br><span class="line"><span class="comment">	 * specified source using default settings.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> primarySource the primary source to load</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args the application arguments (usually passed from a Java main method)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the running &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt; primarySource,</span></span><br><span class="line"><span class="params">			String... args)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> run(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>其中primarySource即为<strong>com.lemon.rabbit.RabbitApplication</strong></p>
<p>SpringApplication中定义了一些静态的成员属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//在非web环境中默认使用的应用程序上下文的类名。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_CONTEXT_CLASS</span> <span class="operator">=</span> <span class="string">&quot;org.springframework.context.&quot;</span></span><br><span class="line">			+ <span class="string">&quot;annotation.AnnotationConfigApplicationContext&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//应用程序上下文的类名，默认用于web环境。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_WEB_CONTEXT_CLASS</span> <span class="operator">=</span> <span class="string">&quot;org.springframework.boot.&quot;</span></span><br><span class="line">			+ <span class="string">&quot;web.servlet.context.AnnotationConfigServletWebServerApplicationContext&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] WEB_ENVIRONMENT_CLASSES = &#123; <span class="string">&quot;javax.servlet.Servlet&quot;</span>,</span><br><span class="line">			<span class="string">&quot;org.springframework.web.context.ConfigurableWebApplicationContext&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_REACTIVE_WEB_CONTEXT_CLASS</span> <span class="operator">=</span> <span class="string">&quot;org.springframework.&quot;</span></span><br><span class="line">			+ <span class="string">&quot;boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REACTIVE_WEB_ENVIRONMENT_CLASS</span> <span class="operator">=</span> <span class="string">&quot;org.springframework.&quot;</span></span><br><span class="line">			+ <span class="string">&quot;web.reactive.DispatcherHandler&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MVC_WEB_ENVIRONMENT_CLASS</span> <span class="operator">=</span> <span class="string">&quot;org.springframework.&quot;</span></span><br><span class="line">			+ <span class="string">&quot;web.servlet.DispatcherServlet&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//banner的默认存放位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BANNER_LOCATION_PROPERTY_VALUE</span> <span class="operator">=</span> SpringApplicationBannerPrinter.DEFAULT_BANNER_LOCATION;</span><br><span class="line"></span><br><span class="line"><span class="comment">//旗帜位置属性的关键。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BANNER_LOCATION_PROPERTY</span> <span class="operator">=</span> SpringApplicationBannerPrinter.BANNER_LOCATION_PROPERTY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SYSTEM_PROPERTY_JAVA_AWT_HEADLESS</span> <span class="operator">=</span> <span class="string">&quot;java.awt.headless&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





































]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 自定义 Starter</title>
    <url>/2020/01/08/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89Starter/</url>
    <content><![CDATA[<h2 id="Starter-命名规范"><a href="#Starter-命名规范" class="headerlink" title="Starter 命名规范"></a>Starter 命名规范</h2><p>官方的 Starter 遵循 <code>spring-boot-starter-*</code> 的命名模式，如 <code>spring-boot-starter-data-jpa</code> 。第三方的 Starter 通常以自己的项目名称开始，例如，名为 thirdpartyproject 的第三方入门项目通常被命名为 <code>thirdpartyproject-spring-boot-starter</code>。</p>
<h2 id="自定义-Starter"><a href="#自定义-Starter" class="headerlink" title="自定义 Starter"></a>自定义 Starter</h2><h3 id="创建-Starter-工程"><a href="#创建-Starter-工程" class="headerlink" title="创建 Starter 工程"></a>创建 Starter 工程</h3><p>使用 <code>maven-archetype-quickstart</code> 架手架创建一个 Maven 工程，artifactId 设置为 <code>zombie-spring-boot-starter</code>。</p>
<p>在 <code>pom.xml</code> 文件中引入依赖的 jar 包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>设置以 jar 包的方式打包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="定义服务类"><a href="#定义服务类" class="headerlink" title="定义服务类"></a>定义服务类</h3><p>定义一个服务类 <code>ZombieService</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZombieService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Zombie <span class="title function_">setZombie</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">        <span class="type">Zombie</span> <span class="variable">zombie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zombie</span>();</span><br><span class="line">        zombie.setName(name);</span><br><span class="line">        zombie.setAge(age);</span><br><span class="line">        <span class="keyword">return</span> zombie;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义配置类"><a href="#定义配置类" class="headerlink" title="定义配置类"></a>定义配置类</h3><p>定义一个自动配置类，一般是以 <code>*AutoConfiguration</code> 的形式命名的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(ZombieService.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZombieAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(ZombieService.class)</span></span><br><span class="line">    <span class="keyword">public</span> ZombieService <span class="title function_">zombieService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ZombieService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常用的注解"><a href="#常用的注解" class="headerlink" title="常用的注解"></a>常用的注解</h4><ul>
<li><p>@ConditionalOnClass：当类路径classpath下有指定的类的情况下进行自动配置</p>
</li>
<li><p>@ConditionalOnMissingClass：当类路径下没有指定的类的条件下</p>
</li>
<li><p>@ConditionalOnBean：当容器(Spring Context)中有指定的Bean的条件下</p>
</li>
<li><p>@ConditionalOnMissingBean：当容器(Spring Context)中没有指定Bean的情况下进行自动配置</p>
</li>
</ul>
<h3 id="配置-spring-factories"><a href="#配置-spring-factories" class="headerlink" title="配置 spring.factories"></a>配置 spring.factories</h3><p>在 <code>resources/META-INF/spring.factories</code> 下配置自动配置类。如果没有该文件的话，需要手动创建。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">com.qinghuazs.zombie.auto.ZombieAutoConfiguration</span></span><br></pre></td></tr></table></figure>

<h3 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h3><p>在发布之前需要在 <code>pom.xml</code> 文件中配置仓库信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>qinghuazs-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>qinghuazs-release<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://af.qinghuazs.com.cn:80/artifactory/maven-qinghuazs-release<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>qinghuazs-snapshot<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>qinghuazs-snapshot<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://af.qinghuazs.com.cn:80/artifactory/maven-qinghuazs-snapshot<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>进行发布</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mvn clean install</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mvn deploy</span></span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>新建测试项目，并在 <code>pom.xml</code> 中引入自定义的 Starter：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qinghuazs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zombie-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>自建 Controller 类，并引入 Starter 中的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ZombieService zombieService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> zombieService.setZombie(<span class="string">&quot;qinghuazs&quot;</span>, <span class="number">11</span>).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Postman 测试，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Zombie(name=qinghuazs, age=11)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot端口配置</title>
    <url>/2018/12/20/SpringBoot%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>SpringBoot的默认端口是8080，如果想要修改端口信息，可以通过以下两种方式</p>
<h3 id="配置文件修改"><a href="#配置文件修改" class="headerlink" title="配置文件修改"></a>配置文件修改</h3><p>在application.properties或application.yml文件中修改server.port</p>
<h4 id="修改application-properties"><a href="#修改application-properties" class="headerlink" title="修改application.properties"></a>修改application.properties</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server.port=<span class="number">8090</span></span><br></pre></td></tr></table></figure>

<h4 id="修改application-yml"><a href="#修改application-yml" class="headerlink" title="修改application.yml"></a>修改application.yml</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8090</span></span><br></pre></td></tr></table></figure>


<h3 id="在命令行中指定启动端口"><a href="#在命令行中指定启动端口" class="headerlink" title="在命令行中指定启动端口"></a>在命令行中指定启动端口</h3><p>比如传入参数–server.port&#x3D;8090</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -jar sprite.jar --server.port=<span class="number">8090</span></span><br></pre></td></tr></table></figure>

<p>或者传入虚拟机系统属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -Dserver.port=<span class="number">8090</span> -jar sprite.jar</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot设置项目的图标</title>
    <url>/2018/07/01/SpringBoot%E8%AE%BE%E7%BD%AE%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9B%BE%E6%A0%87/</url>
    <content><![CDATA[<p>准备一个favicon.ico文件，放在resources下的static文件夹中即可</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot集成Swagger</title>
    <url>/2018/06/27/SpringBoot%E9%9B%86%E6%88%90Swagger/</url>
    <content><![CDATA[<p>在项目中引入Swagger，方便前后端进行接口的定义、测试和联调</p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;dependency&gt;</span></span><br><span class="line">    <span class="string">&lt;groupId&gt;io.springfox&lt;/groupId&gt;</span></span><br><span class="line">    <span class="string">&lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span></span><br><span class="line">    <span class="string">&lt;version&gt;2.8.0&lt;/version&gt;</span></span><br><span class="line"><span class="string">&lt;/dependency&gt;</span></span><br><span class="line"><span class="string">&lt;dependency&gt;</span></span><br><span class="line">    <span class="string">&lt;groupId&gt;io.springfox&lt;/groupId&gt;</span></span><br><span class="line">    <span class="string">&lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span></span><br><span class="line">    <span class="string">&lt;version&gt;2.8.0&lt;/version&gt;</span></span><br><span class="line"><span class="string">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">api</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.lemon.swagger&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;api文档&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;RESTFUL接口&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="EnableSwagger2"><a href="#EnableSwagger2" class="headerlink" title="@EnableSwagger2"></a>@EnableSwagger2</h4><p>启动Swagger</p>
<h4 id="Docket"><a href="#Docket" class="headerlink" title="Docket"></a>Docket</h4><p>制定配置信息和扫描包的路径</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/show&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;测试接口&quot;, notes = &quot;测试接口详细描述&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@ApiParam(required = true, name = &quot;name&quot;, value = &quot;姓名&quot;)</span></span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(name = &quot;name&quot;)</span> String strName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;输入的姓名为-------&gt;&quot;</span> + strName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动项目，在浏览器上输入访问地址<a href="http://127.0.0.1:8080/swagger-ui.html">http://127.0.0.1:8080/swagger-ui.html</a>即可</p>
<h3 id="Swagger常用注解"><a href="#Swagger常用注解" class="headerlink" title="Swagger常用注解"></a>Swagger常用注解</h3><ul>
<li>@Api 作用在类上，说明该类的作用</li>
<li>@ApiOperation 作用在方法上，说明方法的作用，标注在具体的请求上，value和notes作用差不多，都是对请求进行说明，tags则是对请求进行分类的，比如你有好几个controller，分别属于不同的功能模块，那这里我们就可以使用tags来区分了</li>
<li>@ApiImplicitParams 用在方法上包含一组参数说明</li>
<li>@ApiImplicitParam 用在@ApiImplicitParams注解中，制定一个请求参数的各个方面</li>
<li>@ApiResponses 用于表示一组响应</li>
<li>@ApiResponse 用在@ApiResponses中，一版用于表达一个错误的响应信息</li>
<li>@ApiModel 描述一个Model的信息，表明这是一个被swagger框架管理的model，用于class上</li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/2018/12/24/SpringMVC/</url>
    <content><![CDATA[<h3 id="在浏览器中输入网址并回车后发生了什么？"><a href="#在浏览器中输入网址并回车后发生了什么？" class="headerlink" title="在浏览器中输入网址并回车后发生了什么？"></a>在浏览器中输入网址并回车后发生了什么？</h3><p>在浏览器中输入网址并回车后，浏览器先在本地 hosts 文件中查询域名和 IP 的对应关系，如果有，则向 IP 地址发送请求，如果没有，则去 DNS 服务器查询。</p>
<h3 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h3><p>DispatcherServlet 是 SpringMVC 的核心控制器，用于处理 HTTP 请求处理和控制。</p>
<p>dispatcher，即调度员</p>
<p>特点</p>
<ul>
<li>基于 JavaBean 配置机制</li>
<li>可以使用任何的 HandlerMapping 实现来控制对处理程序对象的请求的路由，默认是 BeanNameUrlHandlerMapping 和 RequestMappingHandlerMapping</li>
<li>TODO</li>
</ul>
<p>主要流程：</p>
<p>1、文件上传解析，如果请求类型是multipart将通过MultipartResolver进行文件上传解析；</p>
<p>2、通过HandlerMapping，将请求映射到处理器（返回一个HandlerExecutionChain，它包括一个处理器、多个HandlerInterceptor拦截器）；</p>
<p>3、通过HandlerAdapter支持多种类型的处理器(HandlerExecutionChain中的处理器)；</p>
<p>4、通过ViewResolver解析逻辑视图名到具体视图实现；</p>
<p>5、本地化解析；</p>
<p>6、渲染具体的视图等；</p>
<p>7、如果执行过程中遇到异常将交给HandlerExceptionResolver来解析。</p>
<p>最终调用的方法为 doDispatch。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//检查是否是文件上传请求</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当期请求的HandlerExecutionChain</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="comment">//返回null时。会调用noHandlerFound，抛出异常或返回请求找不到的错误信息</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span> || mappedHandler.getHandler() == <span class="literal">null</span>) &#123;</span><br><span class="line">            	noHandlerFound(processedRequest, response);</span><br><span class="line">            	<span class="keyword">return</span>;</span><br><span class="line">        	&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前请求的处理器适配器</span></span><br><span class="line">            <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Last-Modified value for [&quot;</span> + getRequestUri(request) + <span class="string">&quot;] is: &quot;</span> + lastModified);</span><br><span class="line">                &#125;</span><br><span class="line">        		<span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">        			<span class="keyword">return</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Actually invoke the handler.</span></span><br><span class="line">				mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				applyDefaultViewName(processedRequest, mv);</span><br><span class="line">				mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">				dispatchException = ex;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">				<span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line">				<span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">				dispatchException = <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">			&#125;</span><br><span class="line">			processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">			triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">					<span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler processing failed&quot;</span>, err));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">				<span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">				<span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">					mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">				<span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">					cleanupMultipart(processedRequest);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="checkMultipart-检查是否是文件上传请求"><a href="#checkMultipart-检查是否是文件上传请求" class="headerlink" title="checkMultipart 检查是否是文件上传请求"></a>checkMultipart 检查是否是文件上传请求</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HttpServletRequest <span class="title function_">checkMultipart</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> MultipartException &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.multipartResolver != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.multipartResolver.isMultipart(request)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (WebUtils.getNativeRequest(request, MultipartHttpServletRequest.class) != <span class="literal">null</span>) &#123;</span><br><span class="line">         logger.debug(<span class="string">&quot;Request is already a MultipartHttpServletRequest - if not in a forward, &quot;</span> +</span><br><span class="line">               <span class="string">&quot;this typically results from an additional MultipartFilter in web.xml&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//文件解析异常</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (hasMultipartException(request) ) &#123;</span><br><span class="line">         logger.debug(<span class="string">&quot;Multipart resolution failed for current request before - &quot;</span> +</span><br><span class="line">               <span class="string">&quot;skipping re-resolution for undisturbed error rendering&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">		   <span class="comment">//请求转化          </span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.multipartResolver.resolveMultipart(request);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (MultipartException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) != <span class="literal">null</span>) &#123;</span><br><span class="line">               logger.debug(<span class="string">&quot;Multipart resolution failed for error dispatch&quot;</span>, ex);</span><br><span class="line">               <span class="comment">// Keep processing error dispatch with regular request handle below</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如遇异常或非文件上传请求，则返回原始请求</span></span><br><span class="line">   <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getHandler"><a href="#getHandler" class="headerlink" title="getHandler"></a>getHandler</h4><p>实现如下，返回当前请求对应的 HandlerExecutionChain。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="keyword">for</span> (HandlerMapping hm : <span class="built_in">this</span>.handlerMappings) &#123;</span><br><span class="line">		<span class="comment">//省略日志信息</span></span><br><span class="line">        </span><br><span class="line">         <span class="comment">//根据请求去获取对应的处理器执行链</span></span><br><span class="line">		<span class="type">HandlerExecutionChain</span> <span class="variable">handler</span> <span class="operator">=</span> hm.getHandler(request);</span><br><span class="line">		<span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> handler;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//没有找到对应的处理器执行链，则返回null</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HandlerMapping 都存放在 handlerMappings 变量中，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;HandlerMapping&gt; handlerMappings;</span><br></pre></td></tr></table></figure>

<p>在 initStrategies 方法中进行 handlerMappings 的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initStrategies</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">   initMultipartResolver(context);</span><br><span class="line">   initLocaleResolver(context);</span><br><span class="line">   initThemeResolver(context);</span><br><span class="line">   <span class="comment">//初始化handlerMappings</span></span><br><span class="line">   initHandlerMappings(context);</span><br><span class="line">   initHandlerAdapters(context);</span><br><span class="line">   initHandlerExceptionResolvers(context);</span><br><span class="line">   initRequestToViewNameTranslator(context);</span><br><span class="line">   initViewResolvers(context);</span><br><span class="line">   initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>initHandlerMappings 的作用是初始化所有的HandlerMapping，具体实现如下：</p>
<p>ancestor 祖先</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.handlerMappings = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//是否加载所有的 HandlerMapping</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.detectAllHandlerMappings) &#123;</span><br><span class="line">      <span class="comment">// 找到ApplicationContext中的所有HandlerMapping，包括上级的上下文</span></span><br><span class="line">      Map&lt;String, HandlerMapping&gt; matchingBeans =</span><br><span class="line">            BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line">         <span class="built_in">this</span>.handlerMappings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;HandlerMapping&gt;(matchingBeans.values());</span><br><span class="line">         <span class="comment">// 对HandlerMapping进行排序</span></span><br><span class="line">         AnnotationAwareOrderComparator.sort(<span class="built_in">this</span>.handlerMappings);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//加载单一的HandlerMapping</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//public static final String HANDLER_MAPPING_BEAN_NAME = &quot;handlerMapping&quot;;</span></span><br><span class="line">         <span class="type">HandlerMapping</span> <span class="variable">hm</span> <span class="operator">=</span> context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);</span><br><span class="line">         <span class="built_in">this</span>.handlerMappings = Collections.singletonList(hm);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">         <span class="comment">// Ignore, we&#x27;ll add a default HandlerMapping later.</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注册一个默认的HandlerMapping，以保证至少有一个HandlerMapping存在</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">&quot;No HandlerMappings found in servlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;: using default&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册默认的HandlerMapping</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">getDefaultStrategies</span><span class="params">(ApplicationContext context, Class&lt;T&gt; strategyInterface)</span> &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> strategyInterface.getName();</span><br><span class="line">   <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> defaultStrategies.getProperty(key);</span><br><span class="line">   <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">      String[] classNames = StringUtils.commaDelimitedListToStringArray(value);</span><br><span class="line">      List&lt;T&gt; strategies = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;(classNames.length);</span><br><span class="line">      <span class="keyword">for</span> (String className : classNames) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader());</span><br><span class="line">            <span class="type">Object</span> <span class="variable">strategy</span> <span class="operator">=</span> createDefaultStrategy(context, clazz);</span><br><span class="line">            strategies.add((T) strategy);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanInitializationException</span>(</span><br><span class="line">                  <span class="string">&quot;Could not find DispatcherServlet&#x27;s default strategy class [&quot;</span> + className +</span><br><span class="line">                        <span class="string">&quot;] for interface [&quot;</span> + key + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (LinkageError err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanInitializationException</span>(</span><br><span class="line">                  <span class="string">&quot;Error loading DispatcherServlet&#x27;s default strategy class [&quot;</span> + className +</span><br><span class="line">                        <span class="string">&quot;] for interface [&quot;</span> + key + <span class="string">&quot;]: problem with class file or dependent class&quot;</span>, err);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> strategies;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;T&gt;();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找不到请求对应的处理器映射器时，执行noHandlerFound方法，响应结束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">noHandlerFound</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="keyword">if</span> (pageNotFoundLogger.isWarnEnabled()) &#123;</span><br><span class="line">      pageNotFoundLogger.warn(<span class="string">&quot;No mapping found for HTTP request with URI [&quot;</span> + getRequestUri(request) +</span><br><span class="line">            <span class="string">&quot;] in DispatcherServlet with name &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.throwExceptionIfNoHandlerFound) &#123;</span><br><span class="line">   	  <span class="comment">//抛出异常</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoHandlerFoundException</span>(request.getMethod(), getRequestUri(request),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletServerHttpRequest</span>(request).getHeaders());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">   	  <span class="comment">//返回HttpServletResponse.SC_NOT_FOUND，即404</span></span><br><span class="line">      response.sendError(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取处理器适配器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerAdapter <span class="title function_">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">   <span class="comment">//handlerAdapters 处理器适配器集合，存放所有的处理器适配器 </span></span><br><span class="line">   <span class="keyword">for</span> (HandlerAdapter ha : <span class="built_in">this</span>.handlerAdapters) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;Testing handler adapter [&quot;</span> + ha + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 检查适配器是否支持给定的处理器</span></span><br><span class="line">      <span class="keyword">if</span> (ha.supports(handler)) &#123;</span><br><span class="line">         <span class="keyword">return</span> ha;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 找不到对应的适配器则抛出异常</span></span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;No adapter for handler [&quot;</span> + handler +</span><br><span class="line">         <span class="string">&quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h3><p>接口</p>
<p><strong>请求到处理器的映射</strong>，如果映射成功返回一个 HandlerExecutionChain 对象（包含一个 Handler 处理器（页面控制器）对象、多个 HandlerInterceptor 拦截器）对象；如 BeanNameUrlHandlerMapping 将 URL 与 Bean 名字映射，映射成功的 Bean 就是此处的处理器。</p>
<p>handler 处理器，其实就是 Controller</p>
<p>former 前面的，前者</p>
<p>wrapped 包裹，包含</p>
<p>optionally 可选</p>
<p>accompanied 伴随着</p>
<p>parameterize 参数</p>
<p>unusual 特殊的，不同寻常的</p>
<p>flexible 灵活的</p>
<p>custom 定制的</p>
<p>开发人员可以实现该接口，但是并没有太大的必要，因为 SpringMVC 提供了两个处理器：BeanNameUrlHandlerMapping 和 DefaultAnnotationHandlerMapping，默认的处理器是 BeanNameUrlHandlerMapping 。</p>
<p>HandlerMapping 实现类可以提供匹配的拦截器，但是这些可选的，并不是必须要提供。处理器始终在 HandlerExecutionChain 实例中，可选地伴随着某些 HandlerInterceptor 实例 。 DispatcherServlet 将以指定的顺讯先调用每个  HandlerInterceptor  的 preHandle 方法， 如果每个 preHandle 方法都返回 true， 才会执行处理器的方法。</p>
<p>参数化映射的能力是 SpringMVC 框架提供的强大的不同寻常的功能。例如，开发人员可以根据 session 状态、cookie 状态或其他变量去编写一个自定义的映射器。其他的 MVC 框架并没有这么灵活。</p>
<blockquote>
<p>实现类可以去实现 org.springframework.core.Ordered 接口， 指定排序，以保证 DispatcherServlet 的优先级。无序的实例以最低优先级对待。</p>
</blockquote>
<p><strong>使用了模板方法模式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerMapping</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * HttpServletRequest中包含处理器映射路径的属性的名称</span></span><br><span class="line"><span class="comment">	 * 模式匹配和完整的相关 URI（通常在 DispatcherServlet 的映射中）例外</span></span><br><span class="line"><span class="comment">	 * relevant 相应的</span></span><br><span class="line"><span class="comment">	 * scenarios 场景</span></span><br><span class="line"><span class="comment">	 * 注意：该属性对所有 HandlerMapping 实现来说不是必需的。</span></span><br><span class="line"><span class="comment">	 * 基于 URL 的 HandlerMappings 通常会支持它，但处理程序不要求在所有场景中都存在此请求属性。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE</span> <span class="operator">=</span> HandlerMapping.class.getName() + <span class="string">&quot;.pathWithinHandlerMapping&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * HttpServletRequest包含处理程序映射中最佳匹配模式的属性的名称。</span></span><br><span class="line"><span class="comment">	 * 注意：该属性对所有 HandlerMapping 实现来说不是必需的。</span></span><br><span class="line"><span class="comment">	 * 基于 URL 的 HandlerMappings 通常会支持它，但处理程序不要求在所有场景中都存在此请求属性。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">BEST_MATCHING_PATTERN_ATTRIBUTE</span> <span class="operator">=</span> HandlerMapping.class.getName() + <span class="string">&quot;.bestMatchingPattern&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 布尔 HttpServletRequest 属性的名称，指示是否应检查类型级别映射。</span></span><br><span class="line"><span class="comment">	 * indicate 指示</span></span><br><span class="line"><span class="comment">	 * 注意： 该属性对所有 HandlerMapping 实现来说不是必需的。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">INTROSPECT_TYPE_LEVEL_MAPPING</span> <span class="operator">=</span> HandlerMapping.class.getName() + <span class="string">&quot;.introspectTypeLevelMapping&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * HttpServletRequest 包含 URI 模板映射的属性的名称，将变量名称映射到值。</span></span><br><span class="line"><span class="comment">	 * 注意：该属性对所有 HandlerMapping 实现来说不是必需的。</span></span><br><span class="line"><span class="comment">	 * 基于 URL 的 HandlerMappings 通常会支持它，但处理程序不要求在所有场景中都存在此请求属性。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">URI_TEMPLATE_VARIABLES_ATTRIBUTE</span> <span class="operator">=</span> HandlerMapping.class.getName() + <span class="string">&quot;.uriTemplateVariables&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * HttpServletRequest 包含具有 URI 变量名称的映射的属性的名称</span></span><br><span class="line"><span class="comment">	 * 注意：所有 HandlerMapping 实现都不需要此属性，也可能不存在此属性，</span></span><br><span class="line"><span class="comment">	 * 具体取决于 HandlerMapping 是否配置为保持矩阵变量内容</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">MATRIX_VARIABLES_ATTRIBUTE</span> <span class="operator">=</span> HandlerMapping.class.getName() + <span class="string">&quot;.matrixVariables&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * HttpServletRequest 包含适用于映射处理程序的可生成 MediaType 集的属性的名称</span></span><br><span class="line"><span class="comment">	 * 注意：该属性对所有 HandlerMapping 实现来说不是必需的。</span></span><br><span class="line"><span class="comment">	 * 基于 URL 的 HandlerMappings 通常会支持它，但处理程序不要求在所有场景中都存在此请求属性。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE</span> <span class="operator">=</span> HandlerMapping.class.getName() + <span class="string">&quot;.producibleMediaTypes&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回一个 HandlerExecutionChain 对象，该对象中包含了该请求的处理器和所有的拦截器。</span></span><br><span class="line"><span class="comment">	 * 可以根据请求的 URL， session 的状态，或实现类选择的任何因素进行选择。</span></span><br><span class="line"><span class="comment">	 * HandlerExecutionChain 对象中包含的处理器是 Object 类型的，而不是一个标记接口，所以处理器不会受到任何限制。</span></span><br><span class="line"><span class="comment">	 * 比如，可以编写一个 HandlerAdapter 允许使用另一个框架的处理器。</span></span><br><span class="line"><span class="comment">	 * 如果没有找到匹配的处理器，会返回 null，这并不是错误。</span></span><br><span class="line"><span class="comment">	 * DispatcherServlet 会查询所有注册的 HandlerMapping 以找到对应的匹配项，如果没有找到处理器，才会判定出错</span></span><br><span class="line"><span class="comment">	 * 内部的</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> request 当前的HTTP请求</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 包含处理器对象和所有拦截器的 HandlerExecutionChain 对象，如果没找到，返回 null</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> 如果发生一个内部的错误，则抛出异常</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Ordered"><a href="#Ordered" class="headerlink" title="Ordered"></a>Ordered</h3><p>接口。</p>
<p>Ordered 是一个接口，可以被可比较的对象实现，比如 Collection 类。</p>
<p>actual 实际</p>
<p>interpreted 解释执行，解读</p>
<p>prioritization 优先</p>
<p>实际的排序可以被解读为优先级，值越小，优先级越高，getOrder() 方法可以获取到具体的排序值。</p>
<blockquote>
<p>此接口还有一个优先级的标记：PriorityOrdered，PriorityOrdered 对象表示的排序值始终在普通 Ordered对象表示的相同排序值之前起应用。</p>
</blockquote>
<p>Consult 参考</p>
<p>precedence 优先权，位次</p>
<p>arbitrary 随意的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Ordered</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 最高的优先级</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">HIGHEST_PRECEDENCE</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 最低的优先级</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">LOWEST_PRECEDENCE</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取此对象的排序值</span></span><br><span class="line"><span class="comment">	 * 值越小优先级越高，值越大优先级越低</span></span><br><span class="line"><span class="comment">	 * 相同的排序值，将导致受影响的元素随意的排序</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="PriorityOrdered"><a href="#PriorityOrdered" class="headerlink" title="PriorityOrdered"></a>PriorityOrdered</h3><p>Ordered 接口的扩展，表示优先级排序：</p>
<p>PriorityOrdered 对象表示的顺序值始终在普通 Ordered 对象表示的相同顺序值之前应用。</p>
<p>这主要是一个专用接口，用于首先识别优先级对象尤为重要的对象，甚至不需要获取剩余的对象。一个典型的例子：Spring中的优先级后处理器  ApplicationContext。</p>
<p>注意： PriorityOrdered 后处理器 bean 在特殊阶段初始化，超过其他后处理器 bean。这巧妙地影响了它们的自动装配行为：它们只会针对不需要急切初始化类型匹配的 bean 进行自动装配。</p>
<p>extension 扩展</p>
<p>recognize 识别</p>
<p>phase 阶段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PriorityOrdered</span> <span class="keyword">extends</span> <span class="title class_">Ordered</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Order"><a href="#Order" class="headerlink" title="Order"></a>Order</h3><p>注解类，定义了排序值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Order &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 排序值</span></span><br><span class="line"><span class="comment">	 * 默认值为Ordered.LOWEST_PRECEDENCE，最低优先级</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> Ordered#getOrder()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>value 是可选的，作用和 Ordered 接口中的排序值一样，value 越小，优先级越高，默认值是 Ordered.LOWEST_PRECEDENCE，最低优先级。</p>
<blockquote>
<p>从 Spring 4.0 开始，Spring 中的很多组件都支持基于 Order 注解的排序，即使目标组件的排序值（目标类或 @Bean 方法）考虑的集合注入也是如此。虽然此类排序值可能会影响注入点的优先级，但请注意它们不会影响单例启动顺序，这是由依赖关系和 @DependsOn（影响运行时确定的依赖关系）声明确定的正交关注点。</p>
<p>从 Spring 4.1 开始，标准 Priority 注解可以用作排序方案中该注解的替代品。请注意， @Priority 当必须选择单个元素是，可能会有其他语义。具体参见 <code>AnnotationAwareOrderComparator#getPriority</code>。</p>
<p>也可以通过 Ordered 接口基于每个实例确定排序值，允许配置确定的实例值而不是附加到特定类的硬编码值。</p>
</blockquote>
<p>standard 标准</p>
<p>semantics 语义</p>
<p>Order 注解可以用于类注解、方法注解、字段注解。</p>
<h3 id="OrderUtils"><a href="#OrderUtils" class="headerlink" title="OrderUtils"></a>OrderUtils</h3><p>用于根据类型声明确定对象顺序的常规实用程序 , 用于处理 Spring 的 Order 注解和 Java 的 Priority 注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OrderUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优先级注解类型，使用 javax.annotation.Priority</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; priorityAnnotationType = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">//兼容不同的 JDK 版本</span></span><br><span class="line">			priorityAnnotationType = (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;)</span><br><span class="line">					ClassUtils.forName(<span class="string">&quot;javax.annotation.Priority&quot;</span>, OrderUtils.class.getClassLoader());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="comment">// javax.annotation.Priority 无效，或者存在但是不可装载（JDK6） </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回指定类型的排序值</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Takes care of &#123;<span class="doctag">@link</span> Order <span class="doctag">@Order</span>&#125; and &#123;<span class="doctag">@code</span> <span class="doctag">@javax</span>.annotation.Priority&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> type 要处理的类型，即被注解的类</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 排序值，如果没有找到对应的类型，返回null</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getPriority(Class)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">getOrder</span><span class="params">(Class&lt;?&gt; type)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> getOrder(type, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回指定类型的排序值，如果没有指定的类型，则返回默认的排序值</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Takes care of &#123;<span class="doctag">@link</span> Order <span class="doctag">@Order</span>&#125; and &#123;<span class="doctag">@code</span> <span class="doctag">@javax</span>.annotation.Priority&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> type the type to handle</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the priority value, or the specified default order if none can be found</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getPriority(Class)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">getOrder</span><span class="params">(Class&lt;?&gt; type, Integer defaultOrder)</span> &#123;</span><br><span class="line">         <span class="comment">//优先获取 Order 注解的值</span></span><br><span class="line">		<span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> AnnotationUtils.findAnnotation(type, Order.class);</span><br><span class="line">		<span class="keyword">if</span> (order != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> order.value();</span><br><span class="line">		&#125;</span><br><span class="line">         <span class="comment">// 如果没有声明 Order 注解， 返回 Priority 注解的值</span></span><br><span class="line">		<span class="type">Integer</span> <span class="variable">priorityOrder</span> <span class="operator">=</span> getPriority(type);</span><br><span class="line">		<span class="keyword">if</span> (priorityOrder != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> priorityOrder;</span><br><span class="line">		&#125;</span><br><span class="line">         <span class="comment">// 如果两个注解都为 null， 则返回传入的默认排序值 defaultOrder</span></span><br><span class="line">		<span class="keyword">return</span> defaultOrder;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回 &#123;<span class="doctag">@code</span> javax.annotation.Priority&#125; 注解的值，如果类型上没有声明 Priority 注解，则返回 null</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> type the type to handle</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the priority value if the annotation is declared, or &#123;<span class="doctag">@code</span> null&#125; if none</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">getPriority</span><span class="params">(Class&lt;?&gt; type)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (priorityAnnotationType != <span class="literal">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 获取类上面的 Priority 注解类对象</span></span><br><span class="line">			<span class="type">Annotation</span> <span class="variable">priority</span> <span class="operator">=</span> AnnotationUtils.findAnnotation(type, priorityAnnotationType);</span><br><span class="line">			<span class="keyword">if</span> (priority != <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// 获取注解类的 value 值</span></span><br><span class="line">				<span class="keyword">return</span> (Integer) AnnotationUtils.getValue(priority);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">         <span class="comment">//如果 Priority 注解没有加载，则直接返回 null</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="AbstractHandlerMapping"><a href="#AbstractHandlerMapping" class="headerlink" title="AbstractHandlerMapping"></a>AbstractHandlerMapping</h3><p>抽象类，实现了 HandlerMapping 和 Ordered 接口，同时继承了 WebApplicationObjectSupport 类。</p>
<p>支持排序，拥有一个默认的处理器，一系列处理器拦截器，包括路径模式映射的处理器拦截器。</p>
<blockquote>
<p>该基础类不支持暴露 PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE。对此属性的支持取决于具体的子类，通常基于请求 URL 映射。</p>
</blockquote>
<p>常用的子类有两个：AbstractHandlerMethodMapping 和 AbstractUrlHandlerMapping 。</p>
<p>AbstractHandlerMethodMapping 将具体的 Method 作为 Handler使用</p>
<p>AbstractUrlHandlerMapping 通过 URL 来进行匹配。</p>
<blockquote>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认的处理器</span></span><br><span class="line"><span class="keyword">private</span> Object defaultHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UrlPathHelper 对象，进行 URL 路径匹配</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">UrlPathHelper</span> <span class="variable">urlPathHelper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlPathHelper</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//路径匹配器</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">PathMatcher</span> <span class="variable">pathMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//拦截器列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//拦截器处理器列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;HandlerInterceptor&gt; adaptedInterceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;HandlerInterceptor&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">globalCorsConfigSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//CORS处理器</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">CorsProcessor</span> <span class="variable">corsProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultCorsProcessor</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序值，指定HandlerMapping实现类的执行顺序，默认为 Ordered.LOWEST_PRECEDENCE，最低优先级</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">order</span> <span class="operator">=</span> Ordered.LOWEST_PRECEDENCE;</span><br></pre></td></tr></table></figure>

<p>实现了 HandlerMapping 接口的 getHandler 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">//获取当前请求的处理器，如果没找到对应的处理器，则返回默认的处理器</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> getHandlerInternal(request);</span><br><span class="line">   <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">      handler = getDefaultHandler();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 返回的是Bean Name，则通过bean name创建处理器对象</span></span><br><span class="line">   <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String) handler;</span><br><span class="line">      handler = getApplicationContext().getBean(handlerName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取执行链</span></span><br><span class="line">   <span class="type">HandlerExecutionChain</span> <span class="variable">executionChain</span> <span class="operator">=</span> getHandlerExecutionChain(handler, request);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// CORS 跨越资源共享 判断是否为跨域请求 跨越请求需特殊处理</span></span><br><span class="line">   <span class="keyword">if</span> (CorsUtils.isCorsRequest(request)) &#123;</span><br><span class="line">      <span class="type">CorsConfiguration</span> <span class="variable">globalConfig</span> <span class="operator">=</span> <span class="built_in">this</span>.globalCorsConfigSource.getCorsConfiguration(request);</span><br><span class="line">      <span class="type">CorsConfiguration</span> <span class="variable">handlerConfig</span> <span class="operator">=</span> getCorsConfiguration(handler, request);</span><br><span class="line">      <span class="type">CorsConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> (globalConfig != <span class="literal">null</span> ? globalConfig.combine(handlerConfig) : handlerConfig);</span><br><span class="line">      executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> executionChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getHandlerInternal 方法是一个抽象的方法，由具体的子类来实现，获取当前请求的处理器，如果没找到对应的处理器，则返回null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title function_">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception;</span><br></pre></td></tr></table></figure>

<p>getDefaultHandler 方法即返回默认的处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getDefaultHandler</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.defaultHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getHandlerExecutionChain 方法用于获取请求的执行链</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerExecutionChain <span class="title function_">getHandlerExecutionChain</span><span class="params">(Object handler, HttpServletRequest request)</span> &#123;</span><br><span class="line">   <span class="comment">//如果不存在，则创建一个HandlerExecutionChain对象</span></span><br><span class="line">   <span class="type">HandlerExecutionChain</span> <span class="variable">chain</span> <span class="operator">=</span> (handler <span class="keyword">instanceof</span> HandlerExecutionChain ?</span><br><span class="line">         (HandlerExecutionChain) handler : <span class="keyword">new</span> <span class="title class_">HandlerExecutionChain</span>(handler));</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取请求的路径，相对路径，即Controller中方法配置的请求路径</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">lookupPath</span> <span class="operator">=</span> <span class="built_in">this</span>.urlPathHelper.getLookupPathForRequest(request);</span><br><span class="line">   <span class="comment">//组装拦截器列表</span></span><br><span class="line">   <span class="keyword">for</span> (HandlerInterceptor interceptor : <span class="built_in">this</span>.adaptedInterceptors) &#123;</span><br><span class="line">      <span class="keyword">if</span> (interceptor <span class="keyword">instanceof</span> MappedInterceptor) &#123;</span><br><span class="line">         <span class="comment">//自定义拦截器是否与当前路径匹配，如果相匹配，则加入到拦截器列表中</span></span><br><span class="line">         <span class="type">MappedInterceptor</span> <span class="variable">mappedInterceptor</span> <span class="operator">=</span> (MappedInterceptor) interceptor;</span><br><span class="line">         <span class="keyword">if</span> (mappedInterceptor.matches(lookupPath, <span class="built_in">this</span>.pathMatcher)) &#123;</span><br><span class="line">            chain.addInterceptor(mappedInterceptor.getInterceptor());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         chain.addInterceptor(interceptor);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>initApplicationContext() 方法，初始化时调用，初始化拦截器信息</p>
<h3 id="HandlerInterceptor"><a href="#HandlerInterceptor" class="headerlink" title="HandlerInterceptor"></a>HandlerInterceptor</h3>]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper安装</title>
    <url>/2018/07/04/Zookeeper%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h3><h4 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://mirrors.hust.edu.cn/apache/zookeeper/zookeeper-3.4.12/zookeeper-3.4.12.tar.gz</span><br></pre></td></tr></table></figure>

<h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf zookeeper-3.4.12.tar.gz </span><br></pre></td></tr></table></figure>

<h4 id="检查Java环境"><a href="#检查Java环境" class="headerlink" title="检查Java环境"></a>检查Java环境</h4><p>需要JDK1.6以上的环境</p>
<p>使用<strong>java -version</strong>检查是否安装JDK</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java version &quot;1.8.0_171&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_171-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.171-b11, mixed mode) </span><br></pre></td></tr></table></figure>

<h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@iZbp19q9mzfovzwh6hk6rpZ zookeeper-3.4.12]# pwd</span><br><span class="line">/usr/local/soft/zookeeper/zookeeper-3.4.12</span><br><span class="line">[root@iZbp19q9mzfovzwh6hk6rpZ zookeeper-3.4.12]# vim /etc/profile</span><br></pre></td></tr></table></figure>

<p>添加环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZK_HOME=/usr/local/soft/zookeeper/zookeeper-3.4.12</span><br><span class="line">PATH=$PATH:$ZK_HOME/bin</span><br><span class="line">export PATH ZK_HOME</span><br></pre></td></tr></table></figure>

<p>使配置马上生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@iZbp19q9mzfovzwh6hk6rpZ zookeeper-3.4.12]# source /etc/profile</span><br></pre></td></tr></table></figure>

<h4 id="配置zk"><a href="#配置zk" class="headerlink" title="配置zk"></a>配置zk</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@iZbp19q9mzfovzwh6hk6rpZ zookeeper-3.4.12]# mkdir data</span><br><span class="line">[root@iZbp19q9mzfovzwh6hk6rpZ zookeeper-3.4.12]# mkdir logs</span><br><span class="line">[root@iZbp19q9mzfovzwh6hk6rpZ zookeeper-3.4.12]# cd conf/</span><br><span class="line">[root@iZbp19q9mzfovzwh6hk6rpZ conf]# ll</span><br><span class="line">total 12</span><br><span class="line">-rw-rw-r-- 1 1000 1000  535 Mar 27 12:32 configuration.xsl</span><br><span class="line">-rw-rw-r-- 1 1000 1000 2161 Mar 27 12:32 log4j.properties</span><br><span class="line">-rw-rw-r-- 1 1000 1000  922 Mar 27 12:32 zoo_sample.cfg</span><br><span class="line">[root@iZbp19q9mzfovzwh6hk6rpZ conf]# cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>

<p>修改zoo.cfg中的配置，如下所示</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The number of milliseconds of each tick</span></span><br><span class="line"><span class="string">tickTime=2000</span></span><br><span class="line"><span class="comment"># The number of ticks that the initial </span></span><br><span class="line"><span class="comment"># synchronization phase can take</span></span><br><span class="line"><span class="string">initLimit=20</span></span><br><span class="line"><span class="comment"># The number of ticks that can pass between </span></span><br><span class="line"><span class="comment"># sending a request and getting an acknowledgement</span></span><br><span class="line"><span class="string">syncLimit=5</span></span><br><span class="line"><span class="comment"># the directory where the snapshot is stored.</span></span><br><span class="line"><span class="comment"># do not use /tmp for storage, /tmp here is just </span></span><br><span class="line"><span class="comment"># example sakes.</span></span><br><span class="line"><span class="string">dataDir=/usr/local/soft/zookeeper/zookeeper-3.4.12/data</span></span><br><span class="line"><span class="string">dataLogDir=/usr/local/soft/zookeeper/zookeeper-3.4.12/logs</span></span><br><span class="line"><span class="comment"># the port at which the clients will connect</span></span><br><span class="line"><span class="string">clientPort=2181</span></span><br><span class="line"><span class="comment"># the maximum number of client connections.</span></span><br><span class="line"><span class="comment"># increase this if you need to handle more clients</span></span><br><span class="line"><span class="comment">#maxClientCnxns=60</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Be sure to read the maintenance section of the </span></span><br><span class="line"><span class="comment"># administrator guide before turning on autopurge.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The number of snapshots to retain in dataDir</span></span><br><span class="line"><span class="comment">#autopurge.snapRetainCount=3</span></span><br><span class="line"><span class="comment"># Purge task interval in hours</span></span><br><span class="line"><span class="comment"># Set to &quot;0&quot; to disable auto purge feature</span></span><br><span class="line"><span class="comment">#autopurge.purgeInterval=1</span></span><br><span class="line"><span class="string">server.1=127.0.0.1:2888:3888</span></span><br></pre></td></tr></table></figure>
<p>其中：<br>2888端口号是zookeeper服务之间通信的端口<br>3888是zookeeper与其他应用程序通信的端口</p>
<h4 id="启动与停止"><a href="#启动与停止" class="headerlink" title="启动与停止"></a>启动与停止</h4><p>切换到zookeeper的bin目录下</p>
<h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./zkServer.sh start</span><br></pre></td></tr></table></figure>

<h5 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jps </span><br></pre></td></tr></table></figure>

<p>其中QuorumPeerMain是zookeeper进程，启动正常</p>
<h5 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./zkServer.sh status</span><br></pre></td></tr></table></figure>
<h5 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./zkServer.sh stop</span><br></pre></td></tr></table></figure>

<h4 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h4><p>切换到&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;目录下 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/rc.d/init.d</span><br></pre></td></tr></table></figure>

<p>创建zookeeper文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch zookeeper </span><br></pre></td></tr></table></figure>
<p>更新权限  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x zookeeper </span><br></pre></td></tr></table></figure>

<p>编辑文件，写入一下内容</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment">#chkconfig:2345 20 90  </span></span><br><span class="line"><span class="comment">#description:zookeeper  </span></span><br><span class="line"><span class="comment">#processname:zookeeper  </span></span><br><span class="line"><span class="string">export</span> <span class="string">JAVA_HOME=/usr/local/soft/jdk/jdk1.8.0_171</span>  </span><br><span class="line"><span class="string">export</span> <span class="string">PATH=$JAVA_HOME/bin:$PATH</span></span><br><span class="line"><span class="string">ZK_HOME=/usr/local/soft/zookeeper/zookeeper-3.4.12</span></span><br><span class="line"><span class="string">case</span> <span class="string">$1</span> <span class="string">in</span>  </span><br><span class="line">          <span class="string">start)su</span> <span class="string">root</span> <span class="string">$ZK_HOME/bin/zkServer.sh</span> <span class="string">start;;</span>  </span><br><span class="line">          <span class="string">stop)su</span> <span class="string">root</span> <span class="string">$ZK_HOME/bin/zkServer.sh</span> <span class="string">stop;;</span>  </span><br><span class="line">          <span class="string">status)su</span> <span class="string">root</span> <span class="string">$ZK_HOME/bin/zkServer.sh</span> <span class="string">status;;</span>  </span><br><span class="line">          <span class="string">restart)su</span> <span class="string">root</span> <span class="string">$ZK_HOME/bin/zkServer.sh</span> <span class="string">restart;;</span>  </span><br><span class="line">          <span class="string">*)</span>  <span class="string">echo</span> <span class="string">&quot;require start|stop|status|restart&quot;</span>  <span class="string">;;</span>  </span><br><span class="line"><span class="string">esac</span></span><br></pre></td></tr></table></figure>

<p>这样就可以用service zookeeper start&#x2F;stop来启动停止zookeeper服务了</p>
<p>使用命令把zookeeper添加到开机启动里面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chkconfig zookeeper on  </span><br><span class="line">chkconfig --add zookeeper</span><br></pre></td></tr></table></figure>

<p>然后通过chkconfig –list查看是否已成功添加到开机启动项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zookeeper      	0:off	1:off	2:on	3:on	4:on	5:on	6:off</span><br></pre></td></tr></table></figure>




































]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>idea的后悔药:本地文件删除后恢复</title>
    <url>/2020/04/27/idea%E5%90%8E%E6%82%94%E8%8D%AF%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>在使用 idea 开发时，创建了一个类，但是这个类并没有纳入到版本控制中，如果不小心把这个类删除了，该怎么办？重新花时间去写一个一样的类？但是项目马上就要交付了，哪有那么多时间重新写一个啊，而且还要花时间把原来的功能重新测试一遍！</p>
<p>别慌，idea 的 <code>Local History</code> 功能帮你免除这种烦恼！</p>
<p>现在我们有一个类 <code>Regression</code> ， 这个类里面实现了一些逻辑</p>
<p><img src="http://qinghuazs-blog.oss-cn-beijing.aliyuncs.com/image-1587544032764.png" alt="图1"></p>
<p> <code>Regression</code> 类不小心被删掉了</p>
<p><img src="http://qinghuazs-blog.oss-cn-beijing.aliyuncs.com/image-1587544223951.png" alt="图2"></p>
<p>这时候，可以选中 <code>regression</code> 包，点击右键，从菜单中找到 <code>Local History</code>，再点击 <code>Show History</code> 子菜单</p>
<p><img src="http://qinghuazs-blog.oss-cn-beijing.aliyuncs.com/image-1587544358267.png" alt="图3"></p>
<p>此时，会出现一个弹窗，弹窗内容分为两部分，左侧是 <code>regression</code> 包的操作记录，右侧是每条记录操作的具体内容</p>
<p><img src="http://qinghuazs-blog.oss-cn-beijing.aliyuncs.com/image-1587544517192.png" alt="图4"></p>
<p>根据记录，可以看到5分钟之前删除了 <code>Regression</code> 类，此时我们选中右侧的  <code>Regression</code> 类，右键，点击 <code>Revert Selection</code> 菜单即可恢复 <code>Regression</code> 类</p>
<p><img src="http://qinghuazs-blog.oss-cn-beijing.aliyuncs.com/image-1587544767375.png" alt="图5"></p>
]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenSSL生成SSL证书</title>
    <url>/2018/06/22/openSSL%E7%94%9F%E6%88%90SSL%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<h4 id="创建私钥"><a href="#创建私钥" class="headerlink" title="创建私钥"></a>创建私钥</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl genrsa -des3 -passout pass:qinghuazs12345+ -out private.key 2048 -subj &quot;/CN=Finance/OU=qinghuazs/O=qinghuazs/L=HZ/ST=ZJ/C=CN&quot;</span><br></pre></td></tr></table></figure>
<h4 id="根据私钥生成公钥"><a href="#根据私钥生成公钥" class="headerlink" title="根据私钥生成公钥"></a>根据私钥生成公钥</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl rsa -in private.key -pubout -out public.key</span><br></pre></td></tr></table></figure>
<p>此处需要输入私钥的密码，直接输入qinghuazs12345+即可</p>
<h4 id="证书请求"><a href="#证书请求" class="headerlink" title="证书请求"></a>证书请求</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl req -new -nodes -key private.key -out cert.csr</span><br></pre></td></tr></table></figure>
<p>这里将生成一个新的文件cert.csr，即一个证书请求文件，你可以拿着这个文件去数字证书颁发机构（即CA）申请一个数字证书。CA会给你一个新的文件cacert.pem，那才是包含公钥给对方用的数字证书。</p>
<h4 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h4><p>自签名证书，用于自己测试，不需要CA签发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl req -new -x509 -key private.key -out cacert.pem -days 36500</span><br></pre></td></tr></table></figure>

<p>至此，生成的证书已经可以使用了。</p>
]]></content>
      <categories>
        <category>OpenSSL</category>
      </categories>
      <tags>
        <tag>OpenSSL</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>内部类</title>
    <url>/2018/03/17/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>Java 中，可以在一个类的内部定义另外一个类，这个内部定义的类，就称为内部类</p>
<p>内部类是一种非常有用的特性，它允许你把一些逻辑相关的类组织在一起，并控制位于内部的类的可见性</p>
<p>当生成一个内部类的对象时，此对象与创建它的外部类的对象之间就有了一种联系，所以它能访问其外部类对象的所有成员，而不需要任何特殊条件；此外，内部类还拥有其外部类的所有元素的访问权</p>
<p>如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须具体的制定这个对象的类型： OuterClassName.InnerClassName</p>
<p>创建内部类的对象时，需要使用外部类的对象去创建该内部类的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在拥有外部类的对象之前，是不能创建内部类对象的，这是因为内部类对象会暗中的链接到创建它的外部类对象上；但是如果你创建的是静态内部类，那么它就不需要对外部类对象的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;静态内部类创建测试！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<pre><code>静态内部类创建测试！
</code></pre>
<p>如果是其他的外部类中创建 Inner 内部类的对象，则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();</span><br><span class="line">        inner.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>静态内部类创建测试！
</code></pre>
<p>内部类，隐藏实现细节</p>
<p>方法和作用域内的内部类-局部内部类</p>
<p>可以在方法里面或者任意的作用域内定义内部类</p>
<p>方法内的内部类常常用于回调</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LocalInner</span> &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LocalInner <span class="title function_">getLocalInner</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">MyLocalInner</span> <span class="keyword">implements</span> <span class="title class_">LocalInner</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;local inner&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyLocalInner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">		<span class="type">LocalInner</span> <span class="variable">localInner</span> <span class="operator">=</span> outer.getLocalInner();</span><br><span class="line">		<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> localInner.value();</span><br><span class="line">        System.out.println(value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">local inner</span><br></pre></td></tr></table></figure>

<p>匿名内部类</p>
<p>比较常见的匿名内部类就是创建线程时用到的匿名内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Runnable <span class="title function_">thread</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名内部类末尾有个分号，这个分号不是用来标记内部类结束的；实际上，它标记的是表达式的结束</p>
<p>如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数引用是 final 的；否则，将出现编译错误</p>
<p>在匿名类中不可能有命名构造器（因为它根本没名字），但是可以通过实例初始化，达到为匿名内部类创建一个构造器的效果</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>动态代理</title>
    <url>/2018/12/23/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>JDK</li>
<li>CGLIB</li>
<li>Javassist</li>
<li>ASM</li>
</ul>
<h3 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h3><p>在 JDK 动态代理中，要实现代理逻辑类必须去实现 <code>java.lang.reflect.InvocationHandler</code> 接口</p>
<p>必须提供接口和实现</p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloImpl</span> <span class="keyword">implements</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代理对象"><a href="#代理对象" class="headerlink" title="代理对象"></a>代理对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//真实对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立代理对象和真实对象的代理关系，并返回代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 真实对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">bind</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入代理逻辑方法&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;在调度真实对象之前的服务&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> method.invoke(target, args);<span class="comment">//相当于调用say方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;在调度真实对象之后的服务&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this)</p>
<ul>
<li>第一个参数是类加载器</li>
<li>第二个参数是把生成的动态代理对象挂在那些接口下</li>
<li>第三个参数是定义实现方法逻辑的代理类，这里是当前对象，必须实现 InvocationHandler 的 invoke 方法</li>
</ul>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">HelloProxy</span> <span class="variable">helloProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloProxy</span>();</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">proxy</span> <span class="operator">=</span> (Hello) helloProxy.bind(<span class="keyword">new</span> <span class="title class_">HelloImpl</span>());</span><br><span class="line">        proxy.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">进入代理逻辑方法</span><br><span class="line">在调度真实对象之前的服务</span><br><span class="line">hello world!</span><br><span class="line">在调度真实对象之后的服务</span><br></pre></td></tr></table></figure>

<h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>优势在于不需要提供接口，只要一个非抽象类就能实现动态代理</p>
<h4 id="被代理类"><a href="#被代理类" class="headerlink" title="被代理类"></a>被代理类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloImpl2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代理类"><a href="#代理类" class="headerlink" title="代理类"></a>代理类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成CGLIB代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz Class类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(Class clazz)</span> &#123;</span><br><span class="line">        <span class="comment">//CGLIB enhancer 增强类对象</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//设置增强类型</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="comment">//定义代理逻辑对象为当前对象，要求当前对象实现MethodInterceptor的intercept方法</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//生成并返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理逻辑方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 方法代理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理逻辑返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用真实对象前&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> methodProxy.invokeSuper(proxy, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;调用真实对象后&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">CglibProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CglibProxy</span>();</span><br><span class="line">        <span class="type">HelloImpl2</span> <span class="variable">obj</span> <span class="operator">=</span> (HelloImpl2) proxy.getProxy(HelloImpl2.class);</span><br><span class="line">        obj.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用真实对象前</span><br><span class="line">hello world!</span><br><span class="line">调用真实对象后</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库事务</title>
    <url>/2018/12/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="特性ACID"><a href="#特性ACID" class="headerlink" title="特性ACID"></a>特性ACID</h2><ul>
<li>原子性 Atomicity</li>
<li>一致性 Consistency</li>
<li>隔离性 Isolation</li>
<li>持久性 Durability</li>
</ul>
<h3 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性 Atomicity"></a>原子性 Atomicity</h3><p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，事务的各个元素是不可分的，事务是一个完整操作。</p>
<h3 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性 Consistency"></a>一致性 Consistency</h3><p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p>
<p>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
<h3 id="隔离性-Isolation"><a href="#隔离性-Isolation" class="headerlink" title="隔离性 Isolation"></a>隔离性 Isolation</h3><p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p>即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>
<h3 id="持久性-Durability"><a href="#持久性-Durability" class="headerlink" title="持久性 Durability"></a>持久性 Durability</h3><p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<p>例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p>
<h2 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如果不考虑事务的隔离性，会发生几种问题</p>
<h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</p>
<p>当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户A向用户B转账100元，对应SQL命令如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">100</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;  (此时A通知B)</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">100</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。</p>
<h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p>
<p>例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。</p>
<p>不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</p>
<p>在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了……</p>
<h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p>
<p>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><h4 id="Serializable-串行化"><a href="#Serializable-串行化" class="headerlink" title="Serializable 串行化"></a>Serializable 串行化</h4><p>可避免脏读、不可重复读、幻读的发生。</p>
<h4 id="Repeatable-read-可重复读"><a href="#Repeatable-read-可重复读" class="headerlink" title="Repeatable read 可重复读"></a>Repeatable read 可重复读</h4><p>可避免脏读、不可重复读的发生。</p>
<h4 id="Read-committed-读已提交"><a href="#Read-committed-读已提交" class="headerlink" title="Read committed 读已提交"></a>Read committed 读已提交</h4><p>可避免脏读的发生。</p>
<h4 id="Read-uncommitted-读未提交"><a href="#Read-uncommitted-读未提交" class="headerlink" title="Read uncommitted 读未提交"></a>Read uncommitted 读未提交</h4><p>最低级别，任何情况都无法保证。</p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然<strong>级别越高，执行效率就越低</strong>。像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。**在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)**。</p>
<p>在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)；而在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之队列</title>
    <url>/2018/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>队列（queue），是先进先出（FIFO, First-In-First-Out）的线性表。在具体应用中通常用链表或者数组来实现。</p>
<p>队列的操作方式和堆栈类似，唯一的区别在于<font color="red">队列只允许新数据在后端进行添加</font>。</p>
<p>队列只允许在后端（称为 rear ）进行插入操作，在前端（称为 front ）进行删除操作。进行插入操作的端称为队尾，进行删除操作的端称为队头。从队头删除元素的操作叫做出队，从队尾追加元素的操作叫做入队。</p>
<p>队列可分为三种：顺序队列、循环队列、双端队列</p>
<h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><p>顺序存储结构存储的队列称为顺序队列。和顺序表一样，用一个一维数组存。队头在数组的低下标端，队尾设在高下表端。队头，队尾指针值是数组元素的下标。队头指针始终指向队头结点的前一个结点位置，初始值为-1（理论上应该为0，但是Java中索引是从0开始的，索引为0代表队列中第一个元素，所以定为-1）。队尾指针是指向队尾结点位置，初始值也为-1。</p>
<p>队列中没有元素时，称为空队列， </p>
<ul>
<li><p>初始化条件：<code>front=rear=-1</code> </p>
</li>
<li><p>队列空的条件：<code>front=rear</code></p>
</li>
<li><p>队列满的条件： <code>rear = MAXSIZE</code></p>
</li>
</ul>
<h4 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderQueue</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Object[] data;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">front</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">rear</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 队列的长度</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> length;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_LENGTH</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 默认长度的队列</span></span><br><span class="line"><span class="comment">	 * 创建一个新的实例OrderQueue.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">OrderQueue</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">			length = DEFAULT_LENGTH;</span><br><span class="line">		&#125;</span><br><span class="line">		data = <span class="keyword">new</span> <span class="title class_">Object</span>[length];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 指定队列的长度</span></span><br><span class="line"><span class="comment">	 * 创建一个新的实例OrderQueue.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">OrderQueue</span><span class="params">(<span class="type">int</span> length)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.length = length;</span><br><span class="line">		data = <span class="keyword">new</span> <span class="title class_">Object</span>[length];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 入队</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> qinghuazangshui 2018年7月27日 上午11:02:30</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> v1.0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">in</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (rear == length-<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		data[++rear] = obj;</span><br><span class="line">		<span class="keyword">return</span> obj;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 入列</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> qinghuazangshui 2018年7月27日 上午11:11:15</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> v1.0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">pull</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (rear == length-<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;队列已满&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		data[++rear] = obj;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 出队</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> qinghuazangshui 2018年7月27日 上午11:18:57</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> v1.0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(front == rear) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		front++;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> data[front];</span><br><span class="line">		data[front] = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">return</span> obj;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 出队</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> qinghuazangshui 2018年7月27日 上午11:19:06</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> v1.0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">push</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(front == rear) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;队列已空&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		front++;</span><br><span class="line">		data[front] = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(Arrays.toString(data));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestOrderQueue</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">OrderQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderQueue</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">10</span>; i&lt;<span class="number">23</span>; i++) &#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> queue.in(i);</span><br><span class="line">			System.out.println(obj);</span><br><span class="line">		&#125;</span><br><span class="line">		queue.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环向队列中添加元素，队列的默认长度是10，插入操作结束后打印当前队列的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span><br></pre></td></tr></table></figure>
<p>可以看到，当插入10个元素后开始返回null值，表示队列已满，插入失败；最终打印的结果也只有10个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestOrderQueue</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">OrderQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderQueue</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">10</span>; i&lt;<span class="number">23</span>; i++) &#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> queue.in(i);</span><br><span class="line">			<span class="comment">//System.out.println(obj);</span></span><br><span class="line">		&#125;</span><br><span class="line">		queue.print();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------分割线------------&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> queue.out();</span><br><span class="line">			<span class="keyword">if</span>(obj == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(obj);</span><br><span class="line">		&#125;</span><br><span class="line">		queue.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>]</span><br><span class="line">-----------分割线------------</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line">[<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>]</span><br></pre></td></tr></table></figure>

<p>每次出队都返回此次出队的元素，并将队头指针向后移动一位，同时将原有索引的位置置空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestOrderQueue</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">OrderQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderQueue</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">10</span>; i&lt;<span class="number">23</span>; i++) &#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> queue.in(i);</span><br><span class="line">			<span class="comment">//System.out.println(obj);</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//queue.print();</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//System.out.println(&quot;-----------分割线------------&quot;);</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> queue.out();</span><br><span class="line">			<span class="keyword">if</span>(obj == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//System.out.println(obj);</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//queue.print();</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> queue.in(<span class="number">10</span>);</span><br><span class="line">		System.out.println(obj);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将所有元素出队后，再向队列中添加元素，返回null值，即添加失败；但是队列中明明10个位置都是空的，可用的。这就是顺序队列中的<strong>假溢出</strong>问题。</p>
<h4 id="假溢出"><a href="#假溢出" class="headerlink" title="假溢出"></a>假溢出</h4><p>队尾指针已经指向队尾，即rear &#x3D; length-1；但是队列的前面部分仍有可用空间，但是此时已经不能再向队列中插入元素了，此种情况称为“假溢出”</p>
<p>解决假溢出的方法，可以在每次元素出队时，所有元素整体向前移动，让空的存储单元留在队尾</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">out2</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(front == rear) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	front++;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> data[front];</span><br><span class="line">	</span><br><span class="line">	Object[] temp = <span class="keyword">new</span> <span class="title class_">Object</span>[length];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=front+<span class="number">1</span>; i&lt;=rear; i++) &#123;</span><br><span class="line">		temp[i-<span class="number">1</span>] = data[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=rear+<span class="number">1</span>; i&lt;length; i++) &#123;</span><br><span class="line">		temp[i] = <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	data = temp;</span><br><span class="line">	front = -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">OrderQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderQueue</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">10</span>; i&lt;<span class="number">23</span>; i++) &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> queue.in(i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	System.out.println(queue.out2());</span><br><span class="line">	queue.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">[11, 12, 13, 14, 15, 16, 17, 18, 19, null]</span><br></pre></td></tr></table></figure>

<p>可以看出，不再出现假溢出的问题</p>
<p>但是，这种处理方式涉及到大量的对象创建和数据移动，性能很低；还有一种较巧妙的解决方法，那就是循环队列</p>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>循环队列可以更简单防止伪溢出的发生，但队列大小是固定的。</p>
<p>循环队列应用范围广泛，比如Linux内核当中的环形缓冲区就是基于循环队列来设计的。</p>
<p>循环队列：采用环状顺序表来存放队列元素，有两个指针，其中 front 指针指向队列的队头元素，rear指针指向队尾元素的下一个位置，往队列中加进或取出元素时分别改变这两个变量的计数。当头尾指针（front &#x2F; rear）指向队列尾的元素（下标：QueueSize-1）时，其加1操作的结果是指向向量的下界0。</p>
<p>循环队列中，由于入队时尾指针向前追赶头指针；出队时头指针向前追赶尾指针，造成队空和队满时头尾指针均相等。因此，无法通过条件front&#x3D;&#x3D;rear来判别队列是”空”还是”满”。</p>
<p>解决这个问题的方法至少有三种：</p>
<ul>
<li>另设一布尔变量以区别队列的空和满；</li>
<li>少用一个元素的空间。约定入队前，测试尾指针在循环意义下加1后是否等于头指针，若相等则认为队满（注意：rear所指的单元始终为空）；</li>
<li>使用一个计数器记录队列中元素的总数（即队列长度）。</li>
</ul>
<p>此处我们采用第二种方式，少用一个元素的空间，根据尾指针在循环意义下加1后是否等于头指针判断队列是否满</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>初始化条件： <code>front == rear == 0</code></li>
<li>队列满条件： <code>MOD(rear+1,m) == front</code></li>
<li>队列空条件： <code>front == rear</code></li>
<li>队头指针推进计算: <code>front = MOD(front+1,m)</code></li>
<li>队尾指针推进计算: <code>rear = MOD(rear+1,m)</code></li>
</ul>
<h4 id="Java实现-1"><a href="#Java实现-1" class="headerlink" title="Java实现"></a>Java实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CycleQueue</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Object[] data;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">front</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">rear</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> length;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">CycleQueue</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.data = <span class="keyword">new</span> <span class="title class_">Object</span>[DEFAULT_CAPACITY];</span><br><span class="line">		length = data.length;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">full</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ((rear + <span class="number">1</span>) % length == front) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (front == rear) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">in</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (full()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		data[rear] = obj;</span><br><span class="line">		rear = (rear + <span class="number">1</span>) % length;</span><br><span class="line">		<span class="keyword">return</span> obj;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (empty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> data[front];</span><br><span class="line">		data[front] = <span class="literal">null</span>;</span><br><span class="line">		front = (front + <span class="number">1</span>) % length;</span><br><span class="line">		<span class="keyword">return</span> obj;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(Arrays.toString(data));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试1"><a href="#测试1" class="headerlink" title="测试1"></a>测试1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">CycleQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CycleQueue</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">10</span>; i&lt;<span class="number">23</span>; i++) &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> queue.in(i);</span><br><span class="line">		System.out.println(obj);</span><br><span class="line">	&#125;</span><br><span class="line">	queue.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试向循环队列中插入元素，当插入9个元素后，判定队列已满（空闲一个元素位置，用于区分队列满和队列空），所以不再插入元素。</p>
<p>输出结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line">[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="literal">null</span>]</span><br></pre></td></tr></table></figure>

<h4 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">CycleQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CycleQueue</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">10</span>; i&lt;<span class="number">23</span>; i++) &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> queue.in(i);</span><br><span class="line">		<span class="comment">//System.out.println(obj);</span></span><br><span class="line">	&#125;</span><br><span class="line">	queue.print();</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	System.out.println(<span class="string">&quot;-----------分割线------------&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> queue.out();</span><br><span class="line">		<span class="keyword">if</span>(obj == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(obj);</span><br><span class="line">	&#125;</span><br><span class="line">	queue.print();</span><br><span class="line">       System.out.println(queue.empty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从循环队列中取元素，然后再打印查看效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="literal">null</span>]</span><br><span class="line">-----------分割线------------</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line">[<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>]</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>可以看到，调用出队方法后，队列中元素置为null，队列为空</p>
<h4 id="测试3"><a href="#测试3" class="headerlink" title="测试3"></a>测试3</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">CycleQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CycleQueue</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">10</span>; i&lt;<span class="number">23</span>; i++) &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> queue.in(i);</span><br><span class="line">		<span class="comment">//System.out.println(obj);</span></span><br><span class="line">	&#125;</span><br><span class="line">	queue.print();</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	System.out.println(<span class="string">&quot;-----------分割线------------&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> queue.out();</span><br><span class="line">		<span class="keyword">if</span>(obj == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//System.out.println(obj);</span></span><br><span class="line">	&#125;</span><br><span class="line">	queue.print();</span><br><span class="line">	</span><br><span class="line">	System.out.println(queue.empty());</span><br><span class="line"></span><br><span class="line">	queue.in(<span class="number">20</span>);</span><br><span class="line">	queue.in(<span class="number">21</span>);</span><br><span class="line">	queue.in(<span class="number">22</span>);</span><br><span class="line">	queue.in(<span class="number">23</span>);</span><br><span class="line">	queue.in(<span class="number">24</span>);</span><br><span class="line">	queue.in(<span class="number">25</span>);</span><br><span class="line">	queue.in(<span class="number">26</span>);</span><br><span class="line">	queue.in(<span class="number">27</span>);</span><br><span class="line">	queue.in(<span class="number">28</span>);</span><br><span class="line">	queue.in(<span class="number">29</span>);</span><br><span class="line">	queue.print();</span><br><span class="line">	</span><br><span class="line">	System.out.println(queue.full());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>队列为空后，再向队列中插入元素，输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="literal">null</span>]</span><br><span class="line">-----------分割线------------</span><br><span class="line">[<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>]</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">[<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="literal">null</span>, <span class="number">20</span>]</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>可以看到空元素的位置发生了变化，元素29因为队列已满，并没有插入成功，调用full()方法返回true，队列已满。</p>
<h3 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h3><p>TODO  </p>
<p>等整理完链表的实现再来完善</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云OSS：Put bucket request is not resource owner</title>
    <url>/2018/07/12/%E9%98%BF%E9%87%8C%E4%BA%91OSS%EF%BC%9APut%20bucket%20request%20is%20not%20resource%20owner/</url>
    <content><![CDATA[<p>使用阿里云 OSS SDK 创建 Bucket 时，出现如下错误：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">com.aliyun.oss.OSSException: Put bucket request is not resource owner.</span><br><span class="line">[ErrorCode]: AccessDenied</span><br><span class="line">[RequestId]: 5E821469BB409736367FAEA5</span><br><span class="line">[HostId]: qinghuazs-test.oss-cn-hangzhou.aliyuncs.com</span><br><span class="line">[ResponseError]:</span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Error</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Code</span>&gt;</span>AccessDenied<span class="tag">&lt;/<span class="name">Code</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Message</span>&gt;</span>Put bucket request is not resource owner.<span class="tag">&lt;/<span class="name">Message</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">RequestId</span>&gt;</span>5E821469BB409736367FAEA5<span class="tag">&lt;/<span class="name">RequestId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">HostId</span>&gt;</span>qinghuazs-test.oss-cn-hangzhou.aliyuncs.com<span class="tag">&lt;/<span class="name">HostId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Error</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>权限不足，用户不具备创建 Bucket 的权限，检查后发现虽然创建了用户，但是用户并未加入到用户组中，所以会创建失败。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>1）为用户添加AliyunOSSFullAccess（管理对象存储服务（OSS）权限）的权限</p>
<p>2）将用户添加到用户组下</p>
]]></content>
      <categories>
        <category>OSS</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
        <tag>OSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring之类的优先级设置</title>
    <url>/2022/04/16/Order%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="Order注解"><a href="#Order注解" class="headerlink" title="Order注解"></a>Order注解</h3><p><code>@Order</code> 注解定义了类、方法和字段的优先级（排序情况），<code>value</code> 是可选的，默认为Ordered.LOWEST_PRECEDENCE，即最低优先级。表示 <code>Ordered</code> 接口中的 order 属性。</p>
<blockquote>
<p>目前看到的 @Order 注解都是用在类上的，没有看到过用在方法和字段上的，包括 Spring 自有类 DefaultErrorAttributes、LogbackLoggingSystem.Factory 等。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Order &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 优先级排序值，value 的值越大，优先级越低</span></span><br><span class="line"><span class="comment">	 * 默认值为 Ordered.LOWEST_PRECEDENCE(Integer.MAX_VALUE) </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> Ordered#getOrder()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 Spring 4.0 开始，Spring 中的很多组件都支持基于 <code>Order</code> 注解的排序，使用了该注解后，会影响依赖注入的优先级，但是不影响bean的加载顺序，因为加载顺序受依赖关系和 <code>@DependsOn</code>声明影响的。</p>
<blockquote>
<p>这句理解上还是有问题~</p>
</blockquote>
<p>从 Spring 4.1 开始，<code>jakarta.annotation.Priority</code> 可在一些排序场景中替代 <code>@Order</code> 的作用，但是在修饰单个元素时，<code>@Priority</code> 可能具有其他语义。</p>
<p>除了这两个注解外，也可以实现 <code>Ordered</code> 接口，来设置优先级信息，相对使用注解的方式更加灵活。</p>
<h3 id="Priority注解"><a href="#Priority注解" class="headerlink" title="Priority注解"></a>Priority注解</h3><p><code>@Priority</code> 注解位于 <code>jakarta.annotation</code> 包下，可以标识类或参数以什么样的顺序来执行或使用。</p>
<p><code>Priority</code> 注解的具体作用由具体的使用类来定义，如在Jakarta Interceptors 规范定义了使用拦截器的优先级来控制调用拦截器的顺序。</p>
<p><code>value</code> 一般情况下应该是非负值，负值作为保留值有特定的含义，如“未定义”或“未指定”等。</p>
<p>定义 <code>@Priority</code> 使用的规范可以定义允许的优先级范围和任何具有特殊含义的优先级值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE,PARAMETER&#125;)</span> <span class="comment">//只能用于TYPE和PARAMETER，这是和Order注解不一样的地方</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Priority &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优先级排序值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Priority</code> 的 <code>value</code> 越小，优先级越高。</p>
<h3 id="OrderUtils类"><a href="#OrderUtils类" class="headerlink" title="OrderUtils类"></a>OrderUtils类</h3><p><code>OrderUtils</code> 用于对添加了 <code>@Order</code>注解和 <code>@Priority</code>注解的类，根据声明的顺序和优先级进行处理，相当于是两个注解的具体实现。</p>
<p><code>OrderUtils</code> 提供了三个常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于缓存每个Class的排序值value，如果没有使用 @Order注解，则使用NOT_ANNOTATED标记记录</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;AnnotatedElement, Object&gt; orderCache = <span class="keyword">new</span> <span class="title class_">ConcurrentReferenceHashMap</span>&lt;&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//未用 @Order 注解的缓存标记</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">NOT_ANNOTATED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Priority注解的类路径</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JAVAX_PRIORITY_ANNOTATION</span> <span class="operator">=</span> <span class="string">&quot;jakarta.annotation.Priority&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>针对 <code>@Order</code> 和 <code>@Priority</code> 注解提供了4个 <code>getOrder</code> 的方法，进行排序值的获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取某个类的排序值，如果排序值未设置，则返回默认值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">(Class&lt;?&gt; type, <span class="type">int</span> defaultOrder)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">order</span> <span class="operator">=</span> getOrder(type);</span><br><span class="line">    <span class="keyword">return</span> (order != <span class="literal">null</span> ? order : defaultOrder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取某个类的排序值，如果排序值未设置，则返回默认值</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">getOrder</span><span class="params">(Class&lt;?&gt; type, <span class="meta">@Nullable</span> Integer defaultOrder)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">order</span> <span class="operator">=</span> getOrder(type);</span><br><span class="line">    <span class="keyword">return</span> (order != <span class="literal">null</span> ? order : defaultOrder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取某个类的排序值，可返回null值</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">getOrder</span><span class="params">(Class&lt;?&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getOrder((AnnotatedElement) type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取某个类的排序值，可返回null值</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">getOrder</span><span class="params">(AnnotatedElement element)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getOrderFromAnnotations(element, MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，<code>getOrder(Class&lt;?&gt; type, int defaultOrder)</code> 和 <code>getOrder(Class&lt;?&gt; type, @Nullable Integer defaultOrder)</code>调用了 <code>getOrder(Class&lt;?&gt; type) </code>， 而 <code>getOrder(Class&lt;?&gt; type) </code> 则调用了 <code>getOrder(AnnotatedElement element)</code>。</p>
<p>看看 <code>getOrderFromAnnotations</code> 的具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从指定的 Order注解集合中返回对应的顺序值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">static</span> Integer <span class="title function_">getOrderFromAnnotations</span><span class="params">(AnnotatedElement element, MergedAnnotations annotations)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!(element <span class="keyword">instanceof</span> Class)) &#123;</span><br><span class="line">        <span class="keyword">return</span> findOrder(annotations);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//缓存中是否已存在</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">cached</span> <span class="operator">=</span> orderCache.get(element);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//转换成Integer类型</span></span><br><span class="line">        <span class="keyword">return</span> (cached <span class="keyword">instanceof</span> Integer ? (Integer) cached : <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取Order的排序值，并写入到orderCache中</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> findOrder(annotations);</span><br><span class="line">    orderCache.put(element, result != <span class="literal">null</span> ? result : NOT_ANNOTATED);</span><br><span class="line">    <span class="comment">//返回排序值</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Integer <span class="title function_">findOrder</span><span class="params">(MergedAnnotations annotations)</span> &#123;</span><br><span class="line">    <span class="comment">//判断是否加了Order注解，如果加了，则获取VALUE值，并返回</span></span><br><span class="line">    MergedAnnotation&lt;Order&gt; orderAnnotation = annotations.get(Order.class);</span><br><span class="line">    <span class="keyword">if</span> (orderAnnotation.isPresent()) &#123;</span><br><span class="line">        <span class="keyword">return</span> orderAnnotation.getInt(MergedAnnotation.VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否加了Priority注解，如果加了，则获取VALUE值，并返回</span></span><br><span class="line">    MergedAnnotation&lt;?&gt; priorityAnnotation = annotations.get(JAVAX_PRIORITY_ANNOTATION);</span><br><span class="line">    <span class="keyword">if</span> (priorityAnnotation.isPresent()) &#123;</span><br><span class="line">        <span class="keyword">return</span> priorityAnnotation.getInt(MergedAnnotation.VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Order和Priority注解都没有，则返回null值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后针对 <code>@Priority</code> 注解单独提供了 <code>getPriority(Class&lt;?&gt; type)</code> 方法，获取优先级的数值，如果没有添加注解或者 <code>value</code> 未设值，则返回 null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">getPriority</span><span class="params">(Class&lt;?&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MergedAnnotations.from(type, SearchStrategy.TYPE_HIERARCHY).get(JAVAX_PRIORITY_ANNOTATION)</span><br><span class="line">        .getValue(MergedAnnotation.VALUE, Integer.class).orElse(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Ordered接口"><a href="#Ordered接口" class="headerlink" title="Ordered接口"></a>Ordered接口</h3><p>优先级排序接口，和 <code>@Order</code> 注解一样，获取到的 order 值越小，优先级越高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最高优先级</span></span><br><span class="line"><span class="type">int</span> <span class="variable">HIGHEST_PRECEDENCE</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最低的优先级</span></span><br><span class="line"><span class="type">int</span> <span class="variable">LOWEST_PRECEDENCE</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br></pre></td></tr></table></figure>

<p>提供获取排序值的方法，如果两个对象的 order 值相同，则会进行随机排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<h3 id="PriorityOrdered接口"><a href="#PriorityOrdered接口" class="headerlink" title="PriorityOrdered接口"></a>PriorityOrdered接口</h3><p><code>Ordered</code>接口的扩展接口，表示优先级排序。</p>
<p><code>PriorityOrdered</code> 接口的优先级要高于 <code>Ordered</code>接口的优先级，即使后者对应的 order 值比较小，也是 <code>PriorityOrdered</code> 的优先级高。</p>
<p>在对一组对象进行排序时， <code>PriorityOrdered</code>对象和 <code>Ordered</code>对象可以被看作两个单独的子集，其中一组 <code>PriorityOrdered</code>对象位于一组 <code>Ordered</code> 对象之前，然后在这两个子集中再根据 order 进行相对排序。</p>
<p><code>PriorityOrdered</code> 是一个专用接口，用于标记特别重要的的对象，甚至不需要获取剩余的对象，比如 Spring 中优先级比较高的后置处理器  <code>ApplicationContext</code> 。<code>PriorityOrdered </code> 相关的后置处理器 Bean 在特殊阶段进行初始化，早于其他的后置处理器，这巧妙地影响了它们的自动装配行为：只会针对不需要急切初始化类型匹配的 bean 进行自动装配。</p>
<p><code>PriorityOrdered</code> 的应用可参见 <code>org.springframework.beans.factory.config.PropertyOverrideConfigurer</code> 类。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot排序之Order注解</title>
    <url>/2022/04/17/SpringBoot%E6%8E%92%E5%BA%8F%E4%B9%8BOrder%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p><code>@Order</code> 注解定义了类、方法和字段的优先级（排序情况），<code>value</code> 是可选的，默认为Ordered.LOWEST_PRECEDENCE，即最低优先级。表示 <code>Ordered</code> 接口中的 order 属性。</p>
<blockquote>
<p>目前看到的 @Order 注解都是用在类上的，没有看到过用在方法和字段上的，包括 Spring 自有类 DefaultErrorAttributes、LogbackLoggingSystem.Factory 等。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Order &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 优先级排序值，value 的值越大，优先级越低</span></span><br><span class="line"><span class="comment">	 * 默认值为 Ordered.LOWEST_PRECEDENCE(Integer.MAX_VALUE) </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> Ordered#getOrder()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 Spring 4.0 开始，Spring 中的很多组件都支持基于 <code>Order</code> 注解的排序，但是使用了该注解后，不会影响bean的加载顺序，Bean的加载顺序是由依赖关系和 @DependsOn 注解来决定的。</p>
<p>我们定义两个bean：OrderBean1和OrderBean2，然后通过 @Bean 注入到容器中，启动 SpringBoot 应用，看看打印情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderBean1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderBean1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init Order Bean 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderBean2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderBean2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init Order Bean 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Order(200)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BeanConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bean config&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OrderBean1 <span class="title function_">orderBean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderBean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Order(100)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanConfig2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BeanConfig2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bean config 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OrderBean2 <span class="title function_">orderBean2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderBean2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然 BeanConfig 和 BeanConfig2 都加了 Order 注解，且 BeanConfig2 的优先级更高，但是实际的日志打印是</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line">bean config</span><br><span class="line">bean config <span class="number">2</span></span><br><span class="line">init Order Bean <span class="number">1</span></span><br><span class="line">init Order Bean <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>BeanConfig2 并没有优先于 BeanConfig 进行加载。</p>
<p>如果想要 BeanConfig2 优先加载，可以借助 @DependsOn 注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@DependsOn(&quot;beanConfig2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanConfig1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BeanConfig1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bean config 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@DependsOn(&quot;orderBean2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> OrderBean1 <span class="title function_">orderBean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderBean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志打印为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bean config 2</span><br><span class="line">bean config 1</span><br><span class="line">init Order Bean 2</span><br><span class="line">init Order Bean 1</span><br></pre></td></tr></table></figure>

<p>那 Order 注解在什么场景下才能使用呢？在进行执行顺序的排序时使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderBean</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">order</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Order(200)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderBean1</span> <span class="keyword">implements</span> <span class="title class_">OrderBean</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">order</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;order bean1 ---&gt;  order command&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Order(100)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderBean2</span> <span class="keyword">implements</span> <span class="title class_">OrderBean</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">order</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;order bean2 ---&gt;  order command&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanCommandConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BeanCommandConfig</span><span class="params">(List&lt;OrderBean&gt; orderBeans)</span> &#123;</span><br><span class="line">        orderBeans.forEach(orderBean -&gt; orderBean.order());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出信息为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">order bean2 ---&gt;  order command</span><br><span class="line">order bean1 ---&gt;  order command</span><br></pre></td></tr></table></figure>

<p>可以看到，先删除了 bean2 的内容，再输出了 bean1 的内容。</p>
<p>SpringBoot中的典型应用就是 CommandLineRunner。</p>
<blockquote>
<p>Interface used to indicate that a bean should run when it is contained within a SpringApplication. Multiple CommandLineRunner beans can be defined within the same application context and can be ordered using the Ordered interface or @Order annotation.</p>
<p>翻译：多个CommandLineRunner bean 可以在同一个应用程序上下文中定义，并且可以使用Ordered接口或@Order注释进行排序</p>
</blockquote>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(5)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runner1</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;runner 1 start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runner2</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;runner 2 start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>启动 SpringBoot 工程，查看控制台输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">runner 2 start</span><br><span class="line">runner 1 start</span><br></pre></td></tr></table></figure>

<p>可以看到，两个 Runner 按照配置的优先级执行，先运行 Runner2，再运行 Runner1。</p>
<p>从 Spring 4.1 开始，<code>jakarta.annotation.Priority</code> 可在一些排序场景中替代 <code>@Order</code> 的作用，但是在修饰单个元素时，<code>@Priority</code> 可能具有其他语义。</p>
<p>除了这两个注解外，也可以实现 <code>Ordered</code> 接口，来设置优先级信息，相对使用注解的方式更加灵活。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
</search>
